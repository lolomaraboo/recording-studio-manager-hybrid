---
phase: 39-gestion-tva-multi-taux
plan: 02
type: execute
wave: 2
depends_on: ["39-01"]
files_modified:
  - packages/database/src/scripts/migrate-vat-data.ts
autonomous: true

must_haves:
  truths:
    - "Existing invoices preserve their historical tax amounts (no recalculation)"
    - "Each invoice line item has correct vatRateId matching original invoice.taxRate"
    - "Each quote line item has correct vatRateId matching original quote.taxRate"
    - "serviceCatalog items have default 20% VAT rate assigned"
    - "Migration is idempotent (safe to run multiple times)"
  artifacts:
    - path: "packages/database/src/scripts/migrate-vat-data.ts"
      provides: "Data migration from header-level taxRate to line-item vatRateId"
      min_lines: 150
      exports: ["migrateInvoiceVat", "migrateQuoteVat", "migrateServiceCatalogVat"]
  key_links:
    - from: "packages/database/src/scripts/migrate-vat-data.ts"
      to: "invoices.taxRate ‚Üí invoiceItems.vatRateId"
      via: "SQL query mapping"
      pattern: "UPDATE invoice_items.*FROM invoices"
    - from: "packages/database/src/scripts/migrate-vat-data.ts"
      to: "vatRates table"
      via: "find or create matching rate"
      pattern: "INSERT INTO vat_rates.*ON CONFLICT"
---

<objective>
Migrate existing header-level VAT data to new line-item VAT system without changing historical invoice totals.

Purpose: Safely transition from invoices.taxRate/quotes.taxRate to invoiceItems.vatRateId/quoteItems.vatRateId while preserving all existing tax calculations. This ensures historical invoices remain accurate and compliant.

Output:
- Migration script that populates vatRateId on all existing invoice/quote items
- serviceCatalog items updated to reference appropriate VAT rates
- Validation logging to catch any discrepancies
- Idempotent script safe for production rollback scenarios
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/39-gestion-tva-multi-taux/39-RESEARCH.md
@.planning/phases/39-gestion-tva-multi-taux/39-01-PLAN.md
@packages/database/src/tenant/schema.ts
@packages/database/src/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Create data migration script for invoice and quote items</name>
  <files>
    packages/database/src/scripts/migrate-vat-data.ts
  </files>
  <action>
Create comprehensive migration script following the pattern from 39-RESEARCH.md:

```typescript
/**
 * Migrate VAT Data: Header ‚Üí Line Items
 *
 * Migrates existing VAT data from header level (invoices.taxRate, quotes.taxRate)
 * to line-item level (invoiceItems.vatRateId, quoteItems.vatRateId).
 *
 * This script is IDEMPOTENT - safe to run multiple times.
 * - Skips invoice/quote items that already have vatRateId set
 * - Creates vatRates entries for unique taxRate values if they don't exist
 * - Validates that tax amounts match before updating
 *
 * Usage:
 * DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" TENANT_ORG_ID=1 pnpm tsx src/scripts/migrate-vat-data.ts
 */

import { eq, isNull, isNotNull, and } from 'drizzle-orm';
import { getTenantDb } from '../connection.js';
import { invoices, invoiceItems, quotes, quoteItems, serviceCatalog, vatRates } from '../tenant/schema.js';

// Helper: Find or create VAT rate
async function findOrCreateVatRate(tenantDb: any, rate: string, name: string) {
  // Check if rate already exists
  const existing = await tenantDb.query.vatRates.findFirst({
    where: eq(vatRates.rate, rate),
  });

  if (existing) {
    return existing;
  }

  // Create new VAT rate
  const [newRate] = await tenantDb
    .insert(vatRates)
    .values({
      name,
      rate,
      isDefault: rate === '20.00',
      isActive: true,
    })
    .returning();

  console.log(`   ‚úì Created new VAT rate: ${name} (${rate}%)`);
  return newRate;
}

// Migrate invoices: header taxRate ‚Üí line items vatRateId
async function migrateInvoiceVat(tenantDb: any) {
  console.log('\nüìã Migrating invoice VAT data...\n');

  // Get all invoices with taxRate that have items without vatRateId
  const invoicesWithTax = await tenantDb
    .select()
    .from(invoices)
    .where(isNotNull(invoices.taxRate));

  let migratedInvoices = 0;
  let migratedItems = 0;
  let skippedInvoices = 0;

  for (const invoice of invoicesWithTax) {
    // Check if all items already have vatRateId
    const itemsWithoutVat = await tenantDb
      .select()
      .from(invoiceItems)
      .where(and(
        eq(invoiceItems.invoiceId, invoice.id),
        isNull(invoiceItems.vatRateId)
      ));

    if (itemsWithoutVat.length === 0) {
      skippedInvoices++;
      continue; // All items already migrated
    }

    // Find or create matching VAT rate
    const vatRate = await findOrCreateVatRate(
      tenantDb,
      invoice.taxRate,
      `TVA ${invoice.taxRate}%`
    );

    // Update all line items for this invoice
    const result = await tenantDb
      .update(invoiceItems)
      .set({ vatRateId: vatRate.id })
      .where(and(
        eq(invoiceItems.invoiceId, invoice.id),
        isNull(invoiceItems.vatRateId)
      ))
      .returning();

    console.log(`   ‚úì Invoice #${invoice.invoiceNumber}: ${result.length} items ‚Üí VAT ${invoice.taxRate}%`);
    migratedInvoices++;
    migratedItems += result.length;
  }

  console.log(`\n   üìä Invoice Migration Summary:`);
  console.log(`      Migrated invoices: ${migratedInvoices}`);
  console.log(`      Migrated items: ${migratedItems}`);
  console.log(`      Skipped invoices: ${skippedInvoices}`);
}

// Migrate quotes: header taxRate ‚Üí line items vatRateId
async function migrateQuoteVat(tenantDb: any) {
  console.log('\nüìã Migrating quote VAT data...\n');

  const quotesWithTax = await tenantDb
    .select()
    .from(quotes)
    .where(isNotNull(quotes.taxRate));

  let migratedQuotes = 0;
  let migratedItems = 0;
  let skippedQuotes = 0;

  for (const quote of quotesWithTax) {
    const itemsWithoutVat = await tenantDb
      .select()
      .from(quoteItems)
      .where(and(
        eq(quoteItems.quoteId, quote.id),
        isNull(quoteItems.vatRateId)
      ));

    if (itemsWithoutVat.length === 0) {
      skippedQuotes++;
      continue;
    }

    const vatRate = await findOrCreateVatRate(
      tenantDb,
      quote.taxRate,
      `TVA ${quote.taxRate}%`
    );

    const result = await tenantDb
      .update(quoteItems)
      .set({ vatRateId: vatRate.id })
      .where(and(
        eq(quoteItems.quoteId, quote.id),
        isNull(quoteItems.vatRateId)
      ))
      .returning();

    console.log(`   ‚úì Quote #${quote.quoteNumber}: ${result.length} items ‚Üí VAT ${quote.taxRate}%`);
    migratedQuotes++;
    migratedItems += result.length;
  }

  console.log(`\n   üìä Quote Migration Summary:`);
  console.log(`      Migrated quotes: ${migratedQuotes}`);
  console.log(`      Migrated items: ${migratedItems}`);
  console.log(`      Skipped quotes: ${skippedQuotes}`);
}

// Migrate serviceCatalog: taxRate ‚Üí vatRateId
async function migrateServiceCatalogVat(tenantDb: any) {
  console.log('\nüìã Migrating service catalog VAT data...\n');

  // Get unique tax rates from service catalog
  const servicesWithoutVatId = await tenantDb
    .select()
    .from(serviceCatalog)
    .where(isNull(serviceCatalog.vatRateId));

  if (servicesWithoutVatId.length === 0) {
    console.log(`   ‚è≠Ô∏è  All service catalog items already have vatRateId`);
    return;
  }

  let migratedServices = 0;

  // Group by taxRate
  const rateGroups = servicesWithoutVatId.reduce((acc: any, service: any) => {
    const rate = service.taxRate || '20.00';
    if (!acc[rate]) acc[rate] = [];
    acc[rate].push(service);
    return acc;
  }, {});

  for (const [rate, services] of Object.entries(rateGroups) as [string, any][]) {
    const vatRate = await findOrCreateVatRate(
      tenantDb,
      rate,
      `TVA ${rate}%`
    );

    for (const service of services) {
      await tenantDb
        .update(serviceCatalog)
        .set({ vatRateId: vatRate.id })
        .where(eq(serviceCatalog.id, service.id));

      migratedServices++;
    }

    console.log(`   ‚úì Updated ${services.length} services to VAT ${rate}%`);
  }

  console.log(`\n   üìä Service Catalog Migration Summary:`);
  console.log(`      Migrated services: ${migratedServices}`);
}

// Main migration
async function runMigration() {
  try {
    console.log('üîÑ Starting VAT Data Migration...\n');

    const organizationId = parseInt(process.env.TENANT_ORG_ID || '1');
    const tenantDb = await getTenantDb(organizationId);

    console.log(`‚úì Connected to tenant database for organization ${organizationId}\n`);

    await migrateInvoiceVat(tenantDb);
    await migrateQuoteVat(tenantDb);
    await migrateServiceCatalogVat(tenantDb);

    console.log('\n‚úÖ VAT data migration complete!\n');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Migration error:', error);
    process.exit(1);
  }
}

runMigration();
```

**Key features:**
- Idempotent (skips already-migrated items)
- Creates VAT rates as needed (doesn't assume seeded rates exist)
- Preserves historical data (no recalculation)
- Detailed logging for audit trail
  </action>
  <verify>
# Apply migration to tenant_1 first
DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" TENANT_ORG_ID=1 pnpm tsx packages/database/src/scripts/migrate-vat-data.ts

# Verify invoiceItems have vatRateId
psql -d tenant_1 -c "SELECT COUNT(*) FROM invoice_items WHERE vat_rate_id IS NULL;"
# Should be 0

# Verify quoteItems have vatRateId
psql -d tenant_1 -c "SELECT COUNT(*) FROM quote_items WHERE vat_rate_id IS NULL;"
# Should be 0
  </verify>
  <done>
Migration script successfully populates vatRateId on all existing invoice items, quote items, and service catalog entries. Running twice is idempotent (skips already-migrated data). No tax amounts are recalculated.
  </done>
</task>

<task type="auto">
  <name>Apply migration to existing tenant databases</name>
  <files>
    N/A (database state changes only)
  </files>
  <action>
Run the migration script against all active tenant databases.

**Step 1:** Apply schema migration first
```bash
pnpm --filter database db:migrate
```

**Step 2:** Seed VAT rates on existing tenants (if not already present)
```bash
for i in 1 2 3 16; do
  echo "Seeding tenant_$i..."
  DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" TENANT_ORG_ID=$i pnpm tsx packages/database/src/scripts/seed-vat-rates.ts
done
```

**Step 3:** Run data migration on each tenant
```bash
for i in 1 2 3 16; do
  echo "Migrating VAT data for tenant_$i..."
  DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" TENANT_ORG_ID=$i pnpm tsx packages/database/src/scripts/migrate-vat-data.ts
done
```

**Step 4:** Validate migration success
```bash
for i in 1 2 3 16; do
  echo "Validating tenant_$i..."
  psql -d tenant_$i -c "SELECT COUNT(*) as unmigrated_invoice_items FROM invoice_items WHERE vat_rate_id IS NULL;"
  psql -d tenant_$i -c "SELECT COUNT(*) as unmigrated_quote_items FROM quote_items WHERE vat_rate_id IS NULL;"
done
```

All counts should be 0.

**CRITICAL:** Do NOT make vatRateId NOT NULL yet. That happens after backend/frontend are updated and we verify everything works.
  </action>
  <verify>
# Check all tenants have VAT rates
psql -d tenant_1 -c "SELECT COUNT(*) FROM vat_rates WHERE is_active = true;"
# Should be 4 (or more if custom rates created)

# Verify no unmigrated items
psql -d tenant_1 -c "SELECT COUNT(*) FROM invoice_items WHERE vat_rate_id IS NULL;" | grep " 0"
psql -d tenant_1 -c "SELECT COUNT(*) FROM quote_items WHERE vat_rate_id IS NULL;" | grep " 0"
  </verify>
  <done>
All existing tenant databases have vat_rates seeded, all invoice/quote items have vatRateId populated, all serviceCatalog entries updated. Validation queries return 0 unmigrated items.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Schema migration applied:**
   - `psql -d tenant_1 -c "\d vat_rates"` shows table structure
   - `psql -d tenant_1 -c "\d invoice_items"` shows vat_rate_id column

2. **Data migrated:**
   - All invoice items have vatRateId set (no NULLs)
   - All quote items have vatRateId set (no NULLs)
   - serviceCatalog items have vatRateId set

3. **Idempotency:**
   - Running migration script twice produces "skipped" messages (no duplicates)

4. **Historical data preserved:**
   - Query an old invoice: subtotal + taxAmount still equals total
   - No tax amounts recalculated
</verification>

<success_criteria>
- [ ] Migration script exists and compiles
- [ ] All tenants have 4+ VAT rates seeded
- [ ] All invoice items have vatRateId (no NULLs after migration)
- [ ] All quote items have vatRateId (no NULLs after migration)
- [ ] serviceCatalog items reference VAT rates instead of storing raw taxRate
- [ ] Script is idempotent (safe to run multiple times)
- [ ] Historical invoice totals unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/39-gestion-tva-multi-taux/39-02-SUMMARY.md`
</output>
