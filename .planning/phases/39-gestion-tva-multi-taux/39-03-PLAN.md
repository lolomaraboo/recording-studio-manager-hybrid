---
phase: 39-gestion-tva-multi-taux
plan: 03
type: execute
wave: 2
depends_on: ["39-01"]
files_modified:
  - packages/server/src/routers/vatRates.ts
  - packages/server/src/routers/index.ts
  - packages/shared/src/types/vatRate.ts
autonomous: true

must_haves:
  truths:
    - "API can list active VAT rates for an organization"
    - "API can create new VAT rates with validation (0-100%, 2 decimal precision)"
    - "API prevents deleting VAT rates used in active invoices/quotes"
    - "API can archive VAT rates (soft delete)"
    - "API can set exactly one rate as default (atomic transaction)"
  artifacts:
    - path: "packages/server/src/routers/vatRates.ts"
      provides: "tRPC router for VAT rate CRUD operations"
      min_lines: 200
      exports: ["vatRatesRouter"]
    - path: "packages/shared/src/types/vatRate.ts"
      provides: "Shared TypeScript types for VAT rates"
      exports: ["VatRateFormData", "VatRateWithUsage"]
  key_links:
    - from: "packages/server/src/routers/vatRates.ts"
      to: "ctx.getTenantDb()"
      via: "protectedProcedure context"
      pattern: "ctx\\.getTenantDb\\(\\)"
    - from: "packages/server/src/routers/vatRates.ts"
      to: "archive validation"
      via: "check usage before archiving"
      pattern: "inArray\\(invoices\\.status"
---

<objective>
Create backend tRPC API for VAT rate management with proper validation and protection against data corruption.

Purpose: Provide type-safe API endpoints for creating, reading, updating, and archiving VAT rates. Ensures referential integrity by preventing deletion of rates used in historical invoices.

Output:
- tRPC router with 5 procedures: list, create, update, setDefault, archive
- Shared TypeScript types for request/response
- Input validation using Zod schemas
- Business logic preventing orphaned invoice/quote references
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/39-gestion-tva-multi-taux/39-RESEARCH.md
@packages/server/src/routers/rooms.ts
@packages/server/src/routers/invoices.ts
@packages/database/src/tenant/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Create shared TypeScript types for VAT rates</name>
  <files>
    packages/shared/src/types/vatRate.ts
  </files>
  <action>
Create TypeScript types for VAT rate operations:

```typescript
/**
 * Shared types for VAT Rate management
 */

export interface VatRateFormData {
  name: string;          // "TVA Standard 20%"
  rate: number;          // 20.00
  isDefault: boolean;    // true if default rate
  isActive: boolean;     // true if active
}

export interface VatRateWithUsage {
  id: number;
  name: string;
  rate: string;          // decimal from DB
  isDefault: boolean;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  usageCount?: number;   // Optional: number of invoices/quotes using this rate
}

export interface SetDefaultVatRateInput {
  id: number;
}

export interface ArchiveVatRateInput {
  id: number;
}

export interface CreateVatRateInput {
  name: string;
  rate: number;
  isDefault?: boolean;
}

export interface UpdateVatRateInput {
  id: number;
  name?: string;
  rate?: number;
}
```

Create index export in `packages/shared/src/types/index.ts`:
```typescript
export * from './vatRate';
```
  </action>
  <verify>
grep "export interface VatRateFormData" packages/shared/src/types/vatRate.ts
pnpm --filter shared check
  </verify>
  <done>
Shared types exported from packages/shared with proper TypeScript interfaces for VAT rate operations.
  </done>
</task>

<task type="auto">
  <name>Create tRPC router for VAT rates CRUD</name>
  <files>
    packages/server/src/routers/vatRates.ts
  </files>
  <action>
Create comprehensive tRPC router following the pattern from 39-RESEARCH.md and existing routers:

```typescript
/**
 * VAT Rates Router
 *
 * Handles CRUD operations for organization VAT rates.
 * - List active rates
 * - Create new rate with validation
 * - Update existing rate
 * - Set default rate (atomic transaction)
 * - Archive rate (soft delete with usage validation)
 */

import { router, protectedProcedure } from '../trpc';
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { eq, and, inArray, desc, asc, isNull } from 'drizzle-orm';
import { vatRates, invoiceItems, invoices, quoteItems, quotes } from '@rsm/database/tenant/schema';

export const vatRatesRouter = router({
  /**
   * List all active VAT rates for current organization
   */
  list: protectedProcedure.query(async ({ ctx }) => {
    const tenantDb = await ctx.getTenantDb();

    const rates = await tenantDb.query.vatRates.findMany({
      where: eq(vatRates.isActive, true),
      orderBy: [desc(vatRates.isDefault), asc(vatRates.rate)],
    });

    return rates;
  }),

  /**
   * List ALL rates (active + archived) for admin view
   */
  listAll: protectedProcedure.query(async ({ ctx }) => {
    const tenantDb = await ctx.getTenantDb();

    const rates = await tenantDb.query.vatRates.findMany({
      orderBy: [desc(vatRates.isDefault), desc(vatRates.isActive), asc(vatRates.rate)],
    });

    return rates;
  }),

  /**
   * Create new VAT rate
   */
  create: protectedProcedure
    .input(
      z.object({
        name: z.string().min(1, 'Le nom est requis').max(100, 'Le nom est trop long'),
        rate: z
          .number()
          .min(0, 'Le taux doit être positif')
          .max(100, 'Le taux ne peut pas dépasser 100%'),
        isDefault: z.boolean().default(false),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();

      // If setting as default, unset others first (atomic transaction)
      if (input.isDefault) {
        await tenantDb.transaction(async (tx) => {
          // Unset all existing defaults
          await tx
            .update(vatRates)
            .set({ isDefault: false })
            .where(eq(vatRates.isDefault, true));

          // Insert new rate as default
          const [newRate] = await tx
            .insert(vatRates)
            .values({
              name: input.name,
              rate: input.rate.toFixed(2),
              isDefault: true,
              isActive: true,
            })
            .returning();

          return newRate;
        });
      } else {
        // Insert non-default rate
        const [newRate] = await tenantDb
          .insert(vatRates)
          .values({
            name: input.name,
            rate: input.rate.toFixed(2),
            isDefault: false,
            isActive: true,
          })
          .returning();

        return newRate;
      }

      // Fetch newly created rate
      const created = await tenantDb.query.vatRates.findFirst({
        where: eq(vatRates.name, input.name),
        orderBy: desc(vatRates.createdAt),
      });

      return created;
    }),

  /**
   * Update existing VAT rate (name only - rate changes create new rate)
   */
  update: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        name: z.string().min(1).max(100),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();

      const [updated] = await tenantDb
        .update(vatRates)
        .set({
          name: input.name,
          updatedAt: new Date(),
        })
        .where(eq(vatRates.id, input.id))
        .returning();

      if (!updated) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Taux de TVA introuvable',
        });
      }

      return updated;
    }),

  /**
   * Set a rate as the default (atomic: unset all others, set this one)
   */
  setDefault: protectedProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();

      await tenantDb.transaction(async (tx) => {
        // Unset all defaults
        await tx.update(vatRates).set({ isDefault: false });

        // Set new default
        await tx
          .update(vatRates)
          .set({ isDefault: true, updatedAt: new Date() })
          .where(eq(vatRates.id, input.id));
      });

      return { success: true };
    }),

  /**
   * Archive a VAT rate (soft delete)
   * Prevents archiving if rate is used in active invoices or quotes
   */
  archive: protectedProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();

      // Check if used in active invoices
      const usedInInvoices = await tenantDb
        .select({ id: invoiceItems.id })
        .from(invoiceItems)
        .innerJoin(invoices, eq(invoiceItems.invoiceId, invoices.id))
        .where(
          and(
            eq(invoiceItems.vatRateId, input.id),
            inArray(invoices.status, ['draft', 'sent', 'paid', 'overdue'])
          )
        )
        .limit(1);

      if (usedInInvoices.length > 0) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Impossible d\'archiver ce taux : il est utilisé dans des factures actives',
        });
      }

      // Check if used in active quotes
      const usedInQuotes = await tenantDb
        .select({ id: quoteItems.id })
        .from(quoteItems)
        .innerJoin(quotes, eq(quoteItems.quoteId, quotes.id))
        .where(
          and(
            eq(quoteItems.vatRateId, input.id),
            inArray(quotes.status, ['draft', 'sent', 'accepted'])
          )
        )
        .limit(1);

      if (usedInQuotes.length > 0) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Impossible d\'archiver ce taux : il est utilisé dans des devis actifs',
        });
      }

      // Archive the rate (soft delete)
      const [archived] = await tenantDb
        .update(vatRates)
        .set({
          isActive: false,
          isDefault: false, // Can't be default if archived
          updatedAt: new Date(),
        })
        .where(eq(vatRates.id, input.id))
        .returning();

      if (!archived) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Taux de TVA introuvable',
        });
      }

      return archived;
    }),
});
```

**Key features:**
- Atomic default switching (transaction prevents multiple defaults)
- Validation before archiving (prevents orphaned invoice/quote references)
- Soft delete pattern (preserves historical data)
- French error messages for user-facing errors
  </action>
  <verify>
grep "export const vatRatesRouter" packages/server/src/routers/vatRates.ts
pnpm --filter server check
  </verify>
  <done>
tRPC router created with 6 procedures: list, listAll, create, update, setDefault, archive. All procedures use protectedProcedure, access tenant DB via ctx.getTenantDb(), and include proper validation.
  </done>
</task>

<task type="auto">
  <name>Register VAT rates router in main router</name>
  <files>
    packages/server/src/routers/index.ts
  </files>
  <action>
Add vatRates router to the main tRPC router.

**Import:**
```typescript
import { vatRatesRouter } from './vatRates';
```

**Register in router:**
```typescript
export const appRouter = router({
  // ... existing routers ...
  vatRates: vatRatesRouter,
  // ... rest of routers ...
});
```

Alphabetical ordering recommended (place after `timeTracking`, before or after based on existing order).
  </action>
  <verify>
grep "vatRates: vatRatesRouter" packages/server/src/routers/index.ts
pnpm --filter server check
  </verify>
  <done>
vatRates router registered in main app router. TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **TypeScript validation:**
   - `pnpm check` passes for shared and server packages

2. **Router registration:**
   - `grep "vatRates:" packages/server/src/routers/index.ts` shows registration

3. **API availability (manual test after server start):**
   - Start server: `pnpm --filter server dev`
   - Call API via tRPC client or Postman:
     - `trpc.vatRates.list.query()` returns array of rates
     - `trpc.vatRates.create.mutate({ name: "Test", rate: 15.5 })` creates rate

4. **Validation works:**
   - Creating rate with rate > 100 throws validation error
   - Archiving rate used in active invoice throws BAD_REQUEST error
</verification>

<success_criteria>
- [ ] Shared types exported from packages/shared
- [ ] vatRatesRouter created with 6 procedures
- [ ] All procedures use protectedProcedure and ctx.getTenantDb()
- [ ] setDefault uses transaction for atomic update
- [ ] archive validates usage before allowing soft delete
- [ ] Router registered in main app router
- [ ] TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/39-gestion-tva-multi-taux/39-03-SUMMARY.md`
</output>
