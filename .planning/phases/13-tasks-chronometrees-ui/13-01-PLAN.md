---
phase: 13-tasks-chronometrees-ui
plan: 01
type: execute
---

<objective>
Build timer UI components, live timer widget with Socket.IO, and time history table with manual adjustments.

Purpose: Enable users to track billable time during sessions/projects with visual timer controls and review/edit time entries.
Output: Task Types management page, ActiveTimer widget, TimeHistory table with real-time updates and manual adjustment capabilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Phase 12 Backend (completed):**
Phase 12 delivered complete time tracking backend:
- Database: `task_types` table (name, hourlyRate, category, color, sortOrder)
- Database: `time_entries` table (taskTypeId, sessionId/projectId, startTime, endTime, durationMinutes, hourlyRateSnapshot)
- tRPC API: `timeTrackingRouter` with 8 procedures
  - taskTypes.list/create/update
  - timer.start/stop/getActive
  - timeEntries.list/adjust
- Socket.IO events: timer:started, timer:stopped, timer:adjusted (org-scoped broadcasting)
- Timer service: startTimer, stopTimer, getActiveTimer, adjustTimeEntry, getTimeHistory

**Relevant source files:**
@packages/database/src/tenant/schema.ts (lines 1021-1107: taskTypes, timeEntries schemas)
@packages/server/src/routers/time-tracking.ts (complete tRPC router)
@packages/server/src/services/timer-service.ts (timer business logic)

**UI patterns to follow:**
- Quotes UI (Phase 11-01): Table/form patterns, line items builder
- Client notes (Phase 3.9.1): Timeline display, dated entries
- Existing session/project pages: Detail page structure, cards, tables

**Socket.IO client setup:**
- Socket connection: packages/client/src/socket.ts (if exists) OR create new
- React hooks: useEffect for event listeners, cleanup on unmount
- Pattern: Listen to org-scoped events, update UI state on timer:started/stopped/adjusted

**UI Design Guidelines:**
- Container: `pt-2 pb-4 px-2` (Admin pages)
- Icons: `text-primary` color, `h-8 w-8` size
- Cards: `pb-3` headers, `text-base` titles
- Empty states: `py-6` containers, `h-8` icons
</context>

<tasks>

<task type="auto">
  <name>Task 1: Task Types Management Page</name>
  <files>packages/client/src/pages/TaskTypes.tsx, packages/client/src/App.tsx</files>
  <action>
Create TaskTypesPage for managing task types (CRUD):

**Page structure:**
- Header: "Task Types" title with Settings icon (text-primary, h-8 w-8)
- "Create Task Type" button (top-right)
- Table columns: Name, Hourly Rate, Category (badge), Color (visual indicator), Active status, Actions (edit/delete icons)
- Empty state: "No task types yet" with create button

**Create/Edit modal:**
- Form fields: name (text), description (textarea), hourlyRate (number), category (select: billable/non-billable), color (color picker), sortOrder (number)
- Validation: name required, hourlyRate > 0
- Submit: call trpc.timeTracking.taskTypes.create or update
- Close modal and invalidate query on success

**tRPC integration:**
```tsx
const { data: taskTypes } = trpc.timeTracking.taskTypes.list.useQuery();
const createMutation = trpc.timeTracking.taskTypes.create.useMutation({
  onSuccess: () => utils.timeTracking.taskTypes.list.invalidate(),
});
```

**Routing:**
Add route in App.tsx: `/task-types` → TaskTypesPage

**UI Guidelines:**
- Container: className="pt-2 pb-4 px-2"
- Header icon: Settings from lucide-react, className="h-8 w-8 text-primary"
- Table: shadcn/ui Table component
- Form: shadcn/ui Dialog, Form, Input, Select components
- Color display: Small circle with background color from task type
- Category badge: shadcn/ui Badge (green for billable, gray for non-billable)

Avoid: Don't add timer controls here (that's Task 2). This is purely task type management (CRUD).
  </action>
  <verify>
- Navigate to /task-types, page loads without errors
- Click "Create Task Type", modal opens with form
- Create task type "Recording" with rate 50€/h, color #FF5733, category billable
- Table shows new task type with correct color indicator
- Edit task type, change rate to 60€/h, saves successfully
- pnpm check passes (0 TypeScript errors)
  </verify>
  <done>
- TaskTypesPage exists at packages/client/src/pages/TaskTypes.tsx
- Route /task-types added to App.tsx
- Table displays task types with all columns (name, rate, category badge, color, actions)
- Create/Edit modals work (validation, submission, cache invalidation)
- UI follows design guidelines (pt-2 pb-4 px-2, text-primary icons)
- TypeScript compiles with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Live Timer Widget Component</name>
  <files>packages/client/src/components/time-tracking/ActiveTimer.tsx, packages/client/src/socket.ts</files>
  <action>
Create ActiveTimer widget component for starting/stopping timers with real-time updates:

**Component props:**
```tsx
interface ActiveTimerProps {
  sessionId?: number;
  projectId?: number; // Exactly one of sessionId OR projectId required
}
```

**Component structure:**
- Card with timer display: "00:23:45" (HH:MM:SS format, updates every second)
- Task type selector dropdown (only when no active timer)
- Start button (when no active timer)
- Stop button (when timer running)
- Live stats: Task type name, hourly rate, estimated cost (durationMinutes * hourlyRate / 60)
- Visual indicator: Green border when running, gray when stopped

**tRPC integration:**
```tsx
// Check for active timer on mount
const { data: activeTimer } = trpc.timeTracking.timer.getActive.useQuery({ sessionId, projectId });

// Start timer mutation
const startMutation = trpc.timeTracking.timer.start.useMutation({
  onSuccess: () => utils.timeTracking.timer.getActive.invalidate(),
});

// Stop timer mutation
const stopMutation = trpc.timeTracking.timer.stop.useMutation({
  onSuccess: () => {
    utils.timeTracking.timer.getActive.invalidate();
    utils.timeTracking.timeEntries.list.invalidate(); // Refresh history
  },
});
```

**Socket.IO real-time updates:**
Create packages/client/src/socket.ts if doesn't exist:
```tsx
import { io } from 'socket.io-client';

export const socket = io('http://localhost:3001', {
  withCredentials: true,
  autoConnect: true,
});
```

In ActiveTimer component:
```tsx
useEffect(() => {
  socket.on('timer:started', (data) => {
    // Invalidate active timer query to refresh UI
    utils.timeTracking.timer.getActive.invalidate();
  });

  socket.on('timer:stopped', (data) => {
    utils.timeTracking.timer.getActive.invalidate();
    utils.timeTracking.timeEntries.list.invalidate();
  });

  return () => {
    socket.off('timer:started');
    socket.off('timer:stopped');
  };
}, [utils]);
```

**Timer display logic:**
- If activeTimer exists: Calculate elapsed time from startTime to now
- Use setInterval(1000ms) to update display every second
- Format: Math.floor(minutes/60):minutes%60:seconds (padded)
- Estimated cost: (elapsedMinutes * activeTimer.taskType.hourlyRate / 60).toFixed(2)

**UI Guidelines:**
- Card with border-l-4 (green if running, gray if stopped)
- Timer display: text-4xl font-mono
- Task type: text-sm text-muted-foreground
- Estimated cost: text-lg font-semibold with € symbol
- Buttons: shadcn/ui Button (Start = green, Stop = red)

Avoid: Don't show history here (that's Task 3). This widget is only for active timer control.
  </action>
  <verify>
- Import ActiveTimer in SessionDetail or ProjectDetail page
- Render: `<ActiveTimer sessionId={sessionId} />`
- Select task type "Recording", click Start
- Timer starts counting: 00:00:01, 00:00:02, etc.
- Estimated cost updates in real-time
- Click Stop, timer stops and saves to database
- Open second browser tab, start timer in tab 1 → tab 2 updates automatically (Socket.IO)
- pnpm check passes
  </verify>
  <done>
- ActiveTimer.tsx exists at packages/client/src/components/time-tracking/
- socket.ts exists with Socket.IO client setup
- Timer displays HH:MM:SS format, updates every second
- Start/Stop buttons work, call tRPC mutations
- Socket.IO listeners update UI on timer:started/stopped events
- Estimated cost calculation correct (durationMinutes * hourlyRate / 60)
- Visual indicator: border-l-4 green (running) or gray (stopped)
- TypeScript compiles with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Time History Table with Manual Adjustments</name>
  <files>packages/client/src/components/time-tracking/TimeHistory.tsx</files>
  <action>
Create TimeHistory component displaying completed time entries with filtering and manual adjustment:

**Component props:**
```tsx
interface TimeHistoryProps {
  sessionId?: number;
  projectId?: number; // Exactly one required
}
```

**Table structure:**
- Columns: Task Type, Start Time, End Time, Duration (formatted), Cost (calculated), Notes, Actions (Adjust button)
- Filters: Date range picker (start/end dates), Task type multi-select
- Empty state: "No time entries yet"
- Sort: Most recent first (descending by startTime)

**tRPC integration:**
```tsx
const [filters, setFilters] = useState({
  dateRange: undefined,
  taskTypeIds: [],
});

const { data: timeEntries } = trpc.timeTracking.timeEntries.list.useQuery({
  sessionId,
  projectId,
  ...filters,
});
```

**Duration formatting:**
- Display: "2h 30m" format (Math.floor(minutes/60) + "h " + minutes%60 + "m")
- If < 1h: "45m"
- If < 1m: "0m"

**Cost calculation:**
- Formula: (durationMinutes * hourlyRateSnapshot / 60).toFixed(2)
- Display with € symbol: "125.00 €"

**Manual adjustment modal:**
- Triggered by "Adjust" button on time entry row
- Form fields: Start time (datetime-local input), End time (datetime-local input), Notes (textarea)
- Pre-fill with existing values
- Submit: call trpc.timeTracking.timeEntries.adjust.useMutation
- Show "(Manually Adjusted)" indicator on adjusted entries (manuallyAdjusted = true)

**Socket.IO real-time updates:**
```tsx
useEffect(() => {
  socket.on('timer:adjusted', (data) => {
    utils.timeTracking.timeEntries.list.invalidate();
  });

  return () => socket.off('timer:adjusted');
}, [utils]);
```

**UI Guidelines:**
- Container: Standard card with table
- Table: shadcn/ui Table component
- Filters: shadcn/ui DateRangePicker, MultiSelect
- Adjustment modal: shadcn/ui Dialog with Form
- Adjusted indicator: Badge with "Adjusted" text
- Empty state: EmptyState component with Clock icon

Avoid: Don't add invoice generation here (that's Phase 16-17). This is purely time entry display and adjustment.
  </action>
  <verify>
- Render TimeHistory below ActiveTimer in Session/Project detail page
- Start/stop timer multiple times to create entries
- Table displays entries with correct duration formatting (2h 30m)
- Cost calculation matches: durationMinutes * hourlyRate / 60
- Click "Adjust" on entry, modal opens with pre-filled times
- Change start time, submit → entry updates, shows "Adjusted" badge
- Apply date range filter → table filters correctly
- pnpm check passes
  </verify>
  <done>
- TimeHistory.tsx exists at packages/client/src/components/time-tracking/
- Table displays all time entries with columns (task type, start, end, duration, cost, notes, actions)
- Duration formatted as "Xh Ym" or "Ym"
- Cost calculated correctly with € symbol
- Adjust modal works (pre-fill, datetime inputs, submission, cache invalidation)
- Manually adjusted entries show "Adjusted" badge
- Filters work (date range, task type)
- Socket.IO listener updates table on timer:adjusted
- TypeScript compiles with 0 errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Timer UI components with real-time updates: Task Types management, ActiveTimer widget, TimeHistory table with manual adjustments</what-built>
  <how-to-verify>
    1. Run: pnpm dev (ensure both client and server running)
    2. Navigate to: /task-types
    3. Create task types:
       - "Setup" - 40€/h - billable - #3B82F6 (blue)
       - "Recording" - 60€/h - billable - #EF4444 (red)
       - "Break" - 0€/h - non-billable - #9CA3AF (gray)
    4. Navigate to any Session detail page (e.g., /sessions/1)
    5. Test timer workflow:
       - Select "Recording" task type
       - Click Start → timer begins counting (00:00:01, 00:00:02...)
       - Verify estimated cost updates (e.g., 1 min = 1€)
       - Wait 2-3 minutes
       - Click Stop → timer saves
    6. Verify time history:
       - Table shows new entry with duration "0h 3m" and cost "3.00 €"
       - Click Adjust on entry
       - Change start time to 5 minutes earlier
       - Submit → duration becomes "0h 8m", cost "8.00 €", shows "Adjusted" badge
    7. Test real-time (Socket.IO):
       - Open second browser tab with same session
       - Start timer in tab 1 → verify tab 2 updates automatically
       - Stop timer in tab 1 → verify tab 2 shows completed entry
    8. Test filters:
       - Create multiple entries with different task types
       - Apply date range filter → table filters correctly
       - Apply task type filter → shows only selected types
    9. Visual checks:
       - TaskTypes page: Header with Settings icon (text-primary)
       - ActiveTimer: Green border when running, gray when stopped
       - TimeHistory: Clean table layout, badges for categories
       - All pages: Container spacing pt-2 pb-4 px-2
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] pnpm check passes (0 TypeScript errors)
- [ ] pnpm build succeeds (production bundle)
- [ ] All 3 UI components exist and render without errors
- [ ] Timer start/stop workflow works end-to-end
- [ ] Time history displays with correct calculations
- [ ] Manual adjustment saves and updates UI
- [ ] Socket.IO real-time updates work across browser tabs
- [ ] UI follows design guidelines (spacing, icons, colors)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Timer workflow functional: task type selection → start → running display → stop → history entry
- Real-time updates work via Socket.IO (multi-user timer visibility)
- Manual adjustments save with "Adjusted" indicator
- UI consistent with design guidelines (Phase 3.14 patterns)
- No TypeScript errors or build failures
</success_criteria>

<output>
After completion, create `.planning/phases/13-tasks-chronometrees-ui/13-01-SUMMARY.md`:

# Phase 13 Plan 01: Tasks Chronométrées - UI & History Summary

**Timer UI components with real-time Socket.IO integration complete**

## Accomplishments

- Task Types management page (CRUD for task types with color coding)
- ActiveTimer widget with live countdown and estimated cost
- TimeHistory table with manual time adjustments
- Socket.IO integration for multi-user real-time updates

## Files Created/Modified

- `packages/client/src/pages/TaskTypes.tsx` - Task types management page
- `packages/client/src/components/time-tracking/ActiveTimer.tsx` - Live timer widget
- `packages/client/src/components/time-tracking/TimeHistory.tsx` - Time entries table
- `packages/client/src/socket.ts` - Socket.IO client setup
- `packages/client/src/App.tsx` - Added /task-types route

## Decisions Made

[Document any deviations from plan, technology choices, or architectural decisions]

## Issues Encountered

[Document any problems and resolutions, or "None"]

## Next Step

Phase 13 complete. Ready for Phase 14 (Architecture Session/Project Flexible - Backend).
</output>
