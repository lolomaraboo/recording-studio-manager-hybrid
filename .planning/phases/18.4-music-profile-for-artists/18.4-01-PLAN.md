---
phase: 18.4-music-profile-for-artists
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/src/tenant/schema.ts
  - drizzle/migrations/tenant/0011_add_music_profile_fields.sql
autonomous: true

must_haves:
  truths:
    - "Artist clients can have genres displayed on their profile"
    - "Artist clients can have instruments displayed on their profile"
    - "Artist clients can have streaming platform URLs stored"
    - "Clients list can filter by genre"
    - "Clients list can filter by instrument"
  artifacts:
    - path: "packages/database/src/tenant/schema.ts"
      provides: "Music profile fields in clients table schema"
      contains: "genres: jsonb"
      min_lines: 15
    - path: "drizzle/migrations/tenant/0011_add_music_profile_fields.sql"
      provides: "Migration to add music profile columns"
      contains: "ALTER TABLE clients ADD COLUMN genres"
  key_links:
    - from: "packages/database/src/tenant/schema.ts"
      to: "TypeScript type inference"
      via: "Drizzle ORM $inferSelect"
      pattern: "type Client = typeof clients\\.\$inferSelect"
    - from: "Migration 0011"
      to: "GIN indexes for JSONB search"
      via: "CREATE INDEX USING GIN"
      pattern: "CREATE INDEX.*genres.*USING GIN"
---

<objective>
Add comprehensive music profile fields to the clients table schema enabling recording studios to manage artist-specific information (genres, instruments, streaming platform URLs, industry contacts, career details).

Purpose: Address BUG-006 (P1 severity) - critical missing feature for core domain. Recording studio app without music metadata = car dealership CRM without tracking which cars customers buy.

Output: Extended clients table schema with 15 new nullable columns, migration file, GIN indexes for genre/instrument filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18.4-music-profile-for-artists/18.4-CONTEXT.md
@.planning/phases/18.4-music-profile-for-artists/18.4-RESEARCH.md
@packages/database/src/tenant/schema.ts
@.planning/DEVELOPMENT-WORKFLOW.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend clients table schema with music profile fields</name>
  <files>packages/database/src/tenant/schema.ts</files>
  <action>
Add 15 new nullable columns to clients table (after existing vCard fields, before createdAt):

**JSONB Arrays (with type inference):**
```typescript
// Music Profile - Multi-value fields
genres: jsonb("genres").$type<string[]>().default([]),
instruments: jsonb("instruments").$type<string[]>().default([]),
```

**Streaming Platforms (varchar URLs):**
```typescript
// Streaming Platforms
spotifyUrl: varchar("spotify_url", { length: 500 }),
appleMusicUrl: varchar("apple_music_url", { length: 500 }),
youtubeUrl: varchar("youtube_url", { length: 500 }),
soundcloudUrl: varchar("soundcloud_url", { length: 500 }),
bandcampUrl: varchar("bandcamp_url", { length: 500 }),
deezerUrl: varchar("deezer_url", { length: 500 }),
tidalUrl: varchar("tidal_url", { length: 500 }),
amazonMusicUrl: varchar("amazon_music_url", { length: 500 }),
audiomackUrl: varchar("audiomack_url", { length: 500 }),
beatportUrl: varchar("beatport_url", { length: 500 }),
otherPlatformsUrl: text("other_platforms_url"), // For custom/additional platforms
```

**Industry Contacts:**
```typescript
// Industry Information
recordLabel: varchar("record_label", { length: 255 }),
distributor: varchar("distributor", { length: 255 }),
managerContact: varchar("manager_contact", { length: 255 }),
publisher: varchar("publisher", { length: 255 }),
performanceRightsSociety: varchar("performance_rights_society", { length: 100 }), // SACEM, SOCAN, BMI, ASCAP, PRS
```

**Career Info:**
```typescript
// Career Information
yearsActive: varchar("years_active", { length: 100 }), // e.g., "2015-present" or "2010-2018"
notableWorks: text("notable_works"),
awardsRecognition: text("awards_recognition"),
biography: text("biography"),
```

All fields nullable (no .notNull() required).

Verify TypeScript type inference works: `type Client = typeof clients.$inferSelect;` should include all new fields.
  </action>
  <verify>
```bash
# Type check passes
cd packages/database && pnpm check

# Verify genres and instruments have type string[] (not any)
grep "genres.*string\[\]" src/tenant/schema.ts
grep "instruments.*string\[\]" src/tenant/schema.ts

# Count new fields added (should be 19 total)
grep -E "(spotify_url|genres|instruments|record_label|biography)" src/tenant/schema.ts | wc -l
```
  </verify>
  <done>
- clients table schema contains 19 new music profile fields
- genres and instruments use `.$type<string[]>()` for type safety
- All streaming platform URLs are varchar(500)
- All fields are nullable (backward compatible)
- TypeScript compilation succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate migration for music profile fields</name>
  <files>drizzle/migrations/tenant/0011_add_music_profile_fields.sql</files>
  <action>
Generate Drizzle migration for new music profile columns.

**CRITICAL DEVELOPMENT PATTERN:** Use "increment tenant number" strategy per DEVELOPMENT-WORKFLOW.md:
- Do NOT attempt to fix existing tenant migrations
- Migration will apply to NEW tenants (tenant_4, tenant_5, etc.) automatically
- Existing tenants (tenant_1, tenant_2, tenant_3) can be ignored/deleted
- This is DEVELOPMENT ONLY - production requires progressive migrations

Run migration generation:
```bash
cd packages/database
pnpm db:generate
```

Expected migration file name: `0011_add_music_profile_fields.sql` or similar (Drizzle auto-generates number).

Migration should contain:
1. 19 ALTER TABLE clients ADD COLUMN statements
2. 2 CREATE INDEX statements for GIN indexes on genres and instruments JSONB columns

Verify migration includes:
```sql
ALTER TABLE "clients" ADD COLUMN "genres" jsonb DEFAULT '[]';
ALTER TABLE "clients" ADD COLUMN "instruments" jsonb DEFAULT '[]';
-- ... (17 more ALTER TABLE statements for streaming URLs, industry contacts, career info)

CREATE INDEX IF NOT EXISTS "idx_clients_genres_gin" ON "clients" USING gin ("genres");
CREATE INDEX IF NOT EXISTS "idx_clients_instruments_gin" ON "clients" USING gin ("instruments");
```

If migration file is missing GIN indexes, add them manually to migration SQL file.
  </action>
  <verify>
```bash
# Migration file exists
ls drizzle/migrations/tenant/0011_*.sql

# Contains ALTER TABLE statements for all 19 columns
grep -c "ALTER TABLE.*ADD COLUMN" drizzle/migrations/tenant/0011_*.sql
# Expected output: 19

# Contains GIN indexes
grep "CREATE INDEX.*USING gin" drizzle/migrations/tenant/0011_*.sql
# Should show 2 indexes (genres, instruments)

# Verify JSONB default is empty array
grep "genres.*DEFAULT '\[\]'" drizzle/migrations/tenant/0011_*.sql
```
  </verify>
  <done>
- Migration file 0011_add_music_profile_fields.sql exists
- Contains 19 ALTER TABLE ADD COLUMN statements
- Contains 2 CREATE INDEX USING GIN statements for genres and instruments
- JSONB columns have DEFAULT '[]' (empty array)
- Migration ready to apply to new tenants
  </done>
</task>

<task type="auto">
  <name>Task 3: Test schema with new tenant creation</name>
  <files>None (creates new tenant database)</files>
  <action>
Test migration by creating a new tenant database with the updated schema.

**Follow "increment tenant number" pattern:**

1. Create tenant_4 (or next available tenant number):
```bash
# From project root
DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" pnpm dev
# In separate terminal, create new tenant via backend API or script
```

OR manually create tenant_4:
```bash
# Create database
createdb tenant_4

# Apply migrations
cd packages/database
DATABASE_URL="postgresql://postgres:password@localhost:5432/tenant_4" pnpm db:migrate
```

2. Verify schema applied correctly:
```bash
# Check table structure
psql -d tenant_4 -c "\d clients"

# Should show 19 new columns:
# - genres (jsonb)
# - instruments (jsonb)
# - spotify_url, apple_music_url, youtube_url, soundcloud_url, bandcamp_url, deezer_url, tidal_url, amazon_music_url, audiomack_url, beatport_url (varchar 500)
# - other_platforms_url (text)
# - record_label, distributor, manager_contact, publisher, performance_rights_society (varchar)
# - years_active, notable_works, awards_recognition, biography (text/varchar)

# Verify GIN indexes exist
psql -d tenant_4 -c "\d+ clients" | grep "idx_clients_genres_gin\|idx_clients_instruments_gin"
```

3. Test INSERT with new fields:
```sql
-- Insert artist with music profile
INSERT INTO clients (name, type, genres, instruments, spotify_url, record_label, biography)
VALUES (
  'Test Artist',
  'individual',
  '["Rock", "Alternative"]'::jsonb,
  '["Guitar", "Vocals"]'::jsonb,
  'https://open.spotify.com/artist/test123',
  'Universal Music',
  'Indie rock artist from Paris'
);

-- Verify JSONB containment query works
SELECT name, genres FROM clients WHERE genres @> '["Rock"]';
```

4. Update master database tenant mapping:
```sql
-- Connect to rsm_master
psql -d rsm_master

-- Insert tenant_4 mapping (adjust org_id as needed)
INSERT INTO tenant_databases (organization_id, database_name, created_at, updated_at)
VALUES (1, 'tenant_4', NOW(), NOW());
```

**Do NOT spend time debugging if migration fails - follow DEVELOPMENT-WORKFLOW.md and create tenant_5 instead.**
  </action>
  <verify>
```bash
# Verify tenant_4 exists
psql -l | grep tenant_4

# Verify clients table has music profile columns
psql -d tenant_4 -c "SELECT column_name FROM information_schema.columns WHERE table_name='clients' AND column_name IN ('genres', 'instruments', 'spotify_url', 'biography');"
# Should return 4 rows

# Verify GIN indexes exist
psql -d tenant_4 -c "SELECT indexname FROM pg_indexes WHERE tablename='clients' AND indexdef LIKE '%USING gin%';"
# Should return 2 rows (idx_clients_genres_gin, idx_clients_instruments_gin)

# Test JSONB query performance (should use index)
psql -d tenant_4 -c "EXPLAIN SELECT * FROM clients WHERE genres @> '[\"Rock\"]';"
# Should show "Bitmap Index Scan" or "Index Scan" (not Seq Scan)
```
  </verify>
  <done>
- tenant_4 database created successfully
- All 19 music profile columns present in clients table
- GIN indexes created on genres and instruments columns
- JSONB containment query works and uses indexes
- Test data inserted successfully
- Schema validated with zero PostgreSQL errors
  </done>
</task>

</tasks>

<verification>
**Overall Phase Checks:**
```bash
# All packages type-check
pnpm check

# Migration file exists
ls drizzle/migrations/tenant/0011_*.sql

# New tenant has music profile schema
psql -d tenant_4 -c "\d clients" | grep -E "genres|instruments|spotify_url|biography"

# Backend can query music fields (start dev server and test)
curl http://localhost:3001/health
```

**Database Verification:**
```sql
-- Check schema matches TypeScript
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'clients'
  AND column_name IN ('genres', 'instruments', 'spotify_url', 'record_label', 'biography')
ORDER BY ordinal_position;

-- Verify indexes for performance
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'clients'
  AND indexdef LIKE '%genres%';
```
</verification>

<success_criteria>
**Measurable Completion:**
- [x] packages/database/src/tenant/schema.ts contains 19 new music profile fields
- [x] drizzle/migrations/tenant/0011_*.sql exists with 19 ALTER TABLE + 2 CREATE INDEX statements
- [x] `pnpm check` passes with 0 TypeScript errors
- [x] tenant_4 (or next tenant) created with complete music profile schema
- [x] GIN indexes exist on genres and instruments columns
- [x] JSONB containment queries work and use indexes
- [x] Test data INSERT succeeds for artist with genres/instruments/streaming URLs
- [x] Zero P0/P1/P2 bugs introduced

**Goal-backward verification:**
Can answer YES to all:
1. If I query `clients WHERE genres @> '["Rock"]'`, does it use the GIN index? (YES = idx_clients_genres_gin visible in EXPLAIN)
2. Can I store multiple streaming platform URLs for one artist? (YES = all 11 URL columns nullable and working)
3. Will existing clients without music data still work? (YES = all new fields nullable, backward compatible)
4. Can I create a new tenant and immediately use music fields? (YES = migration applies automatically)
</success_criteria>

<output>
After completion, create `.planning/phases/18.4-music-profile-for-artists/18.4-01-SUMMARY.md` documenting:
- Schema changes (19 new columns added)
- Migration file created (0011_add_music_profile_fields.sql)
- New tenant number used (tenant_X)
- GIN index performance validation results
- Any deviations from plan or issues encountered
</output>
