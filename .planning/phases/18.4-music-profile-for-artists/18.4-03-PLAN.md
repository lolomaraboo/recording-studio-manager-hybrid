---
phase: 18.4-music-profile-for-artists
plan: 03
type: execute
wave: 3
depends_on: ["18.4-02"]
files_modified:
  - packages/client/src/pages/ClientDetail.tsx
  - packages/client/src/pages/Clients.tsx
  - packages/server/src/routers/clients.ts
  - packages/client/src/pages/Dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "ClientDetail page shows music profile in dedicated tab"
    - "Clients list can filter by genre"
    - "Clients list can filter by instrument"
    - "Dashboard shows genre distribution widget"
    - "Music profile updates save to database correctly"
  artifacts:
    - path: "packages/client/src/pages/ClientDetail.tsx"
      provides: "Music Profile tab integration"
      contains: "MusicProfileSection"
      min_lines: 5
    - path: "packages/client/src/pages/Clients.tsx"
      provides: "Genre and instrument filters"
      contains: "genre filter"
      min_lines: 20
    - path: "packages/server/src/routers/clients.ts"
      provides: "JSONB containment query filters"
      contains: "@> operator"
      min_lines: 10
    - path: "packages/client/src/pages/Dashboard.tsx"
      provides: "Genre distribution stats widget"
      contains: "genre distribution"
      min_lines: 30
  key_links:
    - from: "ClientDetail.tsx"
      to: "MusicProfileSection component"
      via: "Tab content"
      pattern: "<TabsContent.*music-profile.*MusicProfileSection"
    - from: "Clients.tsx filter"
      to: "tRPC clients.list query"
      via: "input parameters"
      pattern: "genre.*instrument.*input"
    - from: "clients.ts backend"
      to: "PostgreSQL @> operator"
      via: "sql template tag"
      pattern: "sql.*@>.*JSON\\.stringify"
    - from: "Dashboard widget"
      to: "Genre aggregation query"
      via: "tRPC stats endpoint"
      pattern: "genreDistribution.*clients\\.genres"
---

<objective>
Integrate MusicProfileSection into ClientDetail page, add genre/instrument filters to Clients list, implement backend JSONB containment queries, and create Dashboard genre distribution widget.

Purpose: Complete music profile feature by wiring UI components to database, enabling filtering and analytics.

Output: Fully functional music profile system - creation/editing in ClientDetail, filtering in Clients list, analytics in Dashboard.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18.4-music-profile-for-artists/18.4-CONTEXT.md
@.planning/phases/18.4-music-profile-for-artists/18.4-RESEARCH.md
@.planning/phases/18.4-music-profile-for-artists/18.4-01-SUMMARY.md
@.planning/phases/18.4-music-profile-for-artists/18.4-02-SUMMARY.md
@packages/client/src/pages/ClientDetail.tsx
@packages/client/src/pages/Clients.tsx
@packages/client/src/pages/Dashboard.tsx
@packages/server/src/routers/clients.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Music Profile tab to ClientDetail page</name>
  <files>packages/client/src/pages/ClientDetail.tsx</files>
  <action>
Integrate MusicProfileSection component into ClientDetail.tsx as a dedicated tab.

**Import MusicProfileSection:**
```typescript
import { MusicProfileSection } from "@/components/MusicProfileSection";
```

**Add tab to Tabs list (after "Informations Enrichies" tab):**

Find the TabsList section (around line 300-350) and add:
```typescript
<TabsTrigger value="music-profile" className="gap-2">
  <Music className="h-4 w-4" />
  Profil Musical
</TabsTrigger>
```

**Add TabsContent (after EnrichedClientInfo TabsContent):**
```typescript
<TabsContent value="music-profile">
  <MusicProfileSection
    client={client}
    isEditing={isEditing}
    onUpdate={handleUpdateClient}
  />
</TabsContent>
```

**Import Music icon from lucide-react:**
```typescript
import { /* ... existing imports */, Music } from "lucide-react";
```

Pattern follows existing tabs (Informations, Historique, Informations Enrichies). MusicProfileSection receives same props as EnrichedClientInfo (client, isEditing, onUpdate).

No changes needed to handleUpdateClient function - it already handles partial Client updates via tRPC mutation.
  </action>
  <verify>
```bash
# Music icon imported
grep "Music.*from.*lucide-react" packages/client/src/pages/ClientDetail.tsx

# TabsTrigger added for music-profile
grep "music-profile.*Profil Musical" packages/client/src/pages/ClientDetail.tsx

# MusicProfileSection component used
grep "MusicProfileSection" packages/client/src/pages/ClientDetail.tsx

# Type check passes
cd packages/client && pnpm check
```
  </verify>
  <done>
- ClientDetail.tsx imports MusicProfileSection component
- "Profil Musical" tab added to TabsList with Music icon
- TabsContent renders MusicProfileSection with client, isEditing, onUpdate props
- TypeScript compilation succeeds
- Music profile editable in ClientDetail page
  </done>
</task>

<task type="auto">
  <name>Task 2: Add genre/instrument filters to Clients list</name>
  <files>packages/client/src/pages/Clients.tsx</files>
  <action>
Add genre and instrument filter inputs to Clients.tsx list view, passing filter values to tRPC clients.list query.

**Add filter state (after existing search state):**
```typescript
const [genreFilter, setGenreFilter] = useState<string>("");
const [instrumentFilter, setInstrumentFilter] = useState<string>("");
```

**Update clients.list query to include filters:**
```typescript
const { data: clients, isLoading } = trpc.clients.list.useQuery({
  search: search,
  genre: genreFilter || undefined,
  instrument: instrumentFilter || undefined,
});
```

**Add filter inputs to UI (after existing search Input):**
```typescript
{/* Genre Filter */}
<div className="w-full sm:w-48">
  <Input
    placeholder="Filtrer par genre..."
    value={genreFilter}
    onChange={(e) => setGenreFilter(e.target.value)}
    className="w-full"
  />
</div>

{/* Instrument Filter */}
<div className="w-full sm:w-48">
  <Input
    placeholder="Filtrer par instrument..."
    value={instrumentFilter}
    onChange={(e) => setInstrumentFilter(e.target.value)}
    className="w-full"
  />
</div>
```

Place filter inputs in the toolbar section (next to search input, before view mode toggles).

**Add clear filters button (optional enhancement):**
```typescript
{(genreFilter || instrumentFilter) && (
  <Button
    variant="ghost"
    size="sm"
    onClick={() => {
      setGenreFilter("");
      setInstrumentFilter("");
    }}
    className="gap-2"
  >
    <X className="h-4 w-4" />
    Effacer filtres
  </Button>
)}
```

Filters work on all view modes (Table, Grid, Kanban) since they modify the tRPC query input.
  </action>
  <verify>
```bash
# Filter state variables added
grep "genreFilter.*instrumentFilter" packages/client/src/pages/Clients.tsx

# tRPC query includes filter parameters
grep "genre:.*instrument:" packages/client/src/pages/Clients.tsx

# Filter inputs added to UI
grep 'placeholder="Filtrer par genre' packages/client/src/pages/Clients.tsx
grep 'placeholder="Filtrer par instrument' packages/client/src/pages/Clients.tsx

# Type check passes
cd packages/client && pnpm check
```
  </verify>
  <done>
- genreFilter and instrumentFilter state added
- clients.list query sends genre and instrument parameters
- 2 filter input fields added to toolbar
- Clear filters button added (conditional render)
- TypeScript compilation succeeds
- Filters ready for backend implementation
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement backend JSONB containment filters</name>
  <files>packages/server/src/routers/clients.ts</files>
  <action>
Add genre and instrument filter support to clients.list procedure using PostgreSQL JSONB `@>` containment operator.

**Update tRPC input schema:**
```typescript
list: protectedProcedure
  .input(z.object({
    search: z.string().optional(),
    genre: z.string().optional(), // NEW: Filter by genre
    instrument: z.string().optional(), // NEW: Filter by instrument
    limit: z.number().optional(),
  }))
  .query(async ({ ctx, input }) => {
    const tenantDb = await ctx.getTenantDb();

    // Start building query
    let query = tenantDb
      .select({
        // ... existing select fields
      })
      .from(clients);

    // Existing search filter (name/email)
    if (input.search) {
      query = query.where(
        sql`${clients.name} ILIKE ${`%${input.search}%`} OR ${clients.email} ILIKE ${`%${input.search}%`}`
      );
    }

    // NEW: Genre filter using JSONB containment (@>)
    if (input.genre) {
      query = query.where(
        sql`${clients.genres} @> ${JSON.stringify([input.genre])}`
      );
    }

    // NEW: Instrument filter using JSONB containment (@>)
    if (input.instrument) {
      query = query.where(
        sql`${clients.instruments} @> ${JSON.stringify([input.instrument])}`
      );
    }

    // Existing limit
    if (input.limit) {
      query = query.limit(input.limit);
    }

    return query;
  });
```

**JSONB containment explained:**
- `genres @> '["Rock"]'` means "genres array contains 'Rock'"
- Must use `JSON.stringify([value])` to create proper JSONB array format
- GIN indexes (created in 18.4-01) make these queries fast

**Import sql from drizzle-orm if not already imported:**
```typescript
import { sql } from 'drizzle-orm';
```

Filters work independently: can filter by genre only, instrument only, or both together.
  </action>
  <verify>
```bash
# Input schema includes genre and instrument
grep "genre:.*instrument:" packages/server/src/routers/clients.ts

# JSONB containment operator used
grep "@>" packages/server/src/routers/clients.ts

# JSON.stringify used for array format
grep "JSON.stringify.*input.genre\|input.instrument" packages/server/src/routers/clients.ts

# sql import from drizzle-orm
grep "import.*sql.*from.*drizzle-orm" packages/server/src/routers/clients.ts

# Type check passes
cd packages/server && pnpm check
```
  </verify>
  <done>
- clients.list input schema accepts genre and instrument parameters
- Backend filters using PostgreSQL `@>` JSONB containment operator
- Filters use GIN indexes for performance
- Multiple filters can be combined (search + genre + instrument)
- TypeScript compilation succeeds
- Filters functional end-to-end
  </done>
</task>

<task type="auto">
  <name>Task 4: Add genre distribution widget to Dashboard</name>
  <files>packages/client/src/pages/Dashboard.tsx</files>
  <action>
Create genre distribution stats widget on Dashboard showing top 5 genres with client counts.

**Add stats query to Dashboard component:**

If Dashboard doesn't already have a dedicated stats endpoint, add to clients router first:

**packages/server/src/routers/clients.ts** - Add stats procedure:
```typescript
stats: protectedProcedure
  .query(async ({ ctx }) => {
    const tenantDb = await ctx.getTenantDb();

    // Get all clients with genres
    const clientsWithGenres = await tenantDb
      .select({
        genres: clients.genres,
      })
      .from(clients)
      .where(sql`${clients.genres} IS NOT NULL AND jsonb_array_length(${clients.genres}) > 0`);

    // Aggregate genre counts
    const genreCounts: Record<string, number> = {};
    clientsWithGenres.forEach(client => {
      (client.genres as string[] || []).forEach(genre => {
        genreCounts[genre] = (genreCounts[genre] || 0) + 1;
      });
    });

    // Sort by count descending, take top 5
    const topGenres = Object.entries(genreCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([genre, count]) => ({ genre, count }));

    return {
      genreDistribution: topGenres,
      totalClients: clientsWithGenres.length,
    };
  });
```

**packages/client/src/pages/Dashboard.tsx** - Add widget:
```typescript
import { Music } from "lucide-react";

// Add query
const { data: clientStats } = trpc.clients.stats.useQuery();

// Add widget card (in dashboard grid, after existing widgets)
<Card>
  <CardHeader className="pb-3">
    <CardTitle className="flex items-center gap-2 text-base">
      <Music className="h-8 w-8 text-primary" />
      Genres musicaux populaires
    </CardTitle>
    <CardDescription>Top 5 genres d'artistes</CardDescription>
  </CardHeader>
  <CardContent>
    {clientStats?.genreDistribution && clientStats.genreDistribution.length > 0 ? (
      <div className="space-y-2">
        {clientStats.genreDistribution.map(({ genre, count }, idx) => (
          <div key={genre} className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Badge variant="secondary" className="w-6 h-6 rounded-full flex items-center justify-center text-xs">
                {idx + 1}
              </Badge>
              <span className="text-sm font-medium">{genre}</span>
            </div>
            <Badge variant="outline">{count} client{count > 1 ? 's' : ''}</Badge>
          </div>
        ))}
      </div>
    ) : (
      <p className="text-sm text-muted-foreground py-6 text-center">
        Aucune donnée de genre disponible
      </p>
    )}
  </CardContent>
</Card>
```

Widget shows top 5 genres ranked by number of clients, with empty state when no genre data exists.

**Alternative simpler approach if clients.stats endpoint already exists:**
Extend existing stats endpoint with genreDistribution field instead of creating new procedure.
  </action>
  <verify>
```bash
# clients.stats procedure exists (backend)
grep "stats:.*protectedProcedure" packages/server/src/routers/clients.ts

# genreDistribution aggregation logic
grep "genreDistribution" packages/server/src/routers/clients.ts

# Dashboard uses clients.stats query
grep "trpc.clients.stats.useQuery" packages/client/src/pages/Dashboard.tsx

# Genre widget rendering
grep "Genres musicaux populaires" packages/client/src/pages/Dashboard.tsx

# Type check passes
pnpm check
```
  </verify>
  <done>
- clients.stats procedure created/extended with genreDistribution
- Backend aggregates genre counts from all clients
- Dashboard widget displays top 5 genres with counts
- Widget shows empty state when no genre data
- TypeScript compilation succeeds
- Genre analytics visible on Dashboard
  </done>
</task>

</tasks>

<verification>
**End-to-End Testing:**

```bash
# Start development servers
DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" pnpm dev

# Frontend: http://localhost:5174
# Backend: http://localhost:3001
```

**Test Workflow:**
1. Navigate to /clients/1 (any existing client)
2. Click "Profil Musical" tab → MusicProfileSection renders
3. Click "Modifier" → Enter edit mode
4. Add genres: ["Rock", "Alternative Rock"]
5. Add instruments: ["Guitar", "Vocals"]
6. Add Spotify URL: https://open.spotify.com/artist/test
7. Click "Enregistrer" → Data saves successfully
8. Navigate to /clients list
9. Enter "Rock" in genre filter → Client appears
10. Enter "Guitar" in instrument filter → Client appears
11. Clear filters → All clients visible
12. Navigate to /dashboard → Genre distribution widget shows "Rock" with count

**Database Verification:**
```sql
-- Connect to tenant database
psql -d tenant_4

-- Verify genres saved as JSONB array
SELECT id, name, genres, instruments FROM clients WHERE id = 1;

-- Test JSONB containment query
SELECT name FROM clients WHERE genres @> '["Rock"]';

-- Verify GIN index used (should show Bitmap Index Scan)
EXPLAIN SELECT name FROM clients WHERE genres @> '["Rock"]';
```

**Performance Check:**
- Genre/instrument filters respond instantly (< 100ms)
- Dashboard genre widget loads quickly (< 200ms)
- EXPLAIN shows GIN index usage (not Seq Scan)
</verification>

<success_criteria>
**Measurable Completion:**
- [x] ClientDetail has "Profil Musical" tab with MusicProfileSection
- [x] Clients list has genre and instrument filter inputs
- [x] Backend clients.list supports genre/instrument JSONB filters
- [x] Dashboard has genre distribution widget (top 5 genres)
- [x] `pnpm check` passes with 0 errors
- [x] Music profile edits save to database correctly
- [x] Filters work end-to-end (UI → tRPC → PostgreSQL → results)
- [x] Genre widget shows accurate aggregated data
- [x] Zero P0/P1/P2 bugs introduced

**Goal-backward verification:**
Can answer YES to all:
1. Can I edit an artist's genres and instruments in ClientDetail? (YES = MusicProfileSection in tab, save works)
2. Can I filter clients list by genre "Rock"? (YES = genre input → tRPC → @> query)
3. Does filtering use the GIN index? (YES = EXPLAIN shows Bitmap Index Scan)
4. Can I see which genres are most common on Dashboard? (YES = genre distribution widget)
5. Do filters work in all view modes (Table/Grid/Kanban)? (YES = tRPC query affects all views)
</success_criteria>

<output>
After completion, create `.planning/phases/18.4-music-profile-for-artists/18.4-03-SUMMARY.md` documenting:
- Integration points (ClientDetail tab, Clients filters, Dashboard widget)
- Backend JSONB query implementation (@> operator, GIN index usage)
- Filter UI placement and behavior
- Genre distribution widget design
- Performance validation results (query times, index usage)
- Any deviations from plan or integration issues encountered
</output>
