---
phase: 18.4-music-profile-for-artists
plan: 03
type: execute
wave: 2
depends_on: ["18.4-01"]
files_modified:
  - packages/client/src/pages/Clients.tsx
  - packages/server/src/routers/clients.ts
  - packages/client/src/pages/Dashboard.tsx
autonomous: true

must_haves:
  truths:
    - "Users can filter clients by genre from dropdown"
    - "Users can filter clients by instrument from dropdown"
    - "Search includes music profile fields (genre, instrument, label)"
    - "Dashboard shows genre distribution stats"
    - "Filtering works correctly with PostgreSQL JSONB @> operator"
  artifacts:
    - path: "packages/client/src/pages/Clients.tsx"
      provides: "Genre and instrument filter dropdowns"
      contains: "genre filter"
      min_lines: 500
    - path: "packages/server/src/routers/clients.ts"
      provides: "Extended list query with genre/instrument filters"
      contains: "@>"
    - path: "packages/client/src/pages/Dashboard.tsx"
      provides: "Genre distribution widget"
      contains: "genre distribution"
  key_links:
    - from: "packages/client/src/pages/Clients.tsx"
      to: "packages/server/src/routers/clients.ts"
      via: "trpc.clients.list query with genre/instrument params"
      pattern: "trpc.clients.list.useQuery"
    - from: "packages/server/src/routers/clients.ts"
      to: "PostgreSQL JSONB operators"
      via: "sql`${clients.genres} @> ${JSON.stringify([input.genre])}`"
      pattern: "@>"
---

<objective>
Add genre/instrument filters to Clients list page and genre distribution stats to Dashboard.

Purpose: Enable users to find artists by music profile (filter by genre, instrument), improve discoverability, and provide analytics on artist distribution by genre.

Output: Filter dropdowns on Clients page, extended tRPC query with JSONB filtering, Dashboard widget showing genre distribution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18.4-music-profile-for-artists/18.4-RESEARCH.md
@.planning/phases/18.4-music-profile-for-artists/18.4-01-SUMMARY.md
@.planning/phases/18.4-music-profile-for-artists/18.4-02-SUMMARY.md

# Current Clients list page
@packages/client/src/pages/Clients.tsx

# Current tRPC clients router
@packages/server/src/routers/clients.ts

# Dashboard layout
@packages/client/src/pages/Dashboard.tsx

# PostgreSQL JSONB containment patterns
# Research: @> operator with GIN indexes (RESEARCH.md lines 490-512)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add genre/instrument filters to Clients page and backend</name>
  <files>
    packages/client/src/pages/Clients.tsx
    packages/server/src/routers/clients.ts
  </files>
  <action>
**FRONTEND: Add filter UI to Clients.tsx**

**Step 1: Add state for filters** (around line 30 with other useState)
```typescript
const [genreFilter, setGenreFilter] = useState<string>("");
const [instrumentFilter, setInstrumentFilter] = useState<string>("");
```

**Step 2: Update tRPC query** (modify existing trpc.clients.list.useQuery call)
```typescript
const { data: clients, isLoading } = trpc.clients.list.useQuery({
  search: searchQuery,
  genre: genreFilter || undefined, // NEW
  instrument: instrumentFilter || undefined, // NEW
  // ... other existing params
});
```

**Step 3: Add filter dropdowns** (in existing filter section near search input)
```typescript
{/* Genre Filter */}
<div className="flex items-center gap-2">
  <Label htmlFor="genre-filter">Genre:</Label>
  <Select value={genreFilter} onValueChange={setGenreFilter}>
    <SelectTrigger id="genre-filter" className="w-[180px]">
      <SelectValue placeholder="Tous les genres" />
    </SelectTrigger>
    <SelectContent>
      <SelectItem value="">Tous les genres</SelectItem>
      <SelectItem value="Rock">Rock</SelectItem>
      <SelectItem value="Pop">Pop</SelectItem>
      <SelectItem value="Jazz">Jazz</SelectItem>
      <SelectItem value="Electronic">Electronic</SelectItem>
      <SelectItem value="Hip-Hop">Hip-Hop</SelectItem>
      <SelectItem value="R&B">R&B</SelectItem>
      <SelectItem value="Classical">Classical</SelectItem>
      <SelectItem value="Metal">Metal</SelectItem>
      {/* Add 10+ more common genres */}
    </SelectContent>
  </Select>
</div>

{/* Instrument Filter */}
<div className="flex items-center gap-2">
  <Label htmlFor="instrument-filter">Instrument:</Label>
  <Select value={instrumentFilter} onValueChange={setInstrumentFilter}>
    <SelectTrigger id="instrument-filter" className="w-[180px]">
      <SelectValue placeholder="Tous les instruments" />
    </SelectTrigger>
    <SelectContent>
      <SelectItem value="">Tous les instruments</SelectItem>
      <SelectItem value="Guitar">Guitare</SelectItem>
      <SelectItem value="Bass">Basse</SelectItem>
      <SelectItem value="Drums">Batterie</SelectItem>
      <SelectItem value="Piano">Piano</SelectItem>
      <SelectItem value="Vocals">Voix</SelectItem>
      <SelectItem value="Saxophone">Saxophone</SelectItem>
      {/* Add 10+ more common instruments */}
    </SelectContent>
  </Select>
</div>
```

**WHY Select component:** Consistent with existing filter UI, better UX than free-text search for known categories.

**IMPORTANT:** Import Select components if not already imported:
```typescript
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
```

---

**BACKEND: Extend tRPC router with JSONB filtering**

**Step 1: Update input schema** (packages/server/src/routers/clients.ts)
```typescript
list: protectedProcedure
  .input(z.object({
    search: z.string().optional(),
    genre: z.string().optional(), // NEW
    instrument: z.string().optional(), // NEW
    limit: z.number().default(100),
    offset: z.number().default(0),
  }))
```

**Step 2: Add JSONB filtering logic** (in query handler)
```typescript
import { sql } from 'drizzle-orm';

.query(async ({ ctx, input }) => {
  const tenantDb = await ctx.getTenantDb();

  let query = tenantDb.select().from(clients);

  // Genre filter using JSONB @> containment operator
  if (input.genre) {
    query = query.where(
      sql`${clients.genres} @> ${JSON.stringify([input.genre])}`
    );
  }

  // Instrument filter (check if instruments array contains object with name)
  if (input.instrument) {
    query = query.where(
      sql`${clients.instruments}::jsonb @> ${JSON.stringify([{ name: input.instrument }])}`
    );
  }

  // Existing search logic...
  if (input.search) {
    // EXTEND search to include music profile fields
    query = query.where(
      sql`
        LOWER(${clients.name}) LIKE ${'%' + input.search.toLowerCase() + '%'}
        OR LOWER(${clients.email}) LIKE ${'%' + input.search.toLowerCase() + '%'}
        OR LOWER(${clients.artistName}) LIKE ${'%' + input.search.toLowerCase() + '%'}
        OR LOWER(${clients.recordLabel}) LIKE ${'%' + input.search.toLowerCase() + '%'}
        OR ${clients.genres}::text ILIKE ${'%' + input.search + '%'}
        OR ${clients.instruments}::text ILIKE ${'%' + input.search + '%'}
      `
    );
  }

  return query.limit(input.limit).offset(input.offset);
});
```

**WHY @> operator:** PostgreSQL JSON containment operator with GIN index support. Fast filtering on JSONB arrays without table scans.

**WHY ::jsonb cast for instruments:** Ensures type consistency for object array containment checks.

**IMPORTANT:** GIN indexes (created in Phase 18.4-01) make these queries fast. Without indexes, would cause table scans.
  </action>
  <verify>
**Frontend verification:**
1. Check Select imports: `grep "import.*Select" packages/client/src/pages/Clients.tsx`
2. Check state added: `grep "genreFilter" packages/client/src/pages/Clients.tsx`
3. TypeScript check: `pnpm --filter client check`
4. Visual test: Open http://localhost:5174/clients
5. Filter test: Select "Rock" from genre dropdown, verify only Rock artists shown
6. Instrument test: Select "Guitar" from instrument dropdown, verify only guitarists shown
7. Combine filters: Select Rock + Guitar, verify intersection works
8. Search test: Search "SACEM", verify clients with SACEM in performanceRightsSociety appear

**Backend verification:**
1. Check input schema: `grep "genre: z.string" packages/server/src/routers/clients.ts`
2. Check JSONB query: `grep "@>" packages/server/src/routers/clients.ts`
3. TypeScript check: `pnpm --filter server check`
4. Network test: Open DevTools Network tab, filter by genre, verify API request includes `genre` param
5. Response test: Verify API returns filtered results (not all clients)
6. Performance test: Check query time in database logs (<100ms with GIN indexes)
  </verify>
  <done>Genre and instrument filters working on Clients page, backend JSONB filtering operational, search extended to music profile fields</done>
</task>

<task type="auto">
  <name>Task 2: Add genre distribution widget to Dashboard</name>
  <files>packages/client/src/pages/Dashboard.tsx</files>
  <action>
Add new "Genre Distribution" widget to Dashboard showing breakdown of artists by music genre.

**Step 1: Fetch clients data with genres**
```typescript
// Add to existing queries in Dashboard.tsx
const { data: clients } = trpc.clients.list.useQuery({ limit: 1000 });
```

**Step 2: Calculate genre distribution**
```typescript
// Around line 50-100 with other useMemo calculations
const genreDistribution = useMemo(() => {
  if (!clients) return [];

  // Count clients per genre
  const genreCounts: Record<string, number> = {};

  clients.forEach(client => {
    (client.genres || []).forEach(genre => {
      genreCounts[genre] = (genreCounts[genre] || 0) + 1;
    });
  });

  // Convert to array and sort by count descending
  return Object.entries(genreCounts)
    .map(([genre, count]) => ({ genre, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 8); // Top 8 genres
}, [clients]);
```

**Step 3: Add widget Card** (in Dashboard grid layout)
```typescript
{/* Genre Distribution Widget */}
<Card className="pb-3">
  <CardHeader>
    <CardTitle className="flex items-center gap-2 text-base">
      <Music className="h-8 w-8 text-primary" />
      Distribution par genre
    </CardTitle>
    <CardDescription>Top genres musicaux des artistes</CardDescription>
  </CardHeader>
  <CardContent>
    {genreDistribution.length === 0 ? (
      <p className="text-sm text-muted-foreground py-6 text-center">
        Aucun genre enregistré
      </p>
    ) : (
      <div className="space-y-3">
        {genreDistribution.map(({ genre, count }) => (
          <div key={genre} className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <div className="h-2 w-2 rounded-full bg-primary" />
              <span className="text-sm font-medium">{genre}</span>
            </div>
            <Badge variant="secondary">{count}</Badge>
          </div>
        ))}
      </div>
    )}
  </CardContent>
</Card>
```

**UI Design Guidelines Applied:**
- Card: `pb-3` header spacing
- Icon: `Music` icon, `h-8 w-8 text-primary`
- Title: `text-base` size
- Empty state: `py-6 text-center`
- Badge: `variant="secondary"` for counts

**WHY top 8 genres:** Keeps widget compact, focuses on most common genres. Full list available via filters on Clients page.

**Alternative (future enhancement):** Add pie chart visualization using recharts library. Current version uses simple list for MVP.

**IMPORTANT:** Import Music icon if not already imported:
```typescript
import { Music } from "lucide-react";
```
  </action>
  <verify>
1. Check genreDistribution calculation: `grep "genreDistribution" packages/client/src/pages/Dashboard.tsx`
2. Check Music icon import: `grep "import.*Music" packages/client/src/pages/Dashboard.tsx`
3. TypeScript check: `pnpm --filter client check`
4. Visual test: Open http://localhost:5174/ (Dashboard)
5. Widget visible: Verify "Distribution par genre" card appears
6. Data display: Add genres to clients, verify widget updates with counts
7. Empty state: Test with no genres, verify "Aucun genre enregistré" message
8. Sorting: Verify genres sorted by count descending (most common first)
  </verify>
  <done>Genre distribution widget added to Dashboard, displays top 8 genres with counts, updates when clients have genres</done>
</task>

</tasks>

<verification>
**Overall Phase 18.4-03 Checks:**

1. **Filter Functionality:**
   - Genre dropdown on Clients page
   - Instrument dropdown on Clients page
   - Filters work independently and combined
   - PostgreSQL JSONB @> operator used correctly
   - GIN indexes improve query performance

2. **Search Enhancement:**
   - Search includes recordLabel field
   - Search includes genres JSONB array
   - Search includes instruments JSONB array
   - Search works with ILIKE for case-insensitive matching

3. **Dashboard Widget:**
   - Genre distribution widget visible
   - Top 8 genres displayed with counts
   - Sorting by count descending
   - Empty state when no genres
   - Updates dynamically when client genres change

4. **Performance:**
   - Queries complete <100ms (with GIN indexes)
   - No table scans (verify with EXPLAIN ANALYZE if needed)

**Success Criteria:**
✅ Genre filter dropdown functional
✅ Instrument filter dropdown functional
✅ Backend JSONB filtering working
✅ Search extended to music fields
✅ Dashboard genre distribution widget added
✅ Zero TypeScript errors
✅ Performance acceptable (<100ms queries)
</verification>

<success_criteria>
**Measurable Completion:**

1. Filters added: Genre and instrument dropdowns on Clients page
2. Backend extended: tRPC clients.list supports genre/instrument params
3. JSONB queries: PostgreSQL @> operator used correctly
4. Dashboard widget: Genre distribution card visible and functional
5. Search enhancement: Music profile fields searchable
6. Zero errors: `pnpm check` passes
7. Performance: Filtering completes <100ms

**Phase 18.4-03 is complete when:**
- Users can filter clients by genre and instrument
- Search includes music profile fields
- Dashboard shows genre distribution stats
- All functionality works correctly in browser
- No regressions in existing features
</success_criteria>

<output>
After completion, create `.planning/phases/18.4-music-profile-for-artists/18.4-03-SUMMARY.md` documenting:
- Filter implementation (frontend + backend)
- JSONB query patterns used
- Dashboard widget details
- Performance metrics (query times)
- Visual validation notes
- Time taken
- BUG-006 resolution confirmation
</output>
