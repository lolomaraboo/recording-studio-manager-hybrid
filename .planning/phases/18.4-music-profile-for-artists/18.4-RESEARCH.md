# Phase 18.4: Music Profile for Artists - Research

**Researched:** 2026-01-17
**Domain:** Music industry metadata management, PostgreSQL JSONB arrays, multi-select UI patterns
**Confidence:** HIGH

## Summary

Research into adding comprehensive music profile fields to client records for recording studio management. This phase addresses BUG-006 (P1 severity) discovered during Phase 18 manual testing - the critical absence of music-related information for artist clients in a recording studio application.

The standard approach is to extend the existing `clients` table schema with a mix of **JSONB array columns** (for multi-select fields like genres/instruments) and **varchar columns** (for single-value fields like URLs and industry info). This approach balances flexibility with queryability while maintaining backward compatibility.

**Key technical decisions researched:**
- JSONB arrays with GIN indexes for genre/instrument filtering
- shadcn/ui multi-select components with custom entry capability
- URL validation patterns for streaming platforms
- Migration strategy using "increment tenant number" pattern in development

**Primary recommendation:** Use JSONB arrays for multi-value fields (genres, instruments), add GIN indexes for search performance, create separate `MusicProfileSection` component for UI modularity, and leverage existing `EnrichedClientInfo` pattern.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| PostgreSQL JSONB | 16+ | Store multi-value arrays | Native JSON support with containment operators, GIN indexing |
| Drizzle ORM | 0.44+ | Type-safe schema definition | Already in project stack, supports `.$type<T[]>()` for arrays |
| GIN indexes | Native | JSONB array search performance | PostgreSQL recommended for JSON containment queries |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| shadcn-multi-select-component | Latest | Multi-select with custom entries | Genre/instrument selection UI |
| shadcn-ui-expansions Multiple Selector | Latest | Async multi-select with "creatable" | When async search + custom entries needed |
| zod | Latest | URL format validation | Streaming platform URL validation in tRPC |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| JSONB arrays | Junction tables (genres, instruments as separate tables) | Junction tables: more normalized, but adds complexity and migration burden for 15+ new tables |
| Custom multi-select | HTML5 `<select multiple>` | HTML5 select: works but poor UX, no custom entries, limited styling |
| Manual URL validation | External API validation (Spotify API) | API validation: more accurate but adds latency, API dependencies, rate limits |

**Installation:**
```bash
# shadcn-multi-select-component (recommended)
npx shadcn@latest add https://github.com/sersavan/shadcn-multi-select-component

# OR shadcn-ui-expansions (if async + creatable needed)
npx shadcn@latest add https://shadcnui-expansions.typeart.cc/docs/multiple-selector
```

**Note:** No new npm packages required for database layer - PostgreSQL JSONB and Drizzle ORM already in stack.

## Architecture Patterns

### Recommended Project Structure
```
packages/
├── database/
│   └── src/
│       └── tenant/
│           └── schema.ts           # Extend clients table with music fields
├── server/
│   └── src/
│       ├── routers/
│       │   └── clients.ts          # Add genre/instrument filters to list query
│       └── utils/
│           ├── vcard-service.ts    # Already exists - extend for music fields
│           └── music-validators.ts # NEW: URL/ISRC validation functions
└── client/
    └── src/
        ├── components/
        │   ├── EnrichedClientInfo.tsx  # Already exists - pattern to follow
        │   └── MusicProfileSection.tsx # NEW: Separate music profile component
        └── pages/
            └── ClientDetail.tsx        # Import MusicProfileSection
```

### Pattern 1: JSONB Array Schema with Type Inference
**What:** Use Drizzle ORM's `.$type<T[]>()` for type-safe JSONB arrays
**When to use:** For all multi-value fields (genres, instruments, etc.)
**Example:**
```typescript
// Source: Drizzle ORM documentation + project schema.ts pattern
// packages/database/src/tenant/schema.ts

export const clients = pgTable("clients", {
  // ... existing fields ...

  // Music Profile - JSONB Arrays
  genres: jsonb("genres").$type<string[]>().default([]),
  subGenres: jsonb("sub_genres").$type<string[]>().default([]),
  instruments: jsonb("instruments").$type<Array<{
    name: string;
    proficiency: 'beginner' | 'intermediate' | 'pro';
  }>>().default([]),

  // Music Profile - Single Values
  vocalRange: varchar("vocal_range", { length: 50 }), // soprano, alto, tenor, etc.
  skillLevel: varchar("skill_level", { length: 50 }), // beginner, intermediate, pro, expert

  // Streaming Platforms (varchar for URLs)
  spotifyUrl: varchar("spotify_url", { length: 500 }),
  appleMusicUrl: varchar("apple_music_url", { length: 500 }),
  soundcloudUrl: varchar("soundcloud_url", { length: 500 }),
  youtubeUrl: varchar("youtube_url", { length: 500 }),
  bandcampUrl: varchar("bandcamp_url", { length: 500 }),
  deezerUrl: varchar("deezer_url", { length: 500 }),

  // Industry Information
  recordLabel: varchar("record_label", { length: 255 }),
  distributor: varchar("distributor", { length: 255 }),
  managerName: varchar("manager_name", { length: 255 }),
  managerContact: varchar("manager_contact", { length: 255 }),
  publisher: varchar("publisher", { length: 255 }),
  performanceRightsSociety: varchar("performance_rights_society", { length: 100 }), // SACEM, SOCAN, BMI, ASCAP
  performanceRightsMemberId: varchar("performance_rights_member_id", { length: 100 }),
  isrcPrefix: varchar("isrc_prefix", { length: 20 }), // CC-XXX format
});
```

### Pattern 2: GIN Index for JSONB Containment Queries
**What:** Create GIN indexes on JSONB columns for fast array filtering
**When to use:** For all JSONB array columns used in WHERE clauses
**Example:**
```sql
-- Source: PostgreSQL documentation - JSONB indexing best practices
-- packages/database/migrations/XXXX_add_music_profile_fields.sql

-- Add GIN indexes for genre/instrument filtering
CREATE INDEX idx_clients_genres_gin ON clients
USING GIN (genres jsonb_ops);

CREATE INDEX idx_clients_instruments_gin ON clients
USING GIN (instruments jsonb_ops);
```

**Performance:** GIN indexes enable fast containment queries using `@>` operator (e.g., "find all clients with genre 'Rock'").

### Pattern 3: JSONB Array Containment Filtering (Drizzle + PostgreSQL)
**What:** Use PostgreSQL `@>` containment operator for "array contains value" queries
**When to use:** Filter clients by genre, instrument, or other JSONB array fields
**Example:**
```typescript
// Source: PostgreSQL JSONB operators + Drizzle sql operator
// packages/server/src/routers/clients.ts

import { sql } from 'drizzle-orm';

// Filter clients by genre
list: protectedProcedure
  .input(z.object({
    search: z.string().optional(),
    genre: z.string().optional(), // NEW
    instrument: z.string().optional(), // NEW
    // ... other filters
  }))
  .query(async ({ ctx, input }) => {
    const tenantDb = await ctx.getTenantDb();
    let query = tenantDb.select().from(clients);

    // Genre filter: WHERE genres @> '["Rock"]'
    if (input.genre) {
      query = query.where(
        sql`${clients.genres} @> ${JSON.stringify([input.genre])}`
      );
    }

    // Instrument filter: WHERE instruments @> '[{"name": "Guitar"}]'
    if (input.instrument) {
      query = query.where(
        sql`${clients.instruments}::jsonb @> ${JSON.stringify([{ name: input.instrument }])}`
      );
    }

    return query;
  });
```

**Note:** `@>` operator checks if left JSONB contains right JSONB. For simple string arrays, use `'["value"]'`. For object arrays, match object structure.

### Pattern 4: Multi-Select Component with Custom Entries
**What:** shadcn-based multi-select allowing users to pick from presets OR add custom entries
**When to use:** Genre and instrument selection (predefined lists but allow custom)
**Example:**
```typescript
// Source: shadcn-ui-expansions Multiple Selector (creatable feature)
// packages/client/src/components/MusicProfileSection.tsx

import { MultipleSelector, Option } from '@/components/ui/multiple-selector';

const PRESET_GENRES: Option[] = [
  { label: "Rock", value: "Rock" },
  { label: "Pop", value: "Pop" },
  { label: "Jazz", value: "Jazz" },
  { label: "Electronic", value: "Electronic" },
  { label: "Hip-Hop", value: "Hip-Hop" },
  { label: "Classical", value: "Classical" },
  // ... more presets
];

function GenreSelector({ value, onChange, disabled }: Props) {
  return (
    <MultipleSelector
      value={value.map(v => ({ label: v, value: v }))}
      onChange={(options) => onChange(options.map(o => o.value))}
      options={PRESET_GENRES}
      placeholder="Select genres..."
      creatable // Allow custom entries
      disabled={disabled}
      emptyIndicator={
        <p className="text-center text-sm text-muted-foreground">No genres found.</p>
      }
    />
  );
}
```

**Key Features:**
- `creatable` prop: Allows adding custom genres not in preset list
- Type-safe: Converts `Option[]` to `string[]` for schema compatibility
- Works with react-hook-form for form state management

### Pattern 5: URL Validation with Zod Schemas
**What:** Regex-based validation for streaming platform URLs in tRPC input schemas
**When to use:** All streaming platform URL fields (Spotify, Apple Music, etc.)
**Example:**
```typescript
// Source: Spotify URL regex patterns + ISRC format validation
// packages/server/src/utils/music-validators.ts

export const SPOTIFY_ARTIST_URL_REGEX = /^https?:\/\/(open|play)\.spotify\.com\/artist\/[A-Za-z0-9]{22}(\?.*)?$/;
export const APPLE_MUSIC_URL_REGEX = /^https?:\/\/music\.apple\.com\/.+\/artist\/.+/;
export const SOUNDCLOUD_URL_REGEX = /^https?:\/\/(www\.)?soundcloud\.com\/.+/;
export const YOUTUBE_URL_REGEX = /^https?:\/\/(www\.)?(youtube\.com|music\.youtube\.com)\/.+/;
export const BANDCAMP_URL_REGEX = /^https?:\/\/[a-zA-Z0-9-]+\.bandcamp\.com\/?$/;
export const DEEZER_URL_REGEX = /^https?:\/\/(www\.)?deezer\.com\/.+\/artist\/.+/;

// ISRC format: CC-XXX-YY-NNNNN (hyphens optional)
export const ISRC_PREFIX_REGEX = /^[A-Z]{2}-?[A-Z0-9]{3}$/;

// tRPC input validation
// packages/server/src/routers/clients.ts

update: protectedProcedure
  .input(z.object({
    id: z.number(),
    spotifyUrl: z.string().regex(SPOTIFY_ARTIST_URL_REGEX, "Invalid Spotify Artist URL").optional(),
    appleMusicUrl: z.string().regex(APPLE_MUSIC_URL_REGEX, "Invalid Apple Music URL").optional(),
    isrcPrefix: z.string().regex(ISRC_PREFIX_REGEX, "Invalid ISRC prefix (format: CC-XXX)").optional(),
    // ... other fields
  }))
```

**Validation Levels:**
- **Spotify Artist URL:** Strict (22-char ID required)
- **Apple Music/SoundCloud/YouTube:** Lenient (domain + path validation)
- **ISRC Prefix:** Format validation only (2-letter country + 3-char registrant)

### Pattern 6: Separate MusicProfileSection Component
**What:** Modular component following `EnrichedClientInfo` pattern
**When to use:** Keep music profile separate from vCard fields for clarity
**Example:**
```typescript
// Source: Existing EnrichedClientInfo.tsx pattern
// packages/client/src/components/MusicProfileSection.tsx

interface MusicProfileSectionProps {
  client: Client;
  isEditing: boolean;
  onUpdate: (data: Partial<Client>) => void;
}

export function MusicProfileSection({ client, isEditing, onUpdate }: MusicProfileSectionProps) {
  return (
    <div className="space-y-6">
      {/* Genre Selection Card */}
      <Card>
        <CardHeader>
          <CardTitle>Genres musicaux</CardTitle>
        </CardHeader>
        <CardContent>
          <GenreSelector
            value={client.genres || []}
            onChange={(genres) => onUpdate({ genres })}
            disabled={!isEditing}
          />
        </CardContent>
      </Card>

      {/* Instruments Card */}
      <Card>
        <CardHeader>
          <CardTitle>Instruments</CardTitle>
        </CardHeader>
        <CardContent>
          <InstrumentSelector
            value={client.instruments || []}
            onChange={(instruments) => onUpdate({ instruments })}
            disabled={!isEditing}
          />
        </CardContent>
      </Card>

      {/* Streaming Platforms Card */}
      <Card>
        <CardHeader>
          <CardTitle>Présence en ligne</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div>
            <Label>Spotify Artist URL</Label>
            <Input
              value={client.spotifyUrl || ""}
              onChange={(e) => onUpdate({ spotifyUrl: e.target.value })}
              placeholder="https://open.spotify.com/artist/..."
              disabled={!isEditing}
            />
          </div>
          {/* ... other streaming platforms */}
        </CardContent>
      </Card>

      {/* Industry Information Card */}
      <Card>
        <CardHeader>
          <CardTitle>Informations industrie</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-2 gap-4">
          <div>
            <Label>Label</Label>
            <Input
              value={client.recordLabel || ""}
              onChange={(e) => onUpdate({ recordLabel: e.target.value })}
              disabled={!isEditing}
            />
          </div>
          {/* ... other industry fields */}
        </CardContent>
      </Card>
    </div>
  );
}
```

**Integration:**
```typescript
// packages/client/src/pages/ClientDetail.tsx

import { MusicProfileSection } from "@/components/MusicProfileSection";

// Inside ClientDetail render (within Tabs):
<TabsContent value="music-profile">
  <MusicProfileSection
    client={client}
    isEditing={isEditing}
    onUpdate={handleUpdateClient}
  />
</TabsContent>
```

### Anti-Patterns to Avoid
- **DON'T store JSONB as text:** Never use `text()` column type for JSON data - always use `jsonb()`
- **DON'T query JSONB without indexes:** Filtering JSONB arrays without GIN indexes will cause table scans
- **DON'T hardcode genre list in UI:** Keep genre presets configurable (future: load from backend)
- **DON'T validate URLs client-side only:** Always validate in tRPC schema (server-side) for security

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Multi-select with custom entries | Custom dropdown with checkboxes + input | shadcn-multi-select-component OR shadcn-ui-expansions Multiple Selector | Pre-built: accessibility, keyboard nav, creatable entries, search/filter, form integration |
| Genre taxonomy | Custom genre list in database | MusicBrainz Genre API (future enhancement) | Official taxonomy with 1000+ genres, hierarchical structure, community-maintained |
| Spotify URL validation | Manual string parsing | Regex pattern: `^https?://(open\|play)\.spotify\.com/artist/[A-Za-z0-9]{22}$` | Validated format, handles both open.spotify and play.spotify domains |
| ISRC validation | Custom format checker | Regex pattern: `^[A-Z]{2}-?[A-Z0-9]{3}-?[0-9]{2}-?[0-9]{5}$` | ISO 3901:2019 standard, handles optional hyphens |
| JSONB array search | Loop through results client-side | PostgreSQL `@>` operator with GIN index | Database-level filtering, index-optimized, scales to millions of rows |

**Key insight:** Music industry has established standards (ISRC, streaming URL formats). Use proven patterns instead of inventing custom solutions.

## Common Pitfalls

### Pitfall 1: JSONB Queries Without Indexes (Performance Issue)
**What goes wrong:** Filtering by genre/instrument causes slow queries (table scans) on large datasets
**Why it happens:** PostgreSQL must deserialize every JSONB row to check containment without index
**How to avoid:**
1. Create GIN indexes on ALL JSONB columns used in WHERE clauses
2. Use `@>` containment operator instead of `::text LIKE '%value%'`
3. Test with realistic dataset (1000+ clients)

**Warning signs:**
- Query takes >500ms on 1000 clients
- `EXPLAIN ANALYZE` shows "Seq Scan" instead of "Bitmap Index Scan"

**Fix:**
```sql
CREATE INDEX idx_clients_genres_gin ON clients USING GIN (genres jsonb_ops);
```

### Pitfall 2: Forgetting Development Migration Pattern
**What goes wrong:** Schema changes break existing tenant databases, requiring manual fixes
**Why it happens:** Migrations only apply to NEW tenants, not existing ones
**How to avoid:**
1. **Development:** Use "increment tenant number" pattern (create tenant_4, tenant_5, etc.)
2. **Production:** Write progressive migrations that add columns as nullable/default
3. Document migration strategy in PLAN.md

**Warning signs:**
- Error: `column "genres" does not exist` on existing tenant
- Spending >10 minutes debugging migration desync

**Fix (Development):**
```bash
# Don't fix migrations - create new tenant
pnpm db:generate  # Generate migration
# Create tenant_4 with new schema (migration applies automatically)
# Ignore tenant_1, tenant_2, tenant_3
```

### Pitfall 3: Client-Side Only URL Validation
**What goes wrong:** Invalid URLs stored in database, breaking links and analytics
**Why it happens:** Trusting frontend validation without backend verification
**How to avoid:**
1. Validate URLs in tRPC input schema with zod regex
2. Client-side validation is UX only, never security
3. Return clear error messages on validation failure

**Warning signs:**
- Invalid URLs in production database
- Broken links on client detail page
- Analytics scripts fail on malformed URLs

**Fix:**
```typescript
// tRPC schema validation (server-side, enforced)
.input(z.object({
  spotifyUrl: z.string().regex(SPOTIFY_ARTIST_URL_REGEX, "Invalid Spotify URL").optional(),
}))
```

### Pitfall 4: Genre List Management Chaos
**What goes wrong:** Genre list grows uncontrolled, duplicates appear ("Rock" vs "rock"), no taxonomy
**Why it happens:** Allowing completely free-form custom entries without normalization
**How to avoid:**
1. Use preset list of common genres (50-100 options)
2. Allow custom entries but normalize (trim, capitalize, deduplicate)
3. Future: Validate against MusicBrainz genre API

**Warning signs:**
- Genre filter has 300+ unique values
- Duplicates: "Rock", "rock", "ROCK", "Rock music"
- Can't aggregate stats meaningfully

**Fix:**
```typescript
// Normalize genre input
const normalizeGenre = (genre: string) => {
  return genre.trim().toLowerCase().replace(/\s+/g, ' ');
};

// Before saving
const genres = input.genres.map(normalizeGenre);
```

### Pitfall 5: Instruments Array Structure Inconsistency
**What goes wrong:** Some instruments stored as strings, others as objects with proficiency
**Why it happens:** Schema allows `Array<{ name, proficiency }>` but UI code sometimes saves `string[]`
**How to avoid:**
1. Enforce schema with TypeScript: `Array<{ name: string; proficiency: string }>`
2. Validate in tRPC: `z.array(z.object({ name: z.string(), proficiency: z.enum(['beginner', 'intermediate', 'pro']) }))`
3. Migrate old data during schema change

**Warning signs:**
- Error: `Cannot read property 'proficiency' of string`
- Instrument filter returns incomplete results

**Fix:**
```typescript
// Strict schema enforcement
instruments: z.array(z.object({
  name: z.string(),
  proficiency: z.enum(['beginner', 'intermediate', 'pro'])
})).optional()
```

## Code Examples

Verified patterns from official sources:

### PostgreSQL JSONB Containment Query
```sql
-- Source: PostgreSQL JSON Types documentation
-- Check if genres array contains "Rock"
SELECT * FROM clients
WHERE genres @> '["Rock"]';

-- Check if instruments array contains object with name "Guitar"
SELECT * FROM clients
WHERE instruments @> '[{"name": "Guitar"}]';

-- Multiple genre filter (contains ANY)
SELECT * FROM clients
WHERE genres ?| array['Rock', 'Pop']; -- ?| = contains any of

-- Multiple genre filter (contains ALL)
SELECT * FROM clients
WHERE genres ?& array['Rock', 'Alternative']; -- ?& = contains all of
```

### Drizzle ORM Migration Generation
```bash
# Source: Project DEVELOPMENT-WORKFLOW.md
# After modifying schema.ts

# 1. Generate migration SQL
pnpm db:generate

# 2. Development: Create new tenant (schema auto-applies)
# Migration applies automatically to NEW tenants

# 3. Production: Progressive migration (add nullable columns)
# Manual script needed for existing tenants
```

### shadcn-ui-expansions Multiple Selector (Creatable)
```typescript
// Source: https://shadcnui-expansions.typeart.cc/docs/multiple-selector
import { MultipleSelector, Option } from '@/components/ui/multiple-selector';

<MultipleSelector
  value={selected}
  onChange={setSelected}
  defaultOptions={PRESET_OPTIONS}
  placeholder="Select genres..."
  creatable // Allow custom entries
  emptyIndicator={
    <p className="text-center text-sm">No results found.</p>
  }
/>
```

### ISRC Prefix Validation
```typescript
// Source: IFPI ISRC Handbook + MusicBrainz ISRC documentation
const ISRC_PREFIX_REGEX = /^[A-Z]{2}-?[A-Z0-9]{3}$/;

// Examples:
// Valid: "US-ABC", "USABC", "QM-123", "FR-Z5X"
// Invalid: "us-abc" (lowercase), "USA-BC" (wrong length), "12-345" (numbers in country code)

function validateISRCPrefix(prefix: string): boolean {
  return ISRC_PREFIX_REGEX.test(prefix.toUpperCase());
}
```

### Spotify Artist URL Extraction
```typescript
// Source: Spotify URL format patterns
const SPOTIFY_ARTIST_ID_REGEX = /spotify\.com\/artist\/([A-Za-z0-9]{22})/;

function extractSpotifyArtistId(url: string): string | null {
  const match = url.match(SPOTIFY_ARTIST_ID_REGEX);
  return match ? match[1] : null;
}

// Example:
// Input: "https://open.spotify.com/artist/3TVXtAsR1Inumwj472S9r4?si=abc123"
// Output: "3TVXtAsR1Inumwj472S9r4"
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Separate genre/instrument tables with junction tables | JSONB arrays with GIN indexes | 2020-2023 | Simpler schema, fewer joins, better performance for small-medium cardinality |
| HTML5 `<select multiple>` | shadcn multi-select components | 2023-2024 | Better UX, accessibility, custom entries, search |
| Manual JSON parsing in SQL | Native JSONB operators (`@>`, `?|`, `?&`) | PostgreSQL 9.4+ (2014) | 10-100x faster queries, index support |
| Text-based genre storage | Structured taxonomy (MusicBrainz API) | 2024-2025 | Standardized genres, hierarchical classification |
| Free-form URLs | Validated streaming platform URLs with regex | 2024+ | Data integrity, clickable links, analytics integration |

**Deprecated/outdated:**
- `text` column type for JSON data → Use `jsonb` (PostgreSQL 9.4+)
- Client-side only multi-select → Use shadcn components with server validation
- Hardcoded genre lists in frontend → Use MusicBrainz API (future enhancement)

## Open Questions

Things that couldn't be fully resolved:

1. **MusicBrainz Genre API Integration**
   - What we know: MusicBrainz has `/genre/all` endpoint (returns all genres as text)
   - What's unclear: Rate limits, caching strategy, how to sync genre taxonomy to local database
   - Recommendation: Phase 18.4 uses preset genre list (50-100 common genres), Phase 19+ adds MusicBrainz sync

2. **Instrument Proficiency Levels**
   - What we know: Standard levels are "beginner", "intermediate", "pro" (or "expert")
   - What's unclear: Should "pro" and "expert" be separate levels? Industry standard terminology?
   - Recommendation: Start with 3 levels (beginner/intermediate/pro), add "expert" later if users request

3. **Performance Rights Society List**
   - What we know: Major societies include SACEM (France), SOCAN (Canada), BMI/ASCAP (USA), PRS (UK)
   - What's unclear: Complete list of worldwide societies, how to validate member IDs
   - Recommendation: Use free-form varchar field, add dropdown list later if needed

4. **Vocal Range Terminology**
   - What we know: Classical terms (Soprano, Alto, Tenor, Baritone, Bass)
   - What's unclear: Should we include modern equivalents (High, Mid, Low)? Multiple classifications?
   - Recommendation: Use classical terms (industry standard), add "Other" option for flexibility

5. **Genre Normalization Strategy**
   - What we know: Need to prevent duplicates ("Rock" vs "rock")
   - What's unclear: Should normalization be case-insensitive only, or include synonym mapping ("Electronic" = "EDM")?
   - Recommendation: Phase 18.4 does case-insensitive normalization only, synonym mapping is Phase 19+ if needed

## Sources

### Primary (HIGH confidence)
- [PostgreSQL JSON Types Documentation](https://www.postgresql.org/docs/current/datatype-json.html) - JSONB data type specification
- [PostgreSQL JSON Functions and Operators](https://www.postgresql.org/docs/9.4/functions-json.html) - `@>` containment operator
- [Drizzle ORM PostgreSQL Column Types](https://orm.drizzle.team/docs/column-types/pg) - JSONB with `.$type<T[]>()`
- [IFPI ISRC Handbook](https://www.ifpi.org/wp-content/uploads/2021/02/ISRC_Handbook.pdf) - ISRC format specification (ISO 3901:2019)
- [MusicBrainz Genre Documentation](https://musicbrainz.org/doc/Genre) - Genre taxonomy structure

### Secondary (MEDIUM confidence)
- [PostgreSQL JSON Array Length Guide (2026)](https://copyprogramming.com/howto/postgresql-filtering-on-array-length-inside-json) - JSONB array filtering best practices
- [Querying JSONB in PostgreSQL](https://www.tigerdata.com/learn/how-to-query-jsonb-in-postgresql) - Query patterns and performance
- [shadcn-multi-select-component](https://github.com/sersavan/shadcn-multi-select-component) - Multi-select with custom entries
- [shadcn-ui-expansions Multiple Selector](https://shadcnui-expansions.typeart.cc/docs/multiple-selector) - Creatable multi-select
- [Spotify URL Regexp](https://gist.github.com/fantattitude/3627354) - Artist URL format validation
- [Drizzle ORM Best Practices (2025)](https://gist.github.com/productdevbook/7c9ce3bbeb96b3fabc3c7c2aa2abc717) - JSONB query patterns

### Tertiary (LOW confidence)
- [A Taxonomy of Musical Genres](https://www.francoispachet.fr/wp-content/uploads/2021/01/pachet-00-RIAO.pdf) - Academic research on genre classification (needs verification for production use)
- [Discogs Genre Guidelines](https://support.discogs.com/hc/en-us/articles/360005055213-Database-Guidelines-9-Genres-Styles) - Genre/style hierarchy (different domain than recording studio)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - PostgreSQL JSONB, Drizzle ORM, shadcn components all verified in official docs
- Architecture: HIGH - JSONB array patterns documented in PostgreSQL docs, project already uses similar patterns
- Pitfalls: HIGH - Based on known PostgreSQL indexing issues, development migration pattern from project DEVELOPMENT-WORKFLOW.md
- URL validation: MEDIUM - Regex patterns from community sources, need testing with real URLs
- Genre taxonomy: MEDIUM - MusicBrainz API available but integration details unclear

**Research date:** 2026-01-17
**Valid until:** 30 days (2026-02-16) - PostgreSQL/Drizzle patterns stable, shadcn components may update monthly
