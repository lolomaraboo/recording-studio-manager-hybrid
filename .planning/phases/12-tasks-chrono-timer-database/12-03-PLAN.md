---
phase: 12-tasks-chrono-timer-database
plan: 3
type: execute
---

<objective>
Integrate Socket.IO for real-time timer updates across multiple users and devices.

Purpose: Enable instant timer state synchronization - when one user starts/stops a timer, all connected users see the update immediately without page refresh.
Output: Socket.IO server integrated with Express, authenticated connections, real-time timer event broadcasting.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-tasks-chrono-timer-database/12-01-SUMMARY.md
@.planning/phases/12-tasks-chrono-timer-database/12-02-SUMMARY.md

**Current Architecture:**
- Express server running on port 3001 (development)
- Session-based authentication with express-session + Redis
- tRPC middleware for API endpoints
- Socket.IO client already installed (v4.8.1)

**Relevant Files:**
@packages/server/src/index.ts
@packages/server/package.json
@packages/client/package.json

**Phase Context:**
Plans 12-01 and 12-02 created database schema and tRPC API. This plan adds real-time layer so timer updates broadcast to all connected users in the same organization.

**WebSocket Security:**
- Authenticate socket connections using session cookies
- Only broadcast timer events to users in same organization (tenant isolation)
- Room pattern: socket.join(`org:${organizationId}`) for scoped broadcasting

**Prior Decisions:**
- From STATE.md: Multi-tenant architecture requires organization-scoped communication
- From Phase 3.1: Session cookies already configured with domain `.recording-studio-manager.com`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Socket.IO server and integrate with Express</name>
  <files>packages/server/package.json, packages/server/src/index.ts, packages/server/src/middleware/socket-auth.ts</files>
  <action>
**Step 1: Install Socket.IO server**
```bash
pnpm --filter server add socket.io@^4.8.1
```

**Step 2: Integrate Socket.IO with Express server in index.ts**

Add Socket.IO setup after Express app creation but before server.listen():

```typescript
import { Server as SocketIOServer } from 'socket.io';
import { createServer } from 'http';

// After: const app = express();

const httpServer = createServer(app);
const io = new SocketIOServer(httpServer, {
  cors: {
    origin: process.env.NODE_ENV === 'production'
      ? /^https:\/\/([a-z0-9-]+\.)?recording-studio-manager\.com$/
      : 'http://localhost:5174',
    credentials: true,
  },
});

// Store io instance for use in routes/services
app.set('io', io);

// Socket.IO middleware for authentication (see Task 1b)
io.use(socketAuthMiddleware);

// Socket.IO connection handler
io.on('connection', (socket) => {
  console.log(`[Socket.IO] User connected: ${socket.data.userId} (org: ${socket.data.organizationId})`);

  // Join organization-specific room for scoped broadcasting
  socket.join(`org:${socket.data.organizationId}`);

  socket.on('disconnect', () => {
    console.log(`[Socket.IO] User disconnected: ${socket.data.userId}`);
  });
});

// IMPORTANT: Change app.listen() to httpServer.listen()
// FROM: app.listen(port, ...)
// TO: httpServer.listen(port, ...)
```

**Step 3: Create socket authentication middleware in middleware/socket-auth.ts**

Authenticate socket connections using session cookies:

```typescript
import { Socket } from 'socket.io';
import { sessionMiddleware } from './session'; // Import existing express-session middleware

export const socketAuthMiddleware = (socket: Socket, next: (err?: Error) => void) => {
  // Use express-session middleware to parse session from cookie
  sessionMiddleware(socket.request as any, {} as any, () => {
    const session = (socket.request as any).session;

    if (!session?.userId || !session?.organizationId) {
      return next(new Error('Unauthorized: No valid session'));
    }

    // Store user context in socket for use in handlers
    socket.data.userId = session.userId;
    socket.data.organizationId = session.organizationId;

    next();
  });
};
```

This reuses existing session authentication - no separate WebSocket auth needed.
  </action>
  <verify>
- socket.io package installed in server package.json
- Socket.IO server integrated in index.ts
- Server starts without errors: `DATABASE_URL="..." pnpm --filter server dev`
- httpServer.listen() used instead of app.listen()
- Socket authentication middleware created
- Console logs "User connected" when client connects (test in Plan 12-03)
  </verify>
  <done>Socket.IO server integrated with Express, authenticated connections working, organization rooms configured</done>
</task>

<task type="auto">
  <name>Task 2: Implement real-time timer event broadcasting</name>
  <files>packages/server/src/routers/time-tracking.ts, packages/server/src/services/timer-service.ts</files>
  <action>
**Step 1: Add Socket.IO broadcasting to timer router procedures**

Modify time-tracking router to broadcast events after timer operations:

In `timer.start` procedure (after calling timerService.startTimer):
```typescript
const io = ctx.req.app.get('io');
io.to(`org:${ctx.organizationId}`).emit('timer:started', {
  timeEntryId: result.id,
  taskType: result.task_type,
  sessionId: result.sessionId,
  projectId: result.projectId,
  startTime: result.startTime,
  userId: ctx.userId,
});
```

In `timer.stop` procedure (after calling timerService.stopTimer):
```typescript
const io = ctx.req.app.get('io');
io.to(`org:${ctx.organizationId}`).emit('timer:stopped', {
  timeEntryId: result.id,
  endTime: result.endTime,
  durationMinutes: result.durationMinutes,
  cost: calculateCost(result),
  userId: ctx.userId,
});
```

In `timeEntries.adjust` procedure (after manual adjustment):
```typescript
const io = ctx.req.app.get('io');
io.to(`org:${ctx.organizationId}`).emit('timer:adjusted', {
  timeEntryId: result.id,
  startTime: result.startTime,
  endTime: result.endTime,
  durationMinutes: result.durationMinutes,
  userId: ctx.userId,
});
```

**Step 2: Add type definitions for socket events**

Create `packages/shared/src/socket-events.ts`:
```typescript
export interface TimerStartedEvent {
  timeEntryId: number;
  taskType: { id: number; name: string; color: string };
  sessionId: number | null;
  projectId: number | null;
  startTime: Date;
  userId: number;
}

export interface TimerStoppedEvent {
  timeEntryId: number;
  endTime: Date;
  durationMinutes: number;
  cost: { hours: number; minutes: number; cost: number; formattedCost: string };
  userId: number;
}

export interface TimerAdjustedEvent {
  timeEntryId: number;
  startTime: Date;
  endTime: Date | null;
  durationMinutes: number | null;
  userId: number;
}

export type SocketEvents = {
  'timer:started': TimerStartedEvent;
  'timer:stopped': TimerStoppedEvent;
  'timer:adjusted': TimerAdjustedEvent;
};
```

Export from shared package index.
  </action>
  <verify>
- Timer router emits 3 events (timer:started, timer:stopped, timer:adjusted)
- Events broadcast to correct organization room (`org:${organizationId}`)
- Socket event types defined in shared package
- TypeScript compilation succeeds: `pnpm check`
- Server logs show socket.io events when timer operations occur
  </verify>
  <done>Real-time broadcasting implemented for timer events, type-safe socket events, organization-scoped rooms working</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Socket.IO real-time timer system with authentication and organization-scoped broadcasting</what-built>
  <how-to-verify>
    1. Start development servers:
       ```bash
       # Terminal 1: Server
       DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" pnpm --filter server dev

       # Terminal 2: Client
       pnpm --filter client dev
       ```

    2. Open browser DevTools Console (F12) and run:
       ```javascript
       // This will be implemented in Phase 13 UI, but you can test manually:
       import { io } from 'socket.io-client';
       const socket = io('http://localhost:3001', { withCredentials: true });

       socket.on('connect', () => console.log('‚úÖ Socket connected:', socket.id));
       socket.on('timer:started', (data) => console.log('üü¢ Timer started:', data));
       socket.on('timer:stopped', (data) => console.log('üî¥ Timer stopped:', data));
       socket.on('timer:adjusted', (data) => console.log('‚úèÔ∏è Timer adjusted:', data));
       ```

    3. Test via tRPC Playground or curl:
       ```bash
       # Start timer (replace with actual taskTypeId from seed data)
       curl -X POST http://localhost:3001/api/trpc/timeTracking.timer.start \
         -H "Content-Type: application/json" \
         -H "x-test-user-id: 1" \
         -H "x-test-org-id: 1" \
         -d '{"taskTypeId": 1, "sessionId": 1}'
       ```

    4. Verify in console:
       - ‚úÖ Socket connection established
       - ‚úÖ "timer:started" event received with correct data
       - ‚úÖ Event contains timeEntryId, taskType, timestamps

    5. Stop timer and verify "timer:stopped" event

    6. Check server logs for:
       - "User connected: [userId] (org: [orgId])"
       - Socket.IO event emissions
  </how-to-verify>
  <resume-signal>Type "approved" if Socket.IO connects and events broadcast correctly, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] socket.io@^4.8.1 installed in server package.json
- [ ] Socket.IO server integrated with Express (httpServer pattern)
- [ ] Socket authentication middleware uses existing session
- [ ] Organization-scoped rooms implemented (`org:${organizationId}`)
- [ ] 3 timer events broadcasting (started/stopped/adjusted)
- [ ] Socket event types defined in shared package
- [ ] Manual testing confirms real-time events work
- [ ] `pnpm check` passes with 0 TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Socket.IO authenticated connections working
- Timer events broadcast in real-time to organization members
- Type-safe socket events defined
- Ready for Phase 13 UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/12-tasks-chrono-timer-database/12-03-SUMMARY.md`:

# Phase 12 Plan 3: Socket.IO Integration Summary

**Real-time timer synchronization complete with WebSocket broadcasting**

## Accomplishments

- Installed Socket.IO server v4.8.1
- Integrated Socket.IO with Express server (httpServer pattern)
- Created socket authentication middleware reusing express-session
- Implemented organization-scoped broadcasting (`org:${organizationId}` rooms)
- Added real-time events: timer:started, timer:stopped, timer:adjusted
- Defined type-safe socket event interfaces in shared package

## Files Created/Modified

- `packages/server/package.json` - Added socket.io dependency
- `packages/server/src/index.ts` - Socket.IO server setup, connection handler
- `packages/server/src/middleware/socket-auth.ts` - Socket authentication
- `packages/server/src/routers/time-tracking.ts` - Event broadcasting in 3 procedures
- `packages/shared/src/socket-events.ts` - TypeScript event interfaces

## Decisions Made

- Reuse express-session for socket authentication (no separate WebSocket auth)
- Organization-scoped rooms ensure multi-tenant isolation (users only see their org's timers)
- Broadcast events AFTER database operations complete (consistency)
- Include userId in events for UI attribution ("John started timer")

## Issues Encountered

None

## Next Step

**Phase 12 COMPLETE** - Ready for Phase 13 (Tasks Chronom√©tr√©es - UI & History)

Backend foundation complete:
- ‚úÖ Database schema (task_types, time_entries)
- ‚úÖ tRPC API (8 procedures)
- ‚úÖ Real-time WebSocket broadcasting
- ‚úÖ Default task types seeded

Phase 13 will build the UI layer (timer component, history view, manual entry forms).
</output>
