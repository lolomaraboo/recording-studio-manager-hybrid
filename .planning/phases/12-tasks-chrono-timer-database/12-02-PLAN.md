---
phase: 12-tasks-chrono-timer-database
plan: 2
type: execute
---

<objective>
Implement timer backend logic and tRPC API endpoints for time tracking operations.

Purpose: Enable timer start/stop/pause functionality, time entry management, and hourly rate calculations through type-safe tRPC procedures.
Output: Timer service module, tRPC router with 8+ procedures, and business logic for time tracking.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-tasks-chrono-timer-database/12-01-SUMMARY.md

**Current Architecture:**
- tRPC v11 for type-safe API
- All routers use `ctx.getTenantDb()` pattern for multi-tenancy
- Existing routers: clients, sessions, invoices, projects, equipment, rooms
- Router location: `packages/server/src/routers/`
- Router registration: `packages/server/src/routers/index.ts`

**Relevant Files:**
@packages/server/src/routers/sessions.ts
@packages/server/src/routers/index.ts
@packages/database/src/tenant/schema.ts

**Phase Context:**
Plan 12-01 created database schema (task_types, time_entries). This plan implements business logic and API layer. Plan 12-03 will add WebSocket real-time features.

**Prior Decisions:**
- From Phase 12-01: hourlyRate snapshotted in time_entries for historical accuracy
- From Phase 12-01: Time entries link to sessionId OR projectId (flexible)
- From STATE.md: All routers use protectedProcedure with tenant context
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timer service module with business logic</name>
  <files>packages/server/src/services/timer-service.ts</files>
  <action>
Create timer service module with core business logic functions:

**Functions to implement:**

1. `startTimer(db, data)`: Start new time entry
   - Input: { taskTypeId, sessionId?, projectId?, notes? }
   - Validation: Ensure taskTypeId exists, sessionId OR projectId provided
   - Check: No active timer already running for this session/project
   - Fetch: Current hourlyRate from task_types (for snapshot)
   - Insert: time_entries with startTime=now(), endTime=null, hourlyRateSnapshot
   - Return: Created time entry with task_type details

2. `stopTimer(db, timeEntryId)`: Stop running timer
   - Validation: Time entry exists and endTime is null
   - Calculate: durationMinutes from startTime to now
   - Update: Set endTime=now(), durationMinutes
   - Return: Updated time entry

3. `getActiveTimer(db, sessionId?, projectId?)`: Get currently running timer
   - Query: time_entries WHERE endTime IS NULL AND (sessionId OR projectId)
   - Join: task_types for full details
   - Return: Active time entry or null

4. `adjustTimeEntry(db, timeEntryId, data)`: Manual time adjustment
   - Input: { startTime?, endTime?, notes? }
   - Recalculate: durationMinutes if times changed
   - Update: Set manuallyAdjusted=true
   - Return: Updated time entry

5. `calculateCost(timeEntry)`: Calculate cost from duration and rate
   - Formula: (durationMinutes / 60) * hourlyRateSnapshot
   - Return: { hours, minutes, cost, formattedCost }

6. `getTimeHistory(db, sessionId?, projectId?, filters?)`: Query time entries
   - Support filters: dateRange, taskTypeIds, includeManuallyAdjusted
   - Join: task_types for names/colors
   - Order: startTime DESC
   - Return: Array of time entries with aggregated stats (totalHours, totalCost)

Use Drizzle ORM query patterns from existing routers (see sessions.ts for reference).
Handle errors with descriptive messages (e.g., "Cannot start timer: active timer already running").
  </action>
  <verify>
- Service file exports all 6 functions
- TypeScript compilation succeeds: `pnpm --filter server check`
- Functions use correct Drizzle ORM syntax
- Error handling included for edge cases
  </verify>
  <done>Timer service module complete with 6 business logic functions, type-safe, error handling implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create tRPC time tracking router</name>
  <files>packages/server/src/routers/time-tracking.ts, packages/server/src/routers/index.ts</files>
  <action>
Create time-tracking tRPC router in `packages/server/src/routers/time-tracking.ts`:

**Procedures to implement:**

1. **taskTypes.list**: Query all active task types
   - Input: z.object({ includeInactive: z.boolean().optional() })
   - Query: task_types WHERE isActive=true (or all if includeInactive)
   - Order: sortOrder ASC, name ASC
   - Return: TaskType[]

2. **taskTypes.create**: Create new task type
   - Input: z.object({ name, description?, hourlyRate, category, color?, sortOrder? })
   - Insert: task_types table
   - Return: Created TaskType

3. **taskTypes.update**: Update task type
   - Input: z.object({ id, name?, hourlyRate?, isActive?, ... })
   - Update: task_types WHERE id
   - Return: Updated TaskType

4. **timer.start**: Start timer
   - Input: z.object({ taskTypeId, sessionId?, projectId?, notes? })
   - Validation: sessionId XOR projectId (exactly one required)
   - Call: timerService.startTimer()
   - Return: TimeEntry with task_type joined

5. **timer.stop**: Stop timer
   - Input: z.object({ timeEntryId })
   - Call: timerService.stopTimer()
   - Return: Updated TimeEntry

6. **timer.getActive**: Get active timer for session/project
   - Input: z.object({ sessionId?, projectId? })
   - Call: timerService.getActiveTimer()
   - Return: TimeEntry | null

7. **timeEntries.list**: Get time history
   - Input: z.object({ sessionId?, projectId?, dateRange?, taskTypeIds? })
   - Call: timerService.getTimeHistory()
   - Return: { entries: TimeEntry[], stats: { totalHours, totalCost } }

8. **timeEntries.adjust**: Manual adjustment
   - Input: z.object({ timeEntryId, startTime?, endTime?, notes? })
   - Call: timerService.adjustTimeEntry()
   - Return: Updated TimeEntry

All procedures use `protectedProcedure` and `ctx.getTenantDb()` pattern.

**Register router in index.ts:**
Import and add to root router:
```typescript
import { timeTrackingRouter } from './time-tracking';
// ...
timeTracking: timeTrackingRouter,
```
  </action>
  <verify>
- Router file exports timeTrackingRouter
- 8 procedures defined with Zod input validation
- All procedures use protectedProcedure and getTenantDb()
- Router registered in index.ts
- TypeScript compilation succeeds: `pnpm --filter server check`
  </verify>
  <done>tRPC time tracking router complete with 8 procedures, input validation, registered in root router, type-safe</done>
</task>

<task type="auto">
  <name>Task 3: Seed default task types for testing</name>
  <files>packages/database/src/scripts/seed-task-types.ts</files>
  <action>
Create seed script for default task types:

**Default task types to seed (for tenant_1):**
1. Setup (Billable, $50/hr, #3B82F6 blue, sortOrder: 1)
2. Recording (Billable, $75/hr, #EF4444 red, sortOrder: 2)
3. Mixing (Billable, $60/hr, #10B981 green, sortOrder: 3)
4. Mastering (Billable, $80/hr, #8B5CF6 purple, sortOrder: 4)
5. Break (Non-billable, $0/hr, #6B7280 gray, sortOrder: 5)

Script should:
- Import getTenantDb from connection.ts
- Get tenant DB for organization 1
- Check if task_types already exist (don't duplicate)
- Insert 5 default task types
- Log success/skip messages

Run script after creation:
```bash
DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" TENANT_DB_NAME="tenant_1" pnpm --filter database tsx src/scripts/seed-task-types.ts
```
  </action>
  <verify>
- Script file exists and runs without errors
- 5 task types inserted into tenant_1.task_types
- Re-running script doesn't create duplicates
- Console logs confirm insertion or skip
  </verify>
  <done>Seed script created, default task types in tenant_1, script idempotent (safe to re-run)</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter server check` passes with 0 TypeScript errors
- [ ] Timer service exports 6 functions (start/stop/getActive/adjust/calculateCost/getTimeHistory)
- [ ] tRPC router exports 8 procedures (3 taskTypes, 3 timer, 2 timeEntries)
- [ ] Router registered in index.ts
- [ ] Seed script creates 5 default task types in tenant_1
- [ ] tRPC types regenerated on client: `pnpm --filter client build` succeeds
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors in server or client
- API endpoints ready for frontend integration (Plan 13)
- Default task types seeded for development testing
</success_criteria>

<output>
After completion, create `.planning/phases/12-tasks-chrono-timer-database/12-02-SUMMARY.md`:

# Phase 12 Plan 2: Timer Backend Logic Summary

**Backend timer API complete with business logic and tRPC endpoints**

## Accomplishments

- Created timer-service.ts with 6 business logic functions
- Created tRPC time-tracking router with 8 procedures
- Seeded 5 default task types for development (Setup/Recording/Mixing/Mastering/Break)
- Implemented hourly rate calculations and duration tracking

## Files Created/Modified

- `packages/server/src/services/timer-service.ts` - Timer business logic (6 functions)
- `packages/server/src/routers/time-tracking.ts` - tRPC router (8 procedures)
- `packages/server/src/routers/index.ts` - Registered timeTracking router
- `packages/database/src/scripts/seed-task-types.ts` - Seed script for defaults

## Decisions Made

- XOR validation: timer.start requires exactly one of sessionId OR projectId (not both)
- Calculate cost formula: (durationMinutes / 60) * hourlyRateSnapshot
- Manual adjustments set manuallyAdjusted=true flag for audit trail
- getTimeHistory returns aggregated stats (totalHours, totalCost) for billing summaries

## Issues Encountered

None

## Next Step

Ready for 12-03-PLAN.md (Real-time Socket.IO Integration)
</output>
