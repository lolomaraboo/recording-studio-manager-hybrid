---
phase: 33-harmonisation-sessions---routing-cohérent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/client/src/components/SessionEditForm.tsx (new file)
  - packages/client/src/pages/SessionCreate.tsx
autonomous: true

must_haves:
  truths:
    - "SessionCreate uses accordion pattern like ClientEditForm and TalentEditForm"
    - "Inline form replaced with SessionEditForm component"
    - "Accordions open by default for immediate field access"
    - "Form structure matches session context (scheduling, payment, participants)"
  artifacts:
    - path: "packages/client/src/components/SessionEditForm.tsx"
      provides: "Accordion-based edit form for sessions"
      min_lines: 500
      exports: ["SessionEditForm"]
    - path: "packages/client/src/pages/SessionCreate.tsx"
      provides: "Simplified creation page using SessionEditForm"
      min_lines: 150
      contains: "SessionEditForm"
  key_links:
    - from: "SessionCreate.tsx"
      to: "SessionEditForm"
      via: "reusable component for creation"
      pattern: "SessionEditForm"
    - from: "SessionEditForm"
      to: "formData state"
      via: "two-way binding with setFormData"
      pattern: "formData.*setFormData"
---

<objective>
Create SessionEditForm component with accordion pattern and refactor SessionCreate page to use it, achieving harmonization with Clients (Phase 26), Talents (Phase 28), and Services patterns.

Purpose: Sessions is the central workflow resource - consistent UI eliminates friction across all major entities
Output: SessionEditForm component and refactored SessionCreate page
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Pattern reference (Phase 28 TalentEditForm)
@.planning/phases/28-harmonisation-ui-talents/28-05-PLAN.md

# Reference implementations
@packages/client/src/components/TalentEditForm.tsx (accordion pattern reference)
@packages/client/src/components/ClientEditForm.tsx (accordion pattern reference)

# Current session implementation
@packages/client/src/pages/SessionCreate.tsx (inline form - to be refactored)
@packages/database/src/tenant/schema.ts (sessions schema definition)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionEditForm component with accordions</name>
  <files>packages/client/src/components/SessionEditForm.tsx</files>
  <action>
**Pattern reference:** TalentEditForm.tsx, ClientEditForm.tsx (accordions, all open by default, organized sections)

**Create accordion-based edit form for sessions:**

1. **Component structure (adapt from TalentEditForm):**
   ```typescript
   import { useState, useEffect } from "react";
   import { Button } from "@/components/ui/button";
   import { Card } from "@/components/ui/card";
   import {
     Accordion,
     AccordionContent,
     AccordionItem,
     AccordionTrigger,
   } from "@/components/ui/accordion";
   import { Input } from "@/components/ui/input";
   import { Label } from "@/components/ui/label";
   import { Textarea } from "@/components/ui/textarea";
   import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
   import {
     CalendarClock,
     User,
     DollarSign,
     FileText,
   } from "lucide-react";

   interface SessionEditFormProps {
     formData: any;
     setFormData: (data: any) => void;
     clients?: any[];
     rooms?: any[];
     projects?: any[];
   }

   export function SessionEditForm({
     formData,
     setFormData,
     clients = [],
     rooms = [],
     projects = [],
   }: SessionEditFormProps) {
     // State for open accordions (all open by default)
     const [openItems, setOpenItems] = useState<string[]>(() => {
       try {
         const saved = localStorage.getItem('sessionEditAccordions');
         return saved ? JSON.parse(saved) : ["informations", "planning", "facturation", "notes"];
       } catch {
         return ["informations", "planning", "facturation", "notes"];
       }
     });

     // Save accordion state to localStorage
     useEffect(() => {
       try {
         localStorage.setItem('sessionEditAccordions', JSON.stringify(openItems));
       } catch (error) {
         console.error('Failed to save accordion state:', error);
       }
     }, [openItems]);

     // Alt key handler to toggle all accordions
     const handleAccordionTriggerClick = (event: React.MouseEvent) => {
       if (event.altKey) {
         event.preventDefault();
         event.stopPropagation();

         const allAccordions = ["informations", "planning", "facturation", "notes"];
         if (openItems.length < allAccordions.length) {
           setOpenItems(allAccordions);
         } else {
           setOpenItems([]);
         }
       }
     };

     return (
       <Accordion
         type="multiple"
         value={openItems}
         onValueChange={setOpenItems}
         className="space-y-2"
       >
         {/* Accordion 1: Informations */}
         {/* Accordion 2: Planning */}
         {/* Accordion 3: Facturation */}
         {/* Accordion 4: Notes */}
       </Accordion>
     );
   }
   ```

2. **Accordion 1: Informations** (title, description, client, room, project, status)
   ```typescript
   <AccordionItem value="informations">
     <Card>
       <AccordionTrigger className="px-4 py-3 hover:no-underline" onClick={handleAccordionTriggerClick}>
         <h3 className="text-lg font-semibold flex items-center gap-2">
           <FileText className="h-5 w-5 text-primary" />
           Informations
         </h3>
       </AccordionTrigger>
       <AccordionContent>
         <div className="px-4 pb-3 space-y-3">
           {/* Title */}
           <div>
             <Label htmlFor="title">
               Titre <span className="text-destructive">*</span>
             </Label>
             <Input
               id="title"
               value={formData.title || ""}
               onChange={(e) => setFormData({ ...formData, title: e.target.value })}
               placeholder="Ex: Session enregistrement album"
             />
           </div>

           {/* Description */}
           <div>
             <Label htmlFor="description">Description</Label>
             <Textarea
               id="description"
               value={formData.description || ""}
               onChange={(e) => setFormData({ ...formData, description: e.target.value })}
               placeholder="Description de la session..."
               rows={3}
             />
           </div>

           {/* Client & Room */}
           <div className="grid md:grid-cols-2 gap-3">
             <div>
               <Label htmlFor="clientId">
                 Client <span className="text-destructive">*</span>
               </Label>
               <Select
                 value={formData.clientId?.toString() || "0"}
                 onValueChange={(value) => setFormData({ ...formData, clientId: parseInt(value) })}
               >
                 <SelectTrigger id="clientId">
                   <SelectValue placeholder="Sélectionner un client" />
                 </SelectTrigger>
                 <SelectContent>
                   {clients.map((client) => (
                     <SelectItem key={client.id} value={client.id.toString()}>
                       {client.name}
                     </SelectItem>
                   ))}
                 </SelectContent>
               </Select>
             </div>

             <div>
               <Label htmlFor="roomId">
                 Salle <span className="text-destructive">*</span>
               </Label>
               <Select
                 value={formData.roomId?.toString() || "0"}
                 onValueChange={(value) => setFormData({ ...formData, roomId: parseInt(value) })}
               >
                 <SelectTrigger id="roomId">
                   <SelectValue placeholder="Sélectionner une salle" />
                 </SelectTrigger>
                 <SelectContent>
                   {rooms.map((room) => (
                     <SelectItem key={room.id} value={room.id.toString()}>
                       {room.name}
                     </SelectItem>
                   ))}
                 </SelectContent>
               </Select>
             </div>
           </div>

           {/* Project (optional) */}
           <div>
             <Label htmlFor="projectId">Projet associé (optionnel)</Label>
             <Select
               value={formData.projectId?.toString() || "0"}
               onValueChange={(value) => setFormData({ ...formData, projectId: parseInt(value) })}
             >
               <SelectTrigger id="projectId">
                 <SelectValue placeholder="Aucun projet (session standalone)" />
               </SelectTrigger>
               <SelectContent>
                 <SelectItem value="0">Aucun projet</SelectItem>
                 {projects.map((project) => (
                   <SelectItem key={project.id} value={project.id.toString()}>
                     {project.name}
                   </SelectItem>
                 ))}
               </SelectContent>
             </Select>
           </div>

           {/* Status */}
           <div>
             <Label htmlFor="status">Statut</Label>
             <Select
               value={formData.status || "scheduled"}
               onValueChange={(value) => setFormData({ ...formData, status: value })}
             >
               <SelectTrigger id="status">
                 <SelectValue />
               </SelectTrigger>
               <SelectContent>
                 <SelectItem value="scheduled">Planifiée</SelectItem>
                 <SelectItem value="in_progress">En cours</SelectItem>
                 <SelectItem value="completed">Terminée</SelectItem>
                 <SelectItem value="cancelled">Annulée</SelectItem>
               </SelectContent>
             </Select>
           </div>
         </div>
       </AccordionContent>
     </Card>
   </AccordionItem>
   ```

3. **Accordion 2: Planning** (startTime, endTime)
   ```typescript
   <AccordionItem value="planning">
     <Card>
       <AccordionTrigger className="px-4 py-3 hover:no-underline" onClick={handleAccordionTriggerClick}>
         <h3 className="text-lg font-semibold flex items-center gap-2">
           <CalendarClock className="h-5 w-5 text-primary" />
           Planning
         </h3>
       </AccordionTrigger>
       <AccordionContent>
         <div className="px-4 pb-3 space-y-3">
           <div className="grid md:grid-cols-2 gap-3">
             <div>
               <Label htmlFor="startTime">
                 Début <span className="text-destructive">*</span>
               </Label>
               <Input
                 id="startTime"
                 type="datetime-local"
                 value={formData.startTime || ""}
                 onChange={(e) => setFormData({ ...formData, startTime: e.target.value })}
               />
             </div>

             <div>
               <Label htmlFor="endTime">
                 Fin <span className="text-destructive">*</span>
               </Label>
               <Input
                 id="endTime"
                 type="datetime-local"
                 value={formData.endTime || ""}
                 onChange={(e) => setFormData({ ...formData, endTime: e.target.value })}
               />
             </div>
           </div>
         </div>
       </AccordionContent>
     </Card>
   </AccordionItem>
   ```

4. **Accordion 3: Facturation** (totalAmount, depositAmount, depositPaid, paymentStatus)
   ```typescript
   <AccordionItem value="facturation">
     <Card>
       <AccordionTrigger className="px-4 py-3 hover:no-underline" onClick={handleAccordionTriggerClick}>
         <h3 className="text-lg font-semibold flex items-center gap-2">
           <DollarSign className="h-5 w-5 text-primary" />
           Facturation
         </h3>
       </AccordionTrigger>
       <AccordionContent>
         <div className="px-4 pb-3 space-y-3">
           <div className="grid md:grid-cols-2 gap-3">
             <div>
               <Label htmlFor="totalAmount">Montant total</Label>
               <Input
                 id="totalAmount"
                 type="text"
                 value={formData.totalAmount || ""}
                 onChange={(e) => setFormData({ ...formData, totalAmount: e.target.value })}
                 placeholder="Ex: 500.00"
               />
             </div>

             <div>
               <Label htmlFor="depositAmount">Acompte requis</Label>
               <Input
                 id="depositAmount"
                 type="text"
                 value={formData.depositAmount || ""}
                 onChange={(e) => setFormData({ ...formData, depositAmount: e.target.value })}
                 placeholder="Ex: 150.00"
               />
               <p className="text-xs text-muted-foreground mt-1">Montant d'acompte à payer</p>
             </div>
           </div>

           <div className="grid md:grid-cols-2 gap-3">
             <div className="flex items-center space-x-2">
               <input
                 id="depositPaid"
                 type="checkbox"
                 checked={formData.depositPaid || false}
                 onChange={(e) => setFormData({ ...formData, depositPaid: e.target.checked })}
                 className="h-4 w-4 rounded border-gray-300"
               />
               <Label htmlFor="depositPaid" className="text-sm font-normal cursor-pointer">
                 Acompte payé
               </Label>
             </div>

             <div>
               <Label htmlFor="paymentStatus">Statut paiement</Label>
               <Select
                 value={formData.paymentStatus || "unpaid"}
                 onValueChange={(value) => setFormData({ ...formData, paymentStatus: value })}
               >
                 <SelectTrigger id="paymentStatus">
                   <SelectValue />
                 </SelectTrigger>
                 <SelectContent>
                   <SelectItem value="unpaid">Non payé</SelectItem>
                   <SelectItem value="partial">Partiel</SelectItem>
                   <SelectItem value="paid">Payé</SelectItem>
                   <SelectItem value="refunded">Remboursé</SelectItem>
                 </SelectContent>
               </Select>
             </div>
           </div>
         </div>
       </AccordionContent>
     </Card>
   </AccordionItem>
   ```

5. **Accordion 4: Notes** (internal notes)
   ```typescript
   <AccordionItem value="notes">
     <Card>
       <AccordionTrigger className="px-4 py-3 hover:no-underline" onClick={handleAccordionTriggerClick}>
         <h3 className="text-lg font-semibold flex items-center gap-2">
           <FileText className="h-5 w-5 text-primary" />
           Notes internes
         </h3>
       </AccordionTrigger>
       <AccordionContent>
         <div className="px-4 pb-3 space-y-3">
           <div>
             <Label htmlFor="notes">Notes</Label>
             <Textarea
               id="notes"
               value={formData.notes || ""}
               onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
               placeholder="Notes privées pour l'équipe..."
               rows={3}
             />
           </div>
         </div>
       </AccordionContent>
     </Card>
   </AccordionItem>
   ```

**Key design decisions:**
- 4 accordions (Informations, Planning, Facturation, Notes)
- All open by default with localStorage persistence
- Alt+Click toggles all accordions
- Props accept clients, rooms, projects arrays for Select components
- Matches TalentEditForm pattern but adapted for session-specific fields
- Payment fields grouped in Facturation accordion (totalAmount, depositAmount, depositPaid, paymentStatus)

**Why accordion pattern:** Sessions have complex field structure (scheduling + payment + metadata) - accordions organize fields logically while keeping all accessible without scrolling
  </action>
  <verify>
1. Component exports SessionEditForm
2. TypeScript 0 errors on component definition
3. All 4 accordions render correctly
4. localStorage persistence works (sessionEditAccordions key)
5. Alt+Click toggles all accordions
6. Form fields update formData correctly
7. Select components receive and render clients/rooms/projects props
  </verify>
  <done>
- SessionEditForm.tsx created with 4 accordions
- Informations, Planning, Facturation, Notes sections
- All accordions open by default
- localStorage persistence for accordion state
- Alt+Click toggle all feature
- Props for clients, rooms, projects arrays
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor SessionCreate.tsx to use SessionEditForm</name>
  <files>packages/client/src/pages/SessionCreate.tsx</files>
  <action>
**Pattern reference:** TalentCreate.tsx after Phase 28-05 refactor - reusable form component

**Simplify creation page:**

1. **Import SessionEditForm:**
   ```typescript
   import { SessionEditForm } from "@/components/SessionEditForm";
   ```

2. **Keep existing logic:**
   - formData state (lines 41-52)
   - createMutation with limit error handling (lines 25-38)
   - handleSubmit validation (lines 54-92)
   - Upgrade modal logic (lines 16, 306-312)
   - tRPC queries for clients, rooms, projects (lines 19-22)

3. **Replace Card with inline form (lines 114-302) with SessionEditForm:**
   ```typescript
   return (
     <div className="container pt-2 pb-4 px-2">
       <div className="space-y-2">
         {/* Header */}
         <div className="flex items-center justify-between">
           <div className="flex items-center gap-2">
             <Button variant="ghost" size="icon" asChild>
               <Link to="/sessions">
                 <ArrowLeft className="h-5 w-5" />
               </Link>
             </Button>
             <h2 className="text-3xl font-bold flex items-center gap-2">
               <Plus className="h-8 w-8 text-primary" />
               Nouvelle Session
             </h2>
           </div>
         </div>

         {/* Form */}
         <form onSubmit={handleSubmit}>
           <SessionEditForm
             formData={formData}
             setFormData={setFormData}
             clients={clients || []}
             rooms={rooms || []}
             projects={projects || []}
           />

           {/* Submit button */}
           <div className="mt-4 flex gap-2">
             <Button type="submit" disabled={createMutation.isPending}>
               <Save className="h-4 w-4 mr-2" />
               {createMutation.isPending ? "Création..." : "Créer la session"}
             </Button>
             <Button
               type="button"
               variant="outline"
               onClick={() => navigate("/sessions")}
               disabled={createMutation.isPending}
             >
               Annuler
             </Button>
           </div>
         </form>

         {/* Upgrade Modal */}
         {showUpgradeModal && (
           <UpgradeModal
             limitType="sessions"
             currentPlan={subscription?.subscriptionTier || "trial"}
             onClose={() => setShowUpgradeModal(false)}
           />
         )}
       </div>
     </div>
   );
   ```

4. **Remove all inline form inputs** (lines 114-302 in current file - replaced by SessionEditForm)

5. **Remove unused imports:** Card, CardContent, CardDescription, CardHeader, CardTitle, Input, Label, Textarea, Select components (now handled by SessionEditForm)

**Result:** SessionCreate.tsx reduces from ~317 lines to ~150 lines, reuses SessionEditForm component

**Benefits:**
- DRY principle (single form component for create + edit)
- Consistency (same UI for creation and editing)
- Maintainability (form changes only in SessionEditForm.tsx)
- Ready for future SessionDetail edit mode integration
  </action>
  <verify>
1. Navigate to /sessions/new
2. SessionEditForm renders with 4 accordions
3. Fill form fields (title, clientId, roomId, startTime, endTime required)
4. Select components populate with clients, rooms, projects
5. Click "Créer la session" - createMutation fires
6. Validation works (toast errors for missing required fields)
7. Successful creation redirects to session detail page
8. TypeScript 0 errors
  </verify>
  <done>
- SessionCreate.tsx refactored to use SessionEditForm
- Page simplified to ~150 lines (from ~317)
- Reusable form component for create + edit
- Submit button with validation
- Upgrade modal preserved
- TypeScript compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 3: Build, verify, and commit harmonization</name>
  <files>packages/client/src/components/SessionEditForm.tsx, packages/client/src/pages/SessionCreate.tsx</files>
  <action>
**Final verification steps:**

1. **TypeScript check:**
   ```bash
   pnpm --filter client check
   ```

2. **Build test:**
   ```bash
   pnpm --filter client build
   ```

3. **Test complete workflow:**
   - Visit /sessions/new → create session with SessionEditForm
   - Fill all required fields (title, client, room, startTime, endTime)
   - Optional: fill payment fields, notes, project association
   - Submit form → verify mutation fires
   - Verify redirect to session detail page

4. **Document completion in commit:**
   ```bash
   git add packages/client/src/components/SessionEditForm.tsx packages/client/src/pages/SessionCreate.tsx
   git commit -m "feat(33-01): create SessionEditForm with accordion pattern

Phase 33: Sessions UI Harmonization
- Created SessionEditForm component (4 accordions: Informations, Planning, Facturation, Notes)
- Refactored SessionCreate.tsx to use SessionEditForm (~150 lines from ~317)
- Inline form replaced with reusable accordion component
- All accordions open by default (Alt+Click toggle all)
- localStorage persistence for accordion state
- Props for clients, rooms, projects arrays

Pattern reference: TalentEditForm (Phase 28-05), ClientEditForm (Phase 26)
Goal achieved: Sessions UI harmonized with Clients, Talents, Services

Phase 33 COMPLETE: Sessions creation now consistent with other major entities

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
   ```

**Success indicators:**
- ✓ Build successful (zero errors)
- ✓ TypeScript passes
- ✓ Create workflow functional
- ✓ Accordion pattern adopted
- ✓ Sessions harmonized with Clients/Talents patterns
- ✓ Phase 33 complete
  </action>
  <verify>
1. TypeScript check passes (0 errors)
2. Build completes successfully
3. No console errors in create workflow
4. All 4 accordions functional
5. Form state synchronization working
6. Select dropdowns populate correctly
7. Git commit created with Phase 33 completion message
  </verify>
  <done>
- TypeScript 0 errors confirmed
- Production build successful
- SessionEditForm harmonized with ClientEditForm/TalentEditForm patterns
- Inline form eliminated (accordion pattern adopted)
- Phase 33 complete
- Sessions UI harmonized with all major entities (Clients, Talents, Services)
  </done>
</task>

</tasks>

<verification>
**Phase 33 Complete Verification:**

1. **SessionEditForm component:**
   - [x] 4 accordions (Informations, Planning, Facturation, Notes)
   - [x] All open by default
   - [x] localStorage persistence (sessionEditAccordions key)
   - [x] Alt+Click toggle all feature
   - [x] Props for clients, rooms, projects arrays
   - [x] TypeScript 0 errors

2. **SessionCreate page:**
   - [x] Uses SessionEditForm component
   - [x] Simplified to ~150 lines (from ~317)
   - [x] Reusable form pattern
   - [x] Submit validation preserved
   - [x] Upgrade modal preserved
   - [x] TypeScript 0 errors

3. **Harmonization achieved:**
   - [x] Sessions matches Clients pattern (Phase 26)
   - [x] Sessions matches Talents pattern (Phase 28)
   - [x] Inline form eliminated
   - [x] Accordion pattern adopted
   - [x] Consistent UX across all major entities
</verification>

<success_criteria>
- [ ] SessionEditForm component created with 4 accordions
- [ ] All accordions open by default with localStorage persistence
- [ ] Alt+Click toggles all accordions
- [ ] SessionCreate.tsx refactored to use SessionEditForm (~150 lines)
- [ ] Inline form pattern eliminated from creation flow
- [ ] Props system for clients, rooms, projects arrays
- [ ] TypeScript 0 errors
- [ ] Client builds successfully
- [ ] Create workflow functional
- [ ] Phase 33 complete: Sessions harmonized with Clients/Talents/Services
</success_criteria>

<output>
After completion, create `.planning/phases/33-harmonisation-sessions---routing-cohérent/33-01-SUMMARY.md`
</output>
