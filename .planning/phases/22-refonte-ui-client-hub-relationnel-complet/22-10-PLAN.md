---
phase: 22-refonte-ui-client-hub-relationnel-complet
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/routers/clients.ts
  - packages/client/src/pages/Clients.tsx
autonomous: true

must_haves:
  truths:
    - Single search input replaces separate genre/instrument filters
    - Searching "basse reggae" finds clients with instruments:basse AND genres:reggae
    - Searching "marie guitare" finds clients with name:marie AND instruments:guitare
    - Search works across name, email, company, genres, instruments fields
    - Debounced input avoids excessive API calls
    - Clear button visible when search active
  artifacts:
    - path: packages/server/src/routers/clients.ts
      provides: Backend unified search parsing and filtering
      contains: "searchQuery string parsing"
      min_lines: 40
    - path: packages/client/src/pages/Clients.tsx
      provides: Frontend unified search input with debounce
      contains: "unified search input"
      min_lines: 20
  key_links:
    - from: packages/client/src/pages/Clients.tsx
      to: trpc.clients.list
      via: "searchQuery parameter"
      pattern: "searchQuery.*useState"
    - from: packages/server/src/routers/clients.ts
      to: PostgreSQL ILIKE
      via: "multi-field search query"
      pattern: "ILIKE.*searchQuery"
---

<objective>
Replace separate genre/instrument filters with unified search input on Clients page.

Purpose: Simplify client search UX - single input replaces 3 separate filters, enabling natural language queries like "basse et reggae" or "marie guitare"

Output: Unified search input that searches across name, email, company, genres, instruments with debounce and clear button
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current Clients List Implementation
@packages/client/src/pages/Clients.tsx
# Lines 127-128: Separate genre/instrument filters
# Lines 481-514: Filter UI with 2 separate inputs

# Backend Endpoint
@packages/server/src/routers/clients.ts
# Lines 30-107: clients.list procedure with genre/instrument filters
# Lines 78-96: Conditional filter logic

# Phase 22 Complete
Phase 22 (9/9 plans) just completed comprehensive client UI refactoring:
- ClientFormWizard (3-step wizard)
- ClientDetail (5 tabs + relational data)
- Preferences backend + customization UI

# Current Search Pattern
Users must use 3 separate inputs:
1. Search by name/email (line 469)
2. Filter by genre (line 481)
3. Filter by instrument (line 490)

# Desired Pattern
Single unified search:
- "basse reggae" → finds clients with both
- "marie" → finds in name/email/company
- "guitare rock" → finds instruments AND genre
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend Unified Search Endpoint</name>
  <files>packages/server/src/routers/clients.ts</files>
  <action>
Modify clients.list procedure input schema and query logic:

1. **Update input schema (lines 28-37):**
   - Replace separate `genre` and `instrument` fields with single `searchQuery` field
   - Input: `searchQuery: z.string().optional()`
   - Remove: `genre: z.string().optional()` and `instrument: z.string().optional()`

2. **Parse search query (after line 41):**
   ```typescript
   const { limit = 50, offset = 0, searchQuery } = input || {};

   // Split searchQuery into keywords (space-separated)
   const keywords = searchQuery
     ? searchQuery.trim().toLowerCase().split(/\s+/).filter(k => k.length > 0)
     : [];
   ```

3. **Update WHERE conditions (lines 75-100):**
   - Remove genre and instrument specific filters
   - Add unified keyword search across multiple fields:
   ```typescript
   // For each keyword, search in ALL fields (OR logic between fields, AND logic between keywords)
   if (keywords.length > 0) {
     const keywordConditions = keywords.map(keyword =>
       sql`(
         ${clients.name} ILIKE ${`%${keyword}%`} OR
         ${clients.email} ILIKE ${`%${keyword}%`} OR
         ${clients.artistName} ILIKE ${`%${keyword}%`} OR
         ${clients.genres}::text ILIKE ${`%${keyword}%`} OR
         ${clients.instruments}::text ILIKE ${`%${keyword}%`}
       )`
     );
     conditions.push(sql.join(keywordConditions, sql` AND `));
   }
   ```

4. **Why this approach:**
   - Multiple keywords = AND logic (all must match)
   - Within each keyword = OR logic (match ANY field)
   - JSONB cast to text allows ILIKE on array contents
   - Case-insensitive via ILIKE
   - Partial matches via `%keyword%` pattern

5. **Example queries:**
   - "basse" → finds clients with "basse" in instruments
   - "basse reggae" → finds clients with BOTH "basse" (instruments) AND "reggae" (genres)
   - "marie" → finds "marie" in name/email/artistName
   - "marie guitare" → finds clients named "marie" with "guitare" instrument
  </action>
  <verify>
Backend builds successfully:
```bash
cd packages/server
pnpm tsc --noEmit
```

Zero TypeScript errors. Input schema updated, keyword parsing logic added, WHERE conditions modified.
  </verify>
  <done>
Backend accepts `searchQuery` parameter, parses keywords, searches across 5 fields (name/email/artistName/genres/instruments) with AND logic between keywords and OR logic within each keyword.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend Unified Search Input</name>
  <files>packages/client/src/pages/Clients.tsx</files>
  <action>
Replace separate filters with single debounced search input:

1. **Remove separate filter states (lines 127-128):**
   ```typescript
   // DELETE these lines:
   const [genreFilter, setGenreFilter] = useState<string>("");
   const [instrumentFilter, setInstrumentFilter] = useState<string>("");
   ```

2. **Update tRPC query (lines 135-139):**
   ```typescript
   const { data: clients, isLoading: clientsLoading, refetch } = trpc.clients.list.useQuery({
     limit: 100,
     searchQuery: searchQuery || undefined, // Replace genre/instrument
   });
   ```

3. **Add debounced search (after useState declarations):**
   ```typescript
   import { useMemo } from "react"; // Add to imports if not present

   // Debounce searchQuery (300ms delay)
   const [debouncedSearch, setDebouncedSearch] = useState("");

   useEffect(() => {
     const timer = setTimeout(() => {
       setDebouncedSearch(searchQuery);
     }, 300);
     return () => clearTimeout(timer);
   }, [searchQuery]);
   ```

4. **Update search placeholder (line 472):**
   ```typescript
   <Input
     placeholder="Rechercher par nom, instrument, genre, email..."
     value={searchQuery}
     onChange={(e) => setSearchQuery(e.target.value)}
     className="pl-9"
   />
   ```

5. **Remove genre/instrument filter inputs (lines 480-514):**
   - DELETE entire Genre Filter div (lines 481-488)
   - DELETE entire Instrument Filter div (lines 490-498)
   - DELETE Clear Filters button section (lines 501-514)

6. **Add clear button INSIDE search input (after line 477):**
   ```typescript
   <div className="relative flex-1">
     <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
     <Input
       placeholder="Rechercher par nom, instrument, genre, email..."
       value={searchQuery}
       onChange={(e) => setSearchQuery(e.target.value)}
       className="pl-9 pr-9"
     />
     {searchQuery && (
       <Button
         variant="ghost"
         size="icon"
         className="absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7"
         onClick={() => setSearchQuery("")}
       >
         <X className="h-3 w-3" />
       </Button>
     )}
   </div>
   ```

7. **Import X icon (line 30):**
   Add `X` to Lucide imports: `import { ..., X } from "lucide-react";`

8. **Update filteredClients memo (lines 227-291):**
   - Remove genre/instrument client-side filtering logic
   - Backend now handles all filtering via searchQuery
   - Keep only the useMemo with searchQuery dependency removed (backend filters)

9. **Why debounce:**
   - Prevents API call on every keystroke
   - 300ms delay = good UX balance
   - Reduces server load by ~90%
  </action>
  <verify>
Frontend builds successfully:
```bash
cd packages/client
pnpm build
```

Zero TypeScript errors. Search input renders with clear button, debounce implemented, separate filters removed.

Manual test:
1. Navigate to /clients page
2. Type "basse" → see clients with instrument:basse
3. Type "basse reggae" → see ONLY clients with BOTH
4. Type "marie" → see clients with name containing "marie"
5. Clear button appears when typing, clears on click
  </verify>
  <done>
Single search input replaces 3 separate filters. Debounced 300ms. Clear button visible when search active. Searches across name, email, artistName, genres, instruments with multi-keyword AND logic.
  </done>
</task>

</tasks>

<verification>
1. **Backend verification:**
   - `pnpm tsc --noEmit` in packages/server (0 errors)
   - Input schema has `searchQuery: z.string().optional()`
   - Keyword parsing logic splits on whitespace
   - WHERE clause searches 5 fields with ILIKE

2. **Frontend verification:**
   - `pnpm build` in packages/client (0 errors)
   - Single search input rendered
   - Debounce implemented (300ms)
   - Clear button appears when searchQuery not empty
   - Separate genre/instrument inputs removed

3. **Integration test:**
   ```bash
   # Start dev servers
   ./start.sh

   # Navigate to http://localhost:5174/clients
   # Test queries:
   # - "basse" → finds instrument matches
   # - "basse reggae" → finds BOTH criteria
   # - "marie guitare" → finds name AND instrument
   # - Clear button works
   ```

4. **Must-haves verification:**
   - ✅ Single search input replaces filters
   - ✅ Multi-keyword search (AND logic)
   - ✅ Searches 5 fields (name/email/artistName/genres/instruments)
   - ✅ Debounced to avoid performance issues
   - ✅ Clear button visible when active
</verification>

<success_criteria>
- Backend accepts `searchQuery` parameter and parses keywords
- Frontend has single search input with debounce (300ms)
- Search works across 5 fields: name, email, artistName, genres, instruments
- Multi-keyword queries use AND logic ("basse reggae" finds BOTH)
- Clear button appears when search active and clears input on click
- Zero TypeScript errors in both packages
- Separate genre/instrument filter inputs removed
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/22-refonte-ui-client-hub-relationnel-complet/22-10-SUMMARY.md`
</output>
