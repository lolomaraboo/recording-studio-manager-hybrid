---
phase: 22-refonte-ui-client-hub-relationnel-complet
plan: 03
type: execute
wave: 3
depends_on: [22-01, 22-02]
files_modified:
  - packages/client/src/pages/ClientDetail.tsx
autonomous: true

must_haves:
  truths:
    - "ClientDetail edit mode uses ClientFormSections component"
    - "Edit mode preserves all existing client data including music fields"
    - "Inline editing works with validation and error display"
    - "Cancel button restores original values"
  artifacts:
    - path: "packages/client/src/pages/ClientDetail.tsx"
      provides: "Edit mode using ClientFormSections"
      contains: "ClientFormSections"
      min_lines: 650
  key_links:
    - from: "ClientDetail.tsx edit mode"
      to: "ClientFormSections.tsx"
      via: "import and render in edit mode"
      pattern: "isEditing.*ClientFormSections"
    - from: "ClientDetail.tsx"
      to: "clients.update mutation"
      via: "save button submits formData"
      pattern: "updateMutation\\.mutate"
---

<objective>
Refactor ClientDetail edit mode to use ClientFormSections component for consistent form UI

Purpose: Eliminate duplicated form JSX between creation and edit pages, provide better organized editing experience for 22+ music fields

Output: ClientDetail.tsx edit mode using ClientFormSections with proper data hydration and save/cancel logic
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-refonte-ui-client-hub-relationnel-complet/22-01-SUMMARY.md
@packages/client/src/pages/ClientDetail.tsx
@packages/client/src/components/ClientFormSections.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit mode state management to ClientDetail</name>
  <files>packages/client/src/pages/ClientDetail.tsx</files>
  <action>
Update ClientDetail.tsx to support edit mode with ClientFormSections:

**Current edit mode:** Uses inline Input/Textarea fields scattered throughout tabs (lines ~150-400)

**Add state for edit mode:**
```typescript
// Near top of component (after existing useState declarations)
const [editFormData, setEditFormData] = useState<any>(null);
const [editPhones, setEditPhones] = useState<Array<{ type: string; number: string }>>([]);
const [editEmails, setEditEmails] = useState<Array<{ type: string; email: string }>>([]);
const [editWebsites, setEditWebsites] = useState<Array<{ type: string; url: string }>>([]);
const [editCustomFields, setEditCustomFields] = useState<Array<{ label: string; value: any }>>([]);

// Hydrate form data when entering edit mode
const toggleEditMode = (editing: boolean) => {
  if (editing && client) {
    // Hydrate form data from current client
    setEditFormData({
      name: client.name || "",
      type: client.type || "individual",
      firstName: client.firstName || "",
      lastName: client.lastName || "",
      middleName: client.middleName || "",
      prefix: client.prefix || "",
      suffix: client.suffix || "",
      artistName: client.artistName || "",
      email: client.email || "",
      phone: client.phone || "",
      street: client.street || "",
      city: client.city || "",
      postalCode: client.postalCode || "",
      region: client.region || "",
      country: client.country || "",
      birthday: client.birthday || "",
      gender: client.gender || "",
      notes: client.notes || "",
      avatarUrl: client.avatarUrl || "",
      logoUrl: client.logoUrl || "",

      // Music fields (22 fields from Phase 18.4)
      genres: client.genres || [],
      instruments: client.instruments || [],
      vocalRange: client.vocalRange || "",
      skillLevel: client.skillLevel || "",
      spotifyUrl: client.spotifyUrl || "",
      appleMusicUrl: client.appleMusicUrl || "",
      youtubeUrl: client.youtubeUrl || "",
      soundcloudUrl: client.soundcloudUrl || "",
      bandcampUrl: client.bandcampUrl || "",
      deezerUrl: client.deezerUrl || "",
      tidalUrl: client.tidalUrl || "",
      amazonMusicUrl: client.amazonMusicUrl || "",
      napsterUrl: client.napsterUrl || "",
      qobuzUrl: client.qobuzUrl || "",
      customStreamingUrl: client.customStreamingUrl || "",
      label: client.label || "",
      distributor: client.distributor || "",
      manager: client.manager || "",
      publisher: client.publisher || "",
      performanceRightsSociety: client.performanceRightsSociety || "",
      yearsActive: client.yearsActive || "",
      majorReleases: client.majorReleases || "",
      awardsRecognition: client.awardsRecognition || "",
    });

    // Hydrate arrays (phones, emails, websites, customFields)
    setEditPhones(client.phones || []);
    setEditEmails(client.emails || []);
    setEditWebsites(client.websites || []);
    setEditCustomFields(client.customFields || []);
  } else {
    // Clear form data on cancel
    setEditFormData(null);
    setEditPhones([]);
    setEditEmails([]);
    setEditWebsites([]);
    setEditCustomFields([]);
  }

  setIsEditing(editing);
  if (editing) {
    searchParams.set('edit', 'true');
  } else {
    searchParams.delete('edit');
  }
  setSearchParams(searchParams);
};
```

**Why data hydration:** Edit mode must preserve all existing client data (60+ fields including music profile). Hydrating from client object ensures nothing lost when entering edit mode.
  </action>
  <verify>
```bash
# TypeScript compilation passes
cd packages/client && npx tsc --noEmit

# State hydration works:
# 1. Navigate to client with music data
# 2. Click Edit button
# 3. Verify editFormData contains all client fields
# 4. Verify editPhones/editEmails arrays populated
# 5. Click Cancel → state cleared
```
  </verify>
  <done>Edit mode state management added with proper data hydration from client object, cancel clears state, TypeScript passes</done>
</task>

<task type="auto">
  <name>Task 2: Replace edit mode JSX with ClientFormSections</name>
  <files>packages/client/src/pages/ClientDetail.tsx</files>
  <action>
Replace inline edit fields in ClientDetail with ClientFormSections component:

**Current edit mode:** Scattered Input/Textarea fields across multiple TabsContent sections (~250 lines of JSX)

**Replace with:**
```tsx
{/* In the main render, conditionally show edit form or view mode */}
{isEditing && editFormData ? (
  <Card className="pb-3">
    <CardHeader>
      <CardTitle className="text-base">Mode Édition</CardTitle>
      <CardDescription>Modifier les informations du client</CardDescription>
    </CardHeader>
    <CardContent>
      <ClientFormSections
        formData={editFormData}
        setFormData={setEditFormData}
        phones={editPhones}
        setPhones={setEditPhones}
        emails={editEmails}
        setEmails={setEditEmails}
        websites={editWebsites}
        setWebsites={setEditWebsites}
        customFields={editCustomFields}
        setCustomFields={setEditCustomFields}
        errors={{}} // TODO: Add validation errors
      />

      <div className="mt-6 flex gap-2">
        <Button onClick={handleSave}>
          <Save className="h-4 w-4 mr-2" />
          Enregistrer
        </Button>
        <Button variant="outline" onClick={() => toggleEditMode(false)}>
          <X className="h-4 w-4 mr-2" />
          Annuler
        </Button>
      </div>
    </CardContent>
  </Card>
) : (
  // Existing tabs for view mode (Informations, Projects, Tracks, etc.)
  <Tabs defaultValue="info">
    {/* ... existing tabs JSX ... */}
  </Tabs>
)}
```

**Remove from view mode:**
- Delete all inline `<Input>` fields wrapped in `isEditing` conditionals
- Delete inline save/cancel buttons scattered in tabs
- Keep only read-only display elements in TabsContent sections

**Add handleSave function:**
```typescript
const handleSave = () => {
  if (!editFormData) return;

  updateMutation.mutate({
    id: Number(id),
    // Spread all form data
    ...editFormData,
    // Include arrays
    phones: editPhones,
    emails: editEmails,
    websites: editWebsites,
    customFields: editCustomFields,
  });
};
```

**Why complete replacement:** Mixing inline edit fields with view mode creates 500+ lines of conditional JSX. Single edit mode card with ClientFormSections = cleaner, more maintainable, consistent with creation page.
  </action>
  <verify>
```bash
# Build passes
cd packages/client && pnpm build

# Edit mode works:
# 1. Navigate to client detail
# 2. Click Edit button → ClientFormSections appears
# 3. All sections visible (Identité, Contact, Profil Musical, etc.)
# 4. Form fields populated with existing client data
# 5. Modify a field (e.g., firstName)
# 6. Click Enregistrer → mutation called with updated data
# 7. Click Annuler → form closes, view mode restored
```
  </verify>
  <done>ClientDetail edit mode refactored to use ClientFormSections, ~250 lines of inline edit JSX removed, save/cancel logic works, build passes</done>
</task>

<task type="auto">
  <name>Task 3: Ensure clients.update mutation accepts music fields</name>
  <files>packages/server/src/routers/clients.ts</files>
  <action>
Verify and update clients.update mutation to accept all 22 music profile fields:

**Check existing mutation schema:**
```typescript
// packages/server/src/routers/clients.ts
update: protectedProcedure
  .input(z.object({
    id: z.number(),
    // ... existing fields ...
  }))
  .mutation(async ({ ctx, input }) => { ... })
```

**Ensure input schema includes:**
```typescript
update: protectedProcedure
  .input(z.object({
    id: z.number(),
    // Basic fields (existing)
    name: z.string().optional(),
    type: z.enum(["individual", "company"]).optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    // ... other existing fields ...

    // Music profile fields (ADD IF MISSING)
    genres: z.array(z.string()).optional(),
    instruments: z.array(z.string()).optional(),
    vocalRange: z.string().optional().nullable(),
    skillLevel: z.string().optional().nullable(),

    // Streaming platforms (11 fields)
    spotifyUrl: z.string().optional().nullable(),
    appleMusicUrl: z.string().optional().nullable(),
    youtubeUrl: z.string().optional().nullable(),
    soundcloudUrl: z.string().optional().nullable(),
    bandcampUrl: z.string().optional().nullable(),
    deezerUrl: z.string().optional().nullable(),
    tidalUrl: z.string().optional().nullable(),
    amazonMusicUrl: z.string().optional().nullable(),
    napsterUrl: z.string().optional().nullable(),
    qobuzUrl: z.string().optional().nullable(),
    customStreamingUrl: z.string().optional().nullable(),

    // Industry contacts (5 fields)
    label: z.string().optional().nullable(),
    distributor: z.string().optional().nullable(),
    manager: z.string().optional().nullable(),
    publisher: z.string().optional().nullable(),
    performanceRightsSociety: z.string().optional().nullable(),

    // Career info (3 fields)
    yearsActive: z.string().optional().nullable(),
    majorReleases: z.string().optional().nullable(),
    awardsRecognition: z.string().optional().nullable(),
  }))
  .mutation(async ({ ctx, input }) => {
    const tenantDb = await ctx.getTenantDb();
    const { id, ...updateData } = input;

    await tenantDb.update(clients)
      .set(updateData) // All fields passed through
      .where(eq(clients.id, id));

    return { success: true };
  }),
```

**Why explicit schema:** Without music fields in input schema, Zod validation will strip them from mutation payload even if frontend sends them. Must explicitly declare all 22 fields as optional to support partial updates.

**If music fields already present:** Skip this task, mutation already supports music profile.
  </action>
  <verify>
```bash
# TypeScript compilation passes
cd packages/server && npx tsc --noEmit

# Test mutation with music fields:
# 1. Edit client in UI
# 2. Modify genres to ["Jazz", "Blues"]
# 3. Modify spotifyUrl to "https://spotify.com/artist/test"
# 4. Click Enregistrer
# 5. Backend logs should show mutation received genres and spotifyUrl
# 6. Database should persist changes:
psql -d tenant_1 -c "SELECT genres, spotify_url FROM clients WHERE id = 1;"
```
  </verify>
  <done>clients.update mutation schema includes all 22 music fields, accepts partial updates, validation passes, music data persists correctly</done>
</task>

</tasks>

<verification>
**Functional checks:**
- [ ] Edit button on ClientDetail enters edit mode
- [ ] ClientFormSections renders with all client data hydrated
- [ ] All 5 sections visible (Identité, Contact, Profil Musical, Adresse, Additionnelles)
- [ ] Modifying fields updates editFormData state
- [ ] Save button calls updateMutation with all fields including music
- [ ] Cancel button exits edit mode and clears form state
- [ ] Updated data persists to database and displays in view mode

**Code quality:**
- [ ] TypeScript compilation passes with 0 errors
- [ ] Client and server packages build successfully
- [ ] No console errors during edit workflow
- [ ] Removed ~250 lines of duplicated inline edit JSX

**Regression testing:**
- [ ] View mode still displays all client information correctly
- [ ] Tabs (Projects, Tracks, Finances) still work after edit mode refactor
- [ ] EnrichedClientInfo and MusicProfileSection components still work
- [ ] Updating non-music fields still works (name, email, phone)
</verification>

<success_criteria>
- ClientDetail edit mode uses ClientFormSections component
- Edit form hydrates with all existing client data (60+ fields)
- Save button persists changes including music profile
- Cancel button restores view mode without saving
- ~250 lines of duplicated edit JSX removed
- Build passes, TypeScript has 0 errors
- Zero regressions on existing ClientDetail functionality
</success_criteria>

<output>
After completion, create `.planning/phases/22-refonte-ui-client-hub-relationnel-complet/22-03-SUMMARY.md`
</output>
