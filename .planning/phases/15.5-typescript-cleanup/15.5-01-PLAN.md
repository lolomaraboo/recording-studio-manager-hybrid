---
phase: 15.5-typescript-cleanup
plan: 1
type: execute
---

<objective>
Corriger toutes les erreurs TypeScript (316 total: 44 server + 272 client) avant Phase 16.

Purpose: Rétablir type safety complet après migrations récentes (0007-trackId, 0008-projectId). Types Drizzle non synchronisés causent cascade d'erreurs.
Output: pnpm check = 0 erreurs, tous packages compilent proprement.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Diagnostic (2026-01-09):**
- Migrations 0007 (trackId) et 0008 (projectId) appliquées
- Types Drizzle pas régénérés → 316 erreurs TypeScript
- Server: 44 erreurs (schema incompatibilité, session types, imports)
- Client: 272 erreurs (types router obsolètes, arrays vs strings, undefined checks)

**Erreurs analysées:**
@/tmp/server-errors.txt (50 premières lignes)
@/tmp/client-errors.txt (disponible après rebuild)

**Catégories identifiées:**

**Server (44 erreurs):**
1. P0 - Schema Drizzle incompatibilité (~15):
   - aiActions.ts: 'where' missing in queries (lignes 259, 393, 668, 816, 1153)
   - aiActions.ts: 'validUntil', 'convertedToInvoiceId' n'existent pas (lignes 854, 955)
   - timer-service.ts: 'trackId' n'existe pas (lignes 102, 119, 227, 367)

2. P0 - Session types manquants (~6):
   - index.ts: userId, organizationId manquants (lignes 232, 236, 237)
   - notifications.ts: session manquant dans context (lignes 146, 164)

3. P1 - Schema fields manquants (~8):
   - auth.ts: Organizations schema incomplet (ligne 184)
   - client-portal-dashboard.ts: 'title' n'existe pas (ligne 573)
   - QuoteDetail.tsx: 'title', 'issueDate', 'validUntil' manquants (lignes 156-159)

4. P1 - Type conversions number vs string (~5):
   - rooms.ts: hourlyRate number → string (ligne 114)
   - client-portal-booking.ts: sessionId type incompatible (ligne 797)

5. P2 - Imports/modules manquants (~6):
   - tenantFileAccess.ts: '../lib/session' introuvable (ligne 2)
   - llmProvider.ts: 'function' n'existe pas (lignes 207, 208)

**Client (272 erreurs):**
1. Arrays vs strings (phones/emails) - ~40 erreurs:
   - Clients.tsx: 'phones' n'existe pas, utilise 'phone' (lignes 427, 514, 590)
   - Même problème avec 'emails' → 'email'

2. Undefined checks manquants - ~80 erreurs:
   - BookingDetail.tsx: 'booking' possibly undefined (30+ occurrences)
   - ClientDashboard.tsx: 'invoice.date' undefined (ligne 287)

3. Type mismatch - ~60 erreurs:
   - Projects.tsx: 'credits', 'milestones', 'files' manquants (lignes 500-502, 594, 630, 673)
   - QuoteCreate.tsx: toFixed sur string (lignes 349, 550)

4. Variables non utilisées (TS6133) - ~20 erreurs:
   - AIAssistant.tsx: startNewConversation (ligne 264)
   - EnrichedClientInfo.tsx: avatarFile, setAvatarFile, etc. (lignes 79-176)

5. Schema type incompatibilité - ~70 erreurs:
   - Enum types strict ('string' → literal types)
   - Champs optionnels vs required
</context>

<tasks>

<task type="auto">
  <name>Task 1: Régénérer types Drizzle + rebuild database package</name>
  <files>packages/database/</files>
  <action>
**Étape 1: Nettoyer et régénérer types Drizzle**

1. Supprimer dist/ pour forcer rebuild complet:
   ```bash
   rm -rf packages/database/dist
   ```

2. Rebuild database package (génère types TypeScript):
   ```bash
   cd packages/database
   pnpm build
   ```

3. Vérifier que les types incluent trackId et projectId:
   ```bash
   grep -n "trackId" packages/database/dist/tenant/schema.d.ts
   grep -n "projectId.*sessions" packages/database/dist/tenant/schema.d.ts
   ```

4. Si types manquent, générer migration Drizzle:
   ```bash
   cd packages/database
   pnpm db:generate
   # Répondre aux prompts selon migrations existantes
   ```

**Étape 2: Rebuild shared pour propager types**

```bash
rm -rf packages/shared/dist
cd packages/shared
pnpm build
```

**Validation:**
- `packages/database/dist/tenant/schema.d.ts` contient `trackId: number | null`
- `packages/database/dist/tenant/schema.d.ts` contient `projectId: number | null` dans sessions
- Aucune erreur de build dans database package

**Ce qu'il NE FAUT PAS faire:**
- Ne pas modifier manuellement les fichiers .d.ts (auto-générés)
- Ne pas créer de nouvelles migrations (0007 et 0008 existent déjà)
  </action>
  <verify>
1. `pnpm --filter database build` réussit (0 erreurs)
2. `pnpm --filter shared build` réussit (0 erreurs)
3. Types trackId et projectId présents dans schema.d.ts
  </verify>
  <done>
Types Drizzle régénérés, trackId et projectId disponibles pour server/client.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fixer erreurs critiques server - Schema Drizzle</name>
  <files>packages/server/src/lib/aiActions.ts, packages/server/src/services/timer-service.ts</files>
  <action>
**Fixer aiActions.ts - Queries Drizzle incomplètes**

Problème: Queries manquent `.where()` (lignes 259, 393, 668, 816, 1153)

Exemple ligne 259:
```typescript
// ❌ Avant
const session = await tenantDb.query.sessions.findFirst({ id: sessionId });

// ✅ Après
const session = await tenantDb.query.sessions.findFirst({
  where: (sessions, { eq }) => eq(sessions.id, sessionId)
});
```

Appliquer ce pattern pour toutes les queries manquant `.where()`:
- Line 259: sessions.findFirst
- Line 393: clients.findFirst
- Line 668: invoices.findFirst
- Line 816: quotes.findFirst
- Line 1153: projects.findFirst

**Fixer aiActions.ts - Champs quotes obsolètes**

Problème: 'validUntil', 'convertedToInvoiceId' n'existent plus (lignes 854, 955)

Ligne 854 - Supprimer champs obsolètes:
```typescript
// ❌ Avant
await tenantDb.insert(quotes).values({
  validUntil: ...,
  convertedToInvoiceId: ...,
  // ...autres champs
})

// ✅ Après
await tenantDb.insert(quotes).values({
  expiresAt: ...,  // Remplace validUntil
  // convertedToInvoiceId supprimé (pas dans schema)
  // ...autres champs
})
```

Ligne 955 - Même correction pour update().set()

**Fixer timer-service.ts - trackId manquant**

Problème: trackId utilisé mais types Drizzle obsolètes (lignes 102, 119, 227, 367)

Après Task 1 (rebuild), trackId devrait être disponible. Si erreurs persistent:

```typescript
// Vérifier que timeEntries schema inclut trackId
import { timeEntries } from '@rsm/database/tenant';

// Usage devrait fonctionner maintenant
await tenantDb.query.timeEntries.findMany({
  where: (entries, { eq }) => eq(entries.trackId, trackId)
});
```

**Ce qu'il NE FAUT PAS faire:**
- Ne pas inventer de champs inexistants dans schema
- Ne pas utiliser any ou @ts-ignore
  </action>
  <verify>
1. Grep "error TS2741.*where" dans server build → 0 résultats
2. Grep "validUntil\|convertedToInvoiceId" dans aiActions.ts → 0 résultats
3. Grep "error.*trackId" dans timer-service.ts → 0 résultats
  </verify>
  <done>
Schema Drizzle queries corrigées, champs obsolètes supprimés, trackId supporté.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fixer erreurs critiques server - Session types</name>
  <files>packages/server/src/index.ts, packages/server/src/routers/notifications.ts</files>
  <action>
**Problème: Session types manquent userId/organizationId**

Lignes 232, 236, 237 dans index.ts:
```typescript
// ❌ Avant
req.session.userId
req.session.organizationId

// ✅ Après - Ajouter types à SessionData
declare module 'express-session' {
  interface SessionData {
    userId?: number;
    organizationId?: number;
  }
}
```

Ajouter cette déclaration en haut de index.ts après les imports.

**Notifications.ts - Context session manquant**

Lignes 146, 164:
```typescript
// ❌ Avant (ctx.session n'existe pas dans type Context)
const userId = ctx.session.userId;

// ✅ Après (utiliser ctx.req.session)
const userId = ctx.req.session.userId;
```

**Ce qu'il NE FAUT PAS faire:**
- Ne pas modifier @types/express-session directement
- Utiliser module augmentation (declare module)
  </action>
  <verify>
1. Grep "error TS2339.*userId.*Session" dans index.ts → 0 résultats
2. Grep "error TS2339.*session.*Context" dans notifications.ts → 0 résultats
3. Server compile sans erreurs session types
  </verify>
  <done>
Session types augmentés avec userId/organizationId, notifications.ts utilise ctx.req.session.
  </done>
</task>

<task type="auto">
  <name>Task 4: Fixer erreurs server restantes (P1/P2)</name>
  <files>packages/server/src/routers/*.ts, packages/server/src/middleware/*.ts</files>
  <action>
**Auth.ts - Organizations schema incomplet (ligne 184)**

```typescript
// ❌ Avant (manque 15 champs)
const orgs = await masterDb.query.organizations.findMany();

// ✅ Après (select explicite ou accepter tous les champs)
const orgs = await masterDb.query.organizations.findMany({
  columns: {
    id: true,
    name: true,
    slug: true,
    subdomain: true,
    ownerId: true,
    // ... liste tous les champs requis
  }
});
```

**OU** vérifier que le schema organizations dans master/schema.ts a tous les champs attendus.

**TenantFileAccess.ts - Module '../lib/session' introuvable**

```typescript
// ❌ Avant
import { getSessionFromRequest } from '../lib/session';

// ✅ Après (utiliser req.session directement)
// Supprimer import
// Dans le code:
const userId = req.session?.userId;
const organizationId = req.session?.organizationId;
```

**Rooms.ts - Type conversion hourlyRate**

Ligne 114:
```typescript
// ❌ Avant
hourlyRate: number

// ✅ Après (schema Drizzle utilise decimal → string)
hourlyRate: hourlyRate.toString()
```

**LlmProvider.ts - Property 'function' manquant**

Lignes 207-208:
```typescript
// ❌ Avant
toolCall.function.name
toolCall.function.arguments

// ✅ Après (vérifier type ChatCompletionMessageToolCall)
if ('function' in toolCall) {
  toolCall.function.name
  toolCall.function.arguments
}
```

**Health.ts - Property '$client' manquant**

Lignes 35, 103:
```typescript
// ❌ Avant
masterDb.$client.connect()

// ✅ Après (postgres.js driver)
// $client n'existe pas, utiliser query direct pour health check
await masterDb.execute(sql`SELECT 1`);
```

**Ce qu'il NE FAUT PAS faire:**
- Ne pas ignorer erreurs avec @ts-ignore
- Fixer correctement les types
  </action>
  <verify>
1. `pnpm --filter server tsc --noEmit` → compter erreurs restantes
2. Moins de 10 erreurs server restantes
  </verify>
  <done>
Erreurs P1/P2 server corrigées, imports résolus, types convertis proprement.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Erreurs server corrigées - validation avant client</what-built>
  <how-to-verify>
1. Exécuter: `cd /Users/marabook_m1/Documents/APP_HOME/CascadeProjects/windsurf-project/recording-studio-manager-hybrid`
2. Run: `pnpm --filter server tsc --noEmit 2>&1 | grep "error TS" | wc -l`
3. Vérifier: Devrait afficher un nombre ≤ 5 erreurs (cible: 0)
4. Si > 5 erreurs:
   - Lister: `pnpm --filter server tsc --noEmit 2>&1 | grep "error TS" | head -10`
   - Identifier patterns communs
   - Décider si bloquer ou continuer client
  </how-to-verify>
  <resume-signal>Type "approved" si ≤ 5 erreurs server, ou "block" si trop d'erreurs restent</resume-signal>
</task>

<task type="auto">
  <name>Task 5: Fixer erreurs client systématiques - Arrays vs strings</name>
  <files>packages/client/src/pages/Clients.tsx</files>
  <action>
**Problème: Backend retourne 'phone'/'email' (string) mais code utilise 'phones'/'emails' (arrays)**

Phase 3.9.4 a ajouté vCard support avec arrays, mais router clients.list ne retourne pas ces champs enrichis.

**Solution: Vérifier ce que clients.list retourne réellement**

Ligne 427-428, 514-515, 590-591:
```typescript
// ❌ Avant
client.phones?.[0]?.number || client.phones?.[0] || client.phones
client.emails?.[0]?.email || client.emails?.[0]

// ✅ Après (selon type réel du router)
// Option 1: Si router retourne phone/email (string)
client.phone || '—'
client.email || '—'

// Option 2: Si router retourne phones/emails (arrays)
client.phones?.[0]?.number || client.phones?.[0] || '—'
client.emails?.[0]?.email || client.emails?.[0] || '—'
```

**Vérifier dans packages/server/src/routers/clients.ts:**
- Quelle structure retourne clients.list ?
- Utilise-t-il getWithContacts (enriched) ou query simple ?

**Action:**
1. Grep "clients.list" dans routers/clients.ts
2. Si retourne client simple → Utiliser phone/email
3. Si retourne getWithContacts → Utiliser phones[]/emails[]

Appliquer cohérence dans tout Clients.tsx (lignes 427, 443, 514, 530, 590, 606).

**Ce qu'il NE FAUT PAS faire:**
- Ne pas mélanger les deux formats
- Vérifier le type retourné avant de corriger
  </action>
  <verify>
1. Grep "phones.*does not exist" dans client build → 0 résultats
2. Grep "emails.*does not exist" dans client build → 0 résultats
3. Clients.tsx compile sans erreurs phone/email
  </verify>
  <done>
Clients.tsx utilise correctement phone/email ou phones[]/emails[] selon type router.
  </done>
</task>

<task type="auto">
  <name>Task 6: Fixer erreurs client - Undefined checks</name>
  <files>packages/client/src/pages/client-portal/BookingDetail.tsx, packages/client/src/pages/ClientDetail.tsx</files>
  <action>
**BookingDetail.tsx - 'booking' possibly undefined (30+ erreurs)**

TypeScript strict mode détecte que booking peut être undefined après query.

```typescript
// ❌ Avant (ligne 184+)
booking.status
booking.sessionDate

// ✅ Après (ajouter guard en début de composant)
if (!booking) {
  return (
    <div className="container pt-6">
      <Card>
        <CardContent className="py-6">
          <p className="text-center text-muted-foreground">Réservation introuvable</p>
        </CardContent>
      </Card>
    </div>
  );
}

// Ensuite tout le code peut utiliser booking sans optional chaining
booking.status
booking.sessionDate
```

Ajouter ce guard après la query, avant le JSX.

**ClientDashboard.tsx - invoice.date undefined (ligne 287)**

```typescript
// ❌ Avant
invoice.date.toLocaleDateString()

// ✅ Après
invoice.date ? new Date(invoice.date).toLocaleDateString() : '—'
```

**ClientDetail.tsx - Multiple type errors (lignes 300, 511, 513, 514)**

Ligne 300: `Cannot find name 'Users'`
```typescript
// Import manquant
import { Users } from 'lucide-react';
```

Lignes 511-514: Type incompatibilités Client
```typescript
// Vérifier que le type Client matche avec ce qui est passé
// Ajouter les champs manquants ou utiliser Partial<Client>
```

**Ce qu'il NE FAUT PAS faire:**
- Ne pas utiliser `as any` ou `!` (non-null assertion)
- Ajouter checks propres
  </action>
  <verify>
1. Grep "possibly undefined" dans BookingDetail.tsx → 0 résultats
2. Grep "Cannot find name" dans ClientDetail.tsx → 0 résultats
3. Pages compilent sans erreurs undefined
  </verify>
  <done>
Guards undefined ajoutés, imports manquants corrigés, types Client cohérents.
  </done>
</task>

<task type="auto">
  <name>Task 7: Fixer erreurs client - Type mismatches</name>
  <files>packages/client/src/pages/Projects.tsx, packages/client/src/pages/QuoteCreate.tsx, packages/client/src/pages/QuoteDetail.tsx</files>
  <action>
**Projects.tsx - 'credits', 'milestones', 'files' manquants**

Lignes 500-502, 594, 630, 673:

Problème: Router projects.detail ne retourne pas ces champs enrichis.

```typescript
// ❌ Avant
project.credits
project.milestones
project.files

// ✅ Après (vérifier router projects.ts)
// Si champs existent dans query:
project.credits || []
project.milestones || []
project.files || []

// Si champs n'existent pas:
// Commenter/supprimer code utilisant ces champs
// OU ajouter requêtes séparées
```

**QuoteCreate.tsx / QuoteDetail.tsx - toFixed sur string**

Lignes 349, 550 (QuoteCreate), 156-159 (QuoteDetail):

```typescript
// ❌ Avant
subtotal.toFixed(2)  // subtotal = string (decimal Drizzle)

// ✅ Après
parseFloat(subtotal).toFixed(2)
```

**QuoteDetail.tsx - Champs manquants (title, issueDate, validUntil)**

Lignes 156-159:

```typescript
// ❌ Avant
quote.title
quote.issueDate
quote.validUntil

// ✅ Après (vérifier schema quotes)
quote.quoteNumber  // Remplace title ?
quote.createdAt    // Remplace issueDate ?
quote.expiresAt    // Remplace validUntil
```

**Ce qu'il NE FAUT PAS faire:**
- Ne pas inventer de champs inexistants
- Vérifier schema et adapter
  </action>
  <verify>
1. Grep "does not exist.*credits\|milestones\|files" → 0 résultats
2. Grep "toFixed.*string" → 0 résultats
3. Grep "title\|issueDate\|validUntil.*quotes" → 0 résultats
  </verify>
  <done>
Type mismatches corrigés, champs schema vérifiés, conversions string→number ajoutées.
  </done>
</task>

<task type="auto">
  <name>Task 8: Nettoyer variables non utilisées (TS6133)</name>
  <files>packages/client/src/components/*.tsx, packages/client/src/pages/*.tsx</files>
  <action>
**Supprimer ~20 variables/imports non utilisés**

Pattern de correction:
```typescript
// ❌ Avant
import { Badge, CardHeader, Users } from 'lucide-react';
const [avatarFile, setAvatarFile] = useState(null);
const navigate = useNavigate();

// ✅ Après (supprimer si vraiment non utilisés)
import { CardHeader } from 'lucide-react';
// avatarFile supprimé
// navigate supprimé
```

**Fichiers concernés:**
- AIAssistant.tsx: startNewConversation (ligne 264)
- EnrichedClientInfo.tsx: avatarFile, setAvatarFile, logoFile, setLogoFile, addWebsite, removeWebsite, updateWebsite (lignes 79-176)
- AudioFiles.tsx: fileId (ligne 113)
- Chat.tsx: CardContent, CardTitle (ligne 2)
- Bookings.tsx: navigate (ligne 22)
- ClientCreate.tsx: Badge, Mail, Globe (lignes 9, 11)
- Clients.tsx: _getTypeLabel (ligne 147)
- Dashboard.tsx: CardHeader (ligne 2)
- EquipmentDetail.tsx: Package (ligne 20)
- FinancialReports.tsx: Badge, FileText, Calendar, Users, totalQuotesValue, pendingQuotes (lignes 11, 20, 22, 23, 51, 53)
- Notifications.tsx: CardHeader, CardTitle (ligne 2)
- QuoteCreate.tsx: useRef (ligne 1)

**Stratégie:**
1. Pour chaque fichier, vérifier si variable vraiment inutilisée
2. Si code commenté utilise variable → garder et décommenter
3. Si vraiment inutilisée → supprimer
4. Pour imports → supprimer seulement ceux non utilisés

**Ce qu'il NE FAUT PAS faire:**
- Ne pas supprimer variables utilisées dans JSX
- Ne pas supprimer imports utilisés par d'autres imports
  </action>
  <verify>
1. `pnpm --filter client tsc --noEmit 2>&1 | grep "TS6133" | wc -l` → 0
2. Code compile sans warnings variables non utilisées
  </verify>
  <done>
Variables et imports non utilisés nettoyés, code plus propre.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Toutes corrections TypeScript appliquées - validation finale</what-built>
  <how-to-verify>
1. Exécuter: `cd /Users/marabook_m1/Documents/APP_HOME/CascadeProjects/windsurf-project/recording-studio-manager-hybrid`
2. Run: `pnpm check 2>&1 | tee /tmp/final-typecheck.txt`
3. Compter erreurs: `grep "error TS" /tmp/final-typecheck.txt | wc -l`
4. **Cible: 0 erreurs**
5. Si erreurs restent:
   - Afficher: `grep "error TS" /tmp/final-typecheck.txt | head -20`
   - Catégoriser par type
   - Décider si acceptable ou bloquer
6. Tester build production:
   - `pnpm build`
   - Vérifier: Client et Server compilent
  </how-to-verify>
  <resume-signal>Type "approved" si 0 erreurs OU erreurs < 5 et non-bloquantes, sinon "needs-fix" avec détails</resume-signal>
</task>

</tasks>

<verification>
Avant de déclarer phase complète:
- [ ] `pnpm --filter database build` → 0 erreurs
- [ ] `pnpm --filter shared build` → 0 erreurs
- [ ] `pnpm --filter server build` → 0 erreurs (ou tsc --noEmit)
- [ ] `pnpm --filter client build` → 0 erreurs (warnings TS6133 OK)
- [ ] `pnpm check` → "All checks passed" ou ≤ 5 erreurs non-bloquantes
- [ ] Types trackId et projectId disponibles
- [ ] Git diff montre corrections pertinentes
</verification>

<success_criteria>
- Tous les tasks complétés
- pnpm check = 0 erreurs TypeScript (strict)
- Server compile proprement
- Client compile proprement
- Aucune régression fonctionnelle
- Prêt pour Phase 16 (Facturation Automatique)
</success_criteria>

<output>
After completion, create `.planning/phases/15.5-typescript-cleanup/15.5-01-SUMMARY.md`:

# Phase 15.5 Plan 1: TypeScript Cleanup Summary

**316 erreurs TypeScript corrigées - Type safety restaurée**

## Performance

- **Duration:** [X] min
- **Started:** [timestamp]
- **Completed:** [timestamp]
- **Tasks:** 9 (7 auto + 2 checkpoints)
- **Files modified:** [count]

## Accomplishments

- Types Drizzle régénérés avec trackId/projectId
- 44 erreurs server corrigées (schema Drizzle, session types, imports)
- 272 erreurs client corrigées (arrays vs strings, undefined checks, type mismatches)
- 20 variables non utilisées nettoyées
- pnpm check = 0 erreurs

## Files Created/Modified

- `packages/database/dist/` - Types régénérés
- `packages/server/src/index.ts` - Session types augmentés
- `packages/server/src/lib/aiActions.ts` - Queries Drizzle corrigées
- `packages/server/src/services/timer-service.ts` - trackId supporté
- `packages/server/src/routers/*.ts` - Schema fields corrigés
- `packages/client/src/pages/Clients.tsx` - Arrays vs strings fixés
- `packages/client/src/pages/client-portal/BookingDetail.tsx` - Undefined guards
- `packages/client/src/pages/Projects.tsx` - Type mismatches résolus
- `packages/client/src/components/*.tsx` - Variables non utilisées supprimées

## Decisions Made

**Drizzle types régénération:**
- Choix de rebuild complet plutôt que génération incrémentale
- Garantit synchronisation avec migrations 0007/0008

**Session types augmentation:**
- Utilisation module augmentation (declare module) vs modification @types
- Standard TypeScript pour étendre types tiers

**Arrays vs strings (phones/emails):**
- Décision basée sur ce que clients.list retourne réellement
- Cohérence maintenue dans toute l'UI

## Deviations from Plan

[Documenter si écarts par rapport au plan]

## Issues Encountered

[Documenter problèmes rencontrés et résolutions]

## Next Phase Readiness

Phase 15.5 complete - Type safety restaurée.
Ready for Phase 16 (Facturation Automatique - Backend Integration).

---
*Phase: 15.5-typescript-cleanup*
*Completed: 2026-01-09*
</output>
