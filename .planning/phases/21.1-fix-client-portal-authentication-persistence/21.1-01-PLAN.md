---
phase: 21.1-fix-client-portal-authentication-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/routers/client-portal-auth.ts
  - packages/server/src/_core/context.ts
  - packages/client/src/contexts/ClientPortalAuthContext.tsx
  - packages/client/src/pages/client-portal/ClientLogin.tsx
  - e2e/client-portal/auth.spec.ts
autonomous: true

must_haves:
  truths:
    - "Client Portal login persists session across page refreshes"
    - "ProtectedClientRoute validates session with server, not just localStorage"
    - "E2E tests pass without manual sessionToken injection (8/8 green)"
    - "Session expiration enforced server-side"
    - "Client Portal uses same session mechanism as Admin Portal (express-session)"
  artifacts:
    - path: "packages/server/src/_core/context.ts"
      provides: "Dual session context (Admin + Client Portal)"
      contains: "clientPortalClientId"
      min_lines: 50
    - path: "packages/client/src/contexts/ClientPortalAuthContext.tsx"
      provides: "Server-validated auth context with tRPC query"
      exports: ["useClientPortalAuth", "ProtectedClientRoute"]
      min_lines: 80
    - path: "packages/server/src/routers/client-portal-auth.ts"
      provides: "Express-session based login mutation"
      contains: "req.session.save"
      min_lines: 1000
    - path: "e2e/client-portal/auth.spec.ts"
      provides: "E2E tests without localStorage workarounds"
      contains: "test('login persists across refresh'"
      min_lines: 100
  key_links:
    - from: "ClientPortalAuthContext"
      to: "clientPortalAuth.me"
      via: "tRPC query on mount"
      pattern: "trpc\\.clientPortalAuth\\.me\\.useQuery"
    - from: "ProtectedClientRoute"
      to: "Navigate component"
      via: "React Router declarative redirect"
      pattern: "<Navigate to=\"/client-portal/login\""
    - from: "clientPortalAuth.login"
      to: "req.session.clientPortalClientId"
      via: "express-session storage"
      pattern: "req\\.session\\.save"
    - from: "packages/server/src/_core/context.ts"
      to: "clientPortalClientId"
      via: "session extraction in context"
      pattern: "req\\.session.*clientPortalClientId"
---

<objective>
Fix Client Portal authentication persistence bug by migrating from localStorage-based tokens to express-session cookies (same mechanism as Admin Portal).

Purpose: Resolve critical production blocker where Client Portal sessions fail to persist after login, causing E2E test failures (6/8 failing) and making production client portal unusable for invoice payments.

Output: Unified authentication system using express-session for both Admin and Client Portal, with server-side session validation on every request.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21.1-fix-client-portal-authentication-persistence/21.1-RESEARCH.md

# Architecture References
@packages/server/src/routers/auth.ts                          # Admin Portal auth (WORKING pattern to replicate)
@packages/client/src/contexts/AuthContext.tsx                 # Admin auth context (WORKING pattern to replicate)
@packages/client/src/components/ProtectedRoute.tsx            # Admin protected route (WORKING pattern to replicate)

# Files to Modify
@packages/server/src/routers/client-portal-auth.ts
@packages/server/src/_core/context.ts
@packages/client/src/contexts/ClientPortalAuthContext.tsx
@packages/client/src/pages/client-portal/ClientLogin.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate Client Portal login to express-session</name>
  <files>
packages/server/src/routers/client-portal-auth.ts
packages/server/src/_core/context.ts
  </files>
  <action>
Modify Client Portal authentication backend to use express-session instead of returning sessionToken.

**Backend: packages/server/src/routers/client-portal-auth.ts**

1. **login mutation (lines 166-318):**
   - REMOVE: `sessionToken` generation and return (lines 272-273, 313-316)
   - ADD: Session persistence pattern from Admin Portal auth.ts (lines 131-137):
     ```typescript
     // Set session
     (ctx.req.session as any).clientPortalClientId = account.clientId;
     (ctx.req.session as any).clientPortalOrganizationId = organizationId;

     await new Promise<void>((resolve, reject) => {
       ctx.req.session.save((err) => {
         if (err) reject(err);
         else resolve();
       });
     });
     ```
   - KEEP: All logging, validation, password checks
   - RETURN: Only `{ client: client[0] }` (no sessionToken)

2. **verifyMagicLink mutation (lines 431-556):**
   - Apply same session pattern (replace sessionToken with req.session storage)
   - After magic link verification, set clientPortalClientId + clientPortalOrganizationId
   - Call req.session.save() with promise wrapper

3. **Create new `me` query:**
   ```typescript
   me: publicProcedure.query(async ({ ctx }) => {
     const clientPortalClientId = (ctx.req.session as any).clientPortalClientId;
     const clientPortalOrganizationId = (ctx.req.session as any).clientPortalOrganizationId;

     if (!clientPortalClientId || !clientPortalOrganizationId) {
       return { client: null };
     }

     const tenantDb = await getTenantDb(clientPortalOrganizationId);
     const client = await tenantDb
       .select()
       .from(clients)
       .where(eq(clients.id, clientPortalClientId))
       .limit(1);

     if (client.length === 0) {
       return { client: null };
     }

     return { client: client[0] };
   }),
   ```

4. **logout mutation (lines 736-777):**
   - REMOVE: sessionToken input requirement
   - ADD: Session destruction:
     ```typescript
     delete (ctx.req.session as any).clientPortalClientId;
     delete (ctx.req.session as any).clientPortalOrganizationId;

     await new Promise<void>((resolve, reject) => {
       ctx.req.session.save((err) => {
         if (err) reject(err);
         else resolve();
       });
     });
     ```

**Context: packages/server/src/_core/context.ts**

5. Add Client Portal session extraction to tRPC context (after Admin session extraction):
   ```typescript
   // Admin Portal session (existing)
   const userId = req.session.userId;
   const organizationId = req.session.organizationId;

   // Client Portal session (NEW)
   const clientPortalClientId = (req.session as any).clientPortalClientId;
   const clientPortalOrganizationId = (req.session as any).clientPortalOrganizationId;

   // Determine effective organizationId for getTenantDb
   const effectiveOrgId = organizationId || clientPortalOrganizationId;

   return {
     req,
     res,
     user: userId ? { id: userId } : null,
     organizationId,
     clientPortalClientId,      // NEW
     clientPortalOrganizationId, // NEW
     getTenantDb: async () => getTenantDb(effectiveOrgId || 1),
   };
   ```

**WHY avoid sessionToken approach:** localStorage tokens have no server-side validation, can be manipulated, no automatic expiration enforcement, require custom middleware. Express-session provides battle-tested session management with Redis persistence, automatic expiration, CSRF protection via sameSite cookies, and httpOnly security.
  </action>
  <verify>
Run backend tests:
```bash
# Verify login mutation no longer returns sessionToken
curl -X POST http://localhost:3001/api/trpc/clientPortalAuth.login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@client.com","password":"Test123!"}' \
  --cookie-jar cookies.txt

# Response should NOT contain sessionToken field
# Response should contain Set-Cookie header with express session

# Verify me query works with session cookie
curl http://localhost:3001/api/trpc/clientPortalAuth.me \
  --cookie cookies.txt

# Response should return client data (not null)
```

Expected: login returns `{ client: {...} }` without sessionToken, me query validates session from cookie.
  </verify>
  <done>
- login mutation sets req.session.clientPortalClientId + clientPortalOrganizationId
- login mutation calls req.session.save() with promise wrapper
- login mutation returns only client data (no sessionToken)
- me query created that validates session and returns current client
- logout mutation destroys session
- tRPC context extracts clientPortalClientId from req.session
- Manual curl test confirms session cookie sent and validated
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Client Portal frontend to use session-based auth</name>
  <files>
packages/client/src/contexts/ClientPortalAuthContext.tsx
packages/client/src/pages/client-portal/ClientLogin.tsx
  </files>
  <action>
Migrate Client Portal frontend from localStorage tokens to server-validated sessions using tRPC queries.

**ClientPortalAuthContext.tsx (COMPLETE REWRITE):**

1. **Remove localStorage logic:**
   - DELETE: SESSION_TOKEN_KEY, CLIENT_DATA_KEY constants (lines 34-35)
   - DELETE: sessionToken state (line 42)
   - DELETE: All localStorage.getItem/setItem/removeItem calls (lines 48-78)

2. **Add tRPC query for session validation (replicate Admin Portal pattern from AuthContext.tsx):**
   ```typescript
   import { trpc } from '@/lib/trpc';

   export function ClientPortalAuthProvider({ children }: ClientPortalAuthProviderProps) {
     const [client, setClient] = useState<Client | null>(null);
     const [isLoading, setIsLoading] = useState(true);

     // Query session from server (like Admin Portal auth.me)
     const meQuery = trpc.clientPortalAuth.me.useQuery(undefined, {
       retry: false,
       refetchOnWindowFocus: false,
     });

     useEffect(() => {
       if (meQuery.data?.client) {
         setClient(meQuery.data.client);
       } else if (meQuery.error || meQuery.isError) {
         setClient(null);
       }
       setIsLoading(meQuery.isLoading);
     }, [meQuery.data, meQuery.error, meQuery.isError, meQuery.isLoading]);

     const login = (clientData: Client) => {
       setClient(clientData);
       // No localStorage - session cookie sent automatically by browser
     };

     const logout = () => {
       setClient(null);
       // Server destroys session via logout mutation
     };

     const updateClient = (clientData: Client) => {
       setClient(clientData);
     };

     const value: ClientPortalAuthContextType = {
       client,
       isAuthenticated: !!client,
       isLoading,
       login,
       logout,
       updateClient,
     };

     return (
       <ClientPortalAuthContext.Provider value={value}>
         {children}
       </ClientPortalAuthContext.Provider>
     );
   }
   ```

3. **Fix ProtectedClientRoute:**
   - REPLACE: `window.location.href = '/client-portal/login'` (line 148)
   - WITH: `<Navigate to="/client-portal/login" replace />` (declarative React Router redirect)
   - ADD: `import { Navigate } from 'react-router-dom'`

**ClientLogin.tsx:**

4. Update login success handler:
   ```typescript
   const result = await loginMutation.mutateAsync({ email, password });
   // BEFORE: authLogin(result.sessionToken, result.client as any);
   // AFTER: authLogin(result.client as any); // No sessionToken
   navigate('/client-portal');
   ```

**WHY avoid window.location.href:** Full page reload breaks SPA navigation, loses React Router state, causes flash of loading. `Navigate` component preserves SPA behavior, maintains React state, and is the React Router v6 standard pattern.
  </action>
  <verify>
Run development server and test manually:
```bash
pnpm --filter client dev

# Navigate to http://localhost:5174/client-portal/login
# Login with test credentials
# Open DevTools Network tab
# Verify:
# 1. Login request has Set-Cookie header (express session)
# 2. Subsequent requests send Cookie header automatically
# 3. No sessionToken in localStorage
# 4. Page refresh maintains logged-in state (via me query)
# 5. Navigate to /client-portal works without window.location reload
```

Expected: Login succeeds, session cookie set, me query validates session, page refresh stays logged in, no localStorage usage.
  </verify>
  <done>
- ClientPortalAuthContext uses tRPC me query instead of localStorage
- sessionToken state and localStorage calls removed
- ProtectedClientRoute uses Navigate component (not window.location.href)
- ClientLogin.tsx updated to not expect sessionToken from login mutation
- Manual browser test confirms session persists across page refresh
- DevTools confirms session cookie sent on all requests
  </done>
</task>

<task type="auto">
  <name>Task 3: Update E2E tests to remove localStorage workarounds</name>
  <files>
e2e/client-portal/auth.spec.ts
  </files>
  <action>
Remove manual sessionToken injection from E2E tests now that authentication uses real session cookies.

**e2e/client-portal/auth.spec.ts:**

1. **Remove localStorage.setItem workarounds:**
   - Search for all `localStorage.setItem('client_portal_session_token'` calls
   - DELETE these lines - no longer needed with cookie-based sessions
   - DELETE manual token storage after login

2. **Add page refresh test to validate session persistence:**
   ```typescript
   test('login persists session across page refresh', async ({ page }) => {
     await page.goto('http://localhost:5174/client-portal/login');

     // Login
     await page.fill('input[name="email"]', 'test@client.com');
     await page.fill('input[name="password"]', 'Test123!');
     await page.click('button[type="submit"]');

     // Wait for redirect to dashboard
     await page.waitForURL('**/client-portal**');
     await expect(page.locator('text=Dashboard')).toBeVisible();

     // Refresh page
     await page.reload();

     // Should still be logged in (me query validates session cookie)
     await expect(page.locator('text=Dashboard')).toBeVisible();
     // Should NOT redirect to login
     await expect(page).not.toHaveURL('**/login**');
   });
   ```

3. **Verify cookie storage in tests:**
   ```typescript
   test('login sets session cookie', async ({ page, context }) => {
     await page.goto('http://localhost:5174/client-portal/login');

     await page.fill('input[name="email"]', 'test@client.com');
     await page.fill('input[name="password"]', 'Test123!');
     await page.click('button[type="submit"]');

     await page.waitForURL('**/client-portal**');

     // Verify session cookie exists
     const cookies = await context.cookies();
     const sessionCookie = cookies.find(c => c.name === 'connect.sid');
     expect(sessionCookie).toBeDefined();
     expect(sessionCookie?.httpOnly).toBe(true);
   });
   ```

**WHY remove localStorage injection:** It was a workaround for broken authentication. With proper express-session cookies, browser automatically sends Cookie header on all requests. Playwright's context automatically handles cookie storage and transmission, making manual injection unnecessary and misleading.
  </action>
  <verify>
Run E2E tests:
```bash
npx playwright test e2e/client-portal/auth.spec.ts

# Expected: All tests pass (8/8 green)
# No localStorage manipulation in test code
# Session persistence via cookies works automatically
```

Review test output for:
- 0 uses of `localStorage.setItem` in test code
- Session cookie (`connect.sid`) present in browser context
- Page refresh test passes (session persists)
- No authentication failures or unexpected redirects
  </verify>
  <done>
- E2E tests no longer inject sessionToken into localStorage
- Page refresh test added to validate session persistence
- Cookie verification test confirms httpOnly session cookie set
- All 8 Client Portal E2E tests pass without localStorage workarounds
- Playwright test report shows 100% pass rate
  </done>
</task>

</tasks>

<verification>
**Overall Integration Tests:**

1. **Manual Browser Test:**
   - Navigate to http://localhost:5174/client-portal/login
   - Login with valid credentials
   - Verify redirected to /client-portal dashboard
   - Open DevTools → Application → Cookies
   - Confirm `connect.sid` cookie exists (httpOnly: true, sameSite: lax)
   - Open DevTools → Application → Local Storage
   - Confirm NO `client_portal_session_token` key
   - Refresh page (F5)
   - Confirm still logged in (no redirect to login)
   - Navigate to different client portal pages
   - Confirm navigation works without full page reload
   - Logout
   - Confirm redirected to login
   - Confirm session cookie cleared

2. **E2E Test Suite:**
   ```bash
   npx playwright test e2e/client-portal/
   ```
   - Expected: 8/8 tests passing (was 2/8 before fix)
   - auth.spec.ts: All authentication tests green
   - No localStorage manipulation in test code
   - No manual sessionToken injection

3. **Backend Session Validation:**
   ```bash
   # Test session cookie workflow
   curl -X POST http://localhost:3001/api/trpc/clientPortalAuth.login \
     -H "Content-Type: application/json" \
     -d '{"email":"test@client.com","password":"Test123!"}' \
     -c cookies.txt -v

   # Verify Set-Cookie header in response
   # Verify sessionToken NOT in JSON response body

   # Test me query with cookie
   curl http://localhost:3001/api/trpc/clientPortalAuth.me \
     -b cookies.txt

   # Expected: Returns client data (not null)
   ```

4. **Cross-Browser Compatibility:**
   Run Playwright tests in all browsers:
   ```bash
   npx playwright test e2e/client-portal/ --project=chromium
   npx playwright test e2e/client-portal/ --project=firefox
   npx playwright test e2e/client-portal/ --project=webkit
   ```
   Expected: All pass in all browsers (session cookies work universally)

5. **Session Expiration:**
   - Login to client portal
   - Wait for session expiration (default: 7 days, but can test with shorter TTL)
   - Refresh page
   - Confirm redirected to login (me query returns null)
   - Confirm session cookie cleared
</verification>

<success_criteria>
- [x] Client Portal login mutation sets req.session.clientPortalClientId
- [x] Client Portal login mutation no longer returns sessionToken
- [x] ClientPortalAuthContext uses tRPC me query (not localStorage)
- [x] ProtectedClientRoute uses Navigate component (not window.location.href)
- [x] E2E tests pass 8/8 (was 2/8 before fix)
- [x] No localStorage usage for authentication tokens
- [x] Session cookie (connect.sid) set as httpOnly
- [x] Page refresh maintains logged-in state
- [x] tRPC context extracts clientPortalClientId from req.session
- [x] Production client portal authentication works end-to-end
- [x] Admin Portal authentication still works (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/21.1-fix-client-portal-authentication-persistence/21.1-01-SUMMARY.md` documenting:
- Root cause: Dual authentication systems (localStorage vs express-session)
- Solution: Migrated Client Portal to express-session for consistency
- Files modified: 5 files (2 backend, 2 frontend, 1 E2E test)
- E2E results: 8/8 tests passing (100% success rate)
- Production impact: Client Portal now production-ready for invoice payments
- Architecture change: Unified authentication system using express-session for both Admin and Client Portal
</output>
