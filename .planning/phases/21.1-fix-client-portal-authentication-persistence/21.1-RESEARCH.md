# Phase 21.1: Fix Client Portal Authentication Persistence - Research

**Researched:** 2026-01-16
**Domain:** Authentication persistence in React SPA with dual auth systems (express-session + localStorage)
**Confidence:** HIGH

## Summary

This phase addresses a critical authentication persistence bug where Client Portal sessions fail to persist after login, causing E2E test failures (6/8 failing) and production client portal unusability.

**Root Cause Identified:** The application implements two **completely separate** authentication systems that don't communicate:
1. **Admin Portal:** Express-session + Redis (session cookies) - **WORKS**
2. **Client Portal:** Custom sessionToken + localStorage - **BROKEN**

The Client Portal uses `localStorage` to store session tokens returned from tRPC mutations, but the authentication system has **no server-side session validation** - it only validates tokens on initial login, not on subsequent page navigations. This creates a disconnect where:
- Login succeeds ✅ (token stored in localStorage)
- Navigation fails ❌ (ProtectedClientRoute checks localStorage, but server doesn't validate token)
- Page refresh fails ❌ (localStorage persists, but no server-side session to validate against)

**Primary recommendation:** Fix Client Portal authentication by implementing proper session token validation in tRPC context OR migrate to express-session cookies for consistency with Admin Portal.

## Standard Stack

The established libraries/tools for session management in tRPC + React applications:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| express-session | 1.18+ | Server-side session management | Battle-tested, tRPC-compatible, works with req/res objects |
| connect-redis | 7.1+ | Redis session store | Official Redis store for express-session |
| Redis | 4.x | Session persistence | Industry standard for session storage |
| react-router-dom | 6.x | Client-side routing | Standard for React SPAs, supports declarative navigation |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| bcryptjs | 2.4+ | Password hashing | Already in use for both auth systems |
| crypto (Node.js) | Built-in | Secure token generation | Already in use for sessionToken generation |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| express-session | JWT in httpOnly cookies | More complex, requires token refresh logic |
| localStorage | sessionStorage | Loses session on tab close (worse UX) |
| Custom sessionToken | express-session cookies | More consistent, but requires migration |

**Installation:**
```bash
# Already installed - no new dependencies needed
npm list express-session connect-redis redis bcryptjs
```

## Architecture Patterns

### Current Architecture (BROKEN)

```
Client Portal Flow:
1. User submits login → tRPC clientPortalAuth.login
2. Server validates credentials → returns sessionToken
3. Client stores token in localStorage
4. Client navigates to /client-portal
5. ProtectedClientRoute checks localStorage
   ✅ Token exists → renders children
   ❌ No token → redirects to /login
6. PROBLEM: No server-side validation of token on subsequent requests
```

**Why it's broken:**
- localStorage is **client-side only** - can be manipulated
- Server doesn't validate sessionToken in tRPC context
- Session expiration not enforced (token stored indefinitely)
- Page refresh works (localStorage persists) but actual auth state is stale

### Admin Portal Flow (WORKING)

```
Admin Portal Flow:
1. User submits login → tRPC auth.login
2. Server validates credentials → sets express-session
3. Session cookie sent to client (httpOnly, secure)
4. Client navigates to /dashboard
5. ProtectedRoute checks isAuthenticated (from AuthContext)
6. AuthContext queries tRPC auth.me (validates session on server)
7. Server checks req.session.userId in tRPC context
   ✅ Valid session → returns user data
   ❌ Invalid/expired → returns null
8. Client renders protected route OR redirects to /login
```

**Why it works:**
- Server-side session validation on **every** tRPC request
- Session expiration enforced by Redis TTL
- Cookie sent automatically by browser (credentials: true in tRPC client)
- No client-side storage of sensitive tokens

### Recommended Fix Pattern 1: Validate sessionToken in tRPC Context

Add middleware to validate Client Portal sessionToken on every request:

```typescript
// packages/server/src/_core/context.ts
export async function createContext({ req, res }: CreateExpressContextOptions) {
  // Admin auth (existing - WORKS)
  const userId = req.session.userId;
  const organizationId = req.session.organizationId;

  // Client Portal auth (NEW - validate sessionToken)
  let clientPortalSession = null;
  const authHeader = req.headers.authorization;

  if (authHeader?.startsWith('Bearer ')) {
    const token = authHeader.substring(7);

    // Validate token against database
    const tenantDb = await getTenantDb(organizationId || 1);
    const session = await tenantDb
      .select()
      .from(clientPortalSessions)
      .where(eq(clientPortalSessions.token, token))
      .limit(1);

    if (session.length > 0 && !isTokenExpired(session[0].expiresAt)) {
      clientPortalSession = session[0];
    }
  }

  return {
    req,
    res,
    user: userId ? { id: userId } : null,
    organizationId,
    clientPortalSession, // NEW: Add to context
    getTenantDb: async () => getTenantDb(organizationId || clientPortalSession?.organizationId || 1),
  };
}
```

**Update Client Portal tRPC client:**
```typescript
// packages/client/src/lib/trpc.ts
const sessionToken = localStorage.getItem('client_portal_session_token');

const trpcClient = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: `${getBaseUrl()}/api/trpc`,
      headers: sessionToken
        ? { authorization: `Bearer ${sessionToken}` }
        : undefined,
      fetch(url, options) {
        return fetch(url, {
          ...options,
          credentials: 'include',
        });
      },
    }),
  ],
});
```

### Recommended Fix Pattern 2: Migrate to express-session (PREFERRED)

Unify authentication systems - use express-session for both Admin and Client Portal:

```typescript
// packages/server/src/routers/client-portal-auth.ts
login: publicProcedure
  .input(z.object({ email: z.string().email(), password: z.string() }))
  .mutation(async ({ ctx, input }) => {
    const tenantDb = await getTenantDb(organizationId);

    // Validate credentials...
    const account = await validateCredentials(email, password);

    // Set session (SAME as Admin Portal)
    (ctx.req.session as any).clientPortalClientId = account.clientId;
    (ctx.req.session as any).clientPortalOrganizationId = organizationId;

    await new Promise<void>((resolve, reject) => {
      ctx.req.session.save((err) => {
        if (err) reject(err);
        else resolve();
      });
    });

    // Return client data (NO sessionToken)
    return { client: clientData };
  }),
```

**Update Client Portal AuthContext:**
```typescript
// packages/client/src/contexts/ClientPortalAuthContext.tsx
// REMOVE localStorage usage
// USE tRPC query to check session (like Admin Portal)

const getCurrentSession = trpc.clientPortalAuth.me.useQuery();

useEffect(() => {
  if (getCurrentSession.data) {
    setClient(getCurrentSession.data.client);
  }
}, [getCurrentSession.data]);
```

### Anti-Patterns to Avoid

- **localStorage for authentication tokens in production:** Client-side storage is insecure, can be manipulated, no server-side validation
- **window.location.href for internal redirects:** Breaks React Router state, causes full page reload, loses SPA benefits
- **Separate auth systems for same app:** Admin uses express-session, Client Portal uses localStorage - creates inconsistency and bugs
- **No session validation on protected routes:** ProtectedClientRoute only checks localStorage, doesn't validate with server

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Session token validation | Custom token validation middleware | express-session with Redis | Handles expiration, renewal, concurrent sessions, session fixation attacks |
| Client-side auth state | localStorage + manual sync | tRPC query with React Query caching | Automatic revalidation, optimistic updates, server-side validation |
| Authentication redirects | window.location.href | React Router Navigate or useNavigate | Preserves SPA state, no full page reload |
| Password hashing | Custom crypto implementation | bcryptjs (already in use) | Salt generation, timing attack protection |

**Key insight:** Authentication is security-critical - use battle-tested libraries with proper session management, not custom localStorage solutions.

## Common Pitfalls

### Pitfall 1: localStorage Authentication Without Server Validation

**What goes wrong:** Client Portal stores sessionToken in localStorage but server doesn't validate it on subsequent requests, creating a false sense of authentication.

**Why it happens:** Developers assume localStorage persistence = authenticated session, but localStorage is client-side only and can be manipulated.

**How to avoid:**
- ALWAYS validate tokens on server-side in tRPC context
- Use httpOnly cookies for sensitive tokens (not accessible to JavaScript)
- Implement session expiration and renewal
- Check session validity on EVERY protected route

**Warning signs:**
- E2E tests pass on first navigation, fail on subsequent ones
- Page refresh "logs in" user but protected routes redirect to login
- localStorage has token but API returns 401 Unauthorized
- Different authentication behavior between direct navigation and programmatic navigation

### Pitfall 2: window.location.href Breaking React Router State

**What goes wrong:** ProtectedClientRoute uses `window.location.href = '/client-portal/login'` which causes full page reload, losing React Router state and breaking SPA navigation.

**Why it happens:** Developers use window.location.href from vanilla JS habits, not realizing React Router has declarative navigation.

**How to avoid:**
```typescript
// ❌ WRONG - Full page reload
if (!isAuthenticated) {
  window.location.href = '/client-portal/login';
  return null;
}

// ✅ CORRECT - React Router navigation
if (!isAuthenticated) {
  return <Navigate to="/client-portal/login" replace />;
}

// ✅ ALSO CORRECT - Programmatic navigation
const navigate = useNavigate();
if (!isAuthenticated) {
  navigate('/client-portal/login', { replace: true });
  return null;
}
```

**Warning signs:**
- Full page reload on authentication redirect
- Browser back button doesn't work as expected
- React state lost after redirect
- Different behavior in E2E tests vs manual testing

### Pitfall 3: Dual Authentication Systems in Same Application

**What goes wrong:** Admin Portal uses express-session (works), Client Portal uses localStorage (broken), creating inconsistent authentication flows and maintenance burden.

**Why it happens:** Different developers implement different auth systems, or Client Portal added as "separate app" without considering shared backend.

**How to avoid:**
- Use **one** authentication system for entire application
- If multi-tenant, use same session mechanism with different context (organizationId vs clientId)
- Share authentication middleware and context creation logic
- Document authentication architecture in one place

**Warning signs:**
- Different login flows for different user types
- Different session storage mechanisms (cookies vs localStorage)
- Different context validation logic
- Code duplication in auth routers

### Pitfall 4: No Session Expiration Enforcement

**What goes wrong:** sessionToken stored in localStorage never expires, creating security risk and stale sessions.

**Why it happens:** Client-side expiration checks are optional, server doesn't validate token expiration on every request.

**How to avoid:**
- Store expiration timestamp in session record (database)
- Validate expiration on EVERY server-side request
- Implement automatic session renewal for active users
- Clear expired sessions from database regularly

**Warning signs:**
- Sessions last indefinitely
- No automatic logout after inactivity
- Database fills with expired session records
- Security audits flag session management

### Pitfall 5: tRPC Context Not Validating Client Portal Sessions

**What goes wrong:** tRPC context extracts `userId` and `organizationId` from express-session but doesn't extract/validate Client Portal sessions, so client portal requests have no auth context.

**Why it happens:** Context creation logic only handles Admin Portal auth, Client Portal auth added later without updating context.

**How to avoid:**
- Update `createContext` to handle **both** auth systems
- Extract sessionToken from Authorization header OR Cookie header
- Validate token and add to context object
- Update type definitions to include clientPortalSession

**Warning signs:**
- Client Portal tRPC mutations work (login) but queries fail (getCurrentSession)
- No clientPortalSession in tRPC context type
- Authorization header not sent from client
- 401 Unauthorized on protected Client Portal endpoints

## Code Examples

Verified patterns from official sources and codebase analysis:

### Pattern 1: Express-Session with tRPC (RECOMMENDED)

```typescript
// Source: https://discord-questions.trpc.io/m/1101372058207801435
// tRPC works with express-session without special config

// Server: packages/server/src/index.ts
app.use(session({
  store: new RedisStore({ client: redis, prefix: 'rsm:session:' }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24 * 7, // 7 days
    domain: process.env.NODE_ENV === 'production'
      ? '.recording-studio-manager.com'
      : undefined,
    sameSite: 'lax',
  },
}));

// Server: packages/server/src/_core/context.ts
export async function createContext({ req, res }: CreateExpressContextOptions) {
  return {
    req,
    res,
    user: req.session.userId ? { id: req.session.userId } : null,
    organizationId: req.session.organizationId,
    getTenantDb: async () => getTenantDb(req.session.organizationId || 1),
  };
}

// Client: packages/client/src/lib/trpc.ts
const trpcClient = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: `${getBaseUrl()}/api/trpc`,
      fetch(url, options) {
        return fetch(url, {
          ...options,
          credentials: 'include', // CRITICAL: Send cookies
        });
      },
    }),
  ],
});
```

### Pattern 2: Protected Route with Server Validation

```typescript
// Source: Codebase packages/client/src/components/ProtectedRoute.tsx (Admin - WORKING)
// React Router Navigate component for declarative redirects

import { Navigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <div className="min-h-screen flex items-center justify-center">
      <div className="text-lg">Loading...</div>
    </div>;
  }

  // ✅ CORRECT: React Router Navigate component
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}

// AuthContext validates with server on mount
const meQuery = trpc.auth.me.useQuery(undefined, {
  retry: false,
  refetchOnWindowFocus: false,
});

useEffect(() => {
  if (meQuery.data) {
    setUser(meQuery.data.user);
    setOrganization(meQuery.data.organization);
  } else if (meQuery.error || meQuery.isError) {
    setUser(null);
    setOrganization(null);
  }
  setIsLoading(meQuery.isLoading);
}, [meQuery.data, meQuery.error, meQuery.isError, meQuery.isLoading]);
```

### Pattern 3: Client Portal Login with Session Storage

```typescript
// CURRENT (BROKEN): packages/client/src/pages/client-portal/ClientLogin.tsx
const result = await loginMutation.mutateAsync({ email, password });
authLogin(result.sessionToken, result.client as any); // Stores in localStorage
navigate('/client-portal');

// RECOMMENDED FIX: Remove localStorage, use express-session like Admin Portal
const result = await loginMutation.mutateAsync({ email, password });
// Server sets req.session.clientPortalClientId
// No need to store token - cookie sent automatically
navigate('/client-portal');

// Update ClientPortalAuthContext to query server
const getCurrentSession = trpc.clientPortalAuth.me.useQuery();

useEffect(() => {
  if (getCurrentSession.data) {
    setClient(getCurrentSession.data.client);
  }
}, [getCurrentSession.data]);
```

### Pattern 4: Multi-Tenant Session Context

```typescript
// Server: packages/server/src/_core/context.ts
export async function createContext({ req, res }: CreateExpressContextOptions) {
  // Admin Portal session
  const adminUserId = req.session.userId;
  const adminOrgId = req.session.organizationId;

  // Client Portal session (NEW)
  const clientPortalClientId = (req.session as any).clientPortalClientId;
  const clientPortalOrgId = (req.session as any).clientPortalOrganizationId;

  // Determine active session type
  const isClientPortal = !!clientPortalClientId;
  const effectiveOrgId = isClientPortal ? clientPortalOrgId : adminOrgId;

  return {
    req,
    res,
    // Admin context
    user: adminUserId ? { id: adminUserId } : null,
    organizationId: adminOrgId,
    // Client Portal context (NEW)
    clientPortalClientId,
    clientPortalOrganizationId: clientPortalOrgId,
    isClientPortal,
    // Shared
    getTenantDb: async () => getTenantDb(effectiveOrgId || 1),
  };
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| JWT in localStorage | httpOnly cookies with express-session | 2023-2024 | Better security, no XSS risk, automatic CSRF protection with sameSite |
| window.location for redirects | React Router Navigate component | React Router v6 (2021) | Preserves SPA state, no full page reload |
| Custom session validation | Battle-tested express-session + Redis | Always preferred | Handles edge cases (concurrent sessions, expiration, renewal) |
| Separate auth per user type | Unified auth system with role/type in session | Best practice | Easier to maintain, consistent security model |

**Deprecated/outdated:**
- **localStorage for auth tokens:** Security risk (XSS attacks), no automatic expiration, no httpOnly protection. Use httpOnly cookies instead.
- **window.location.href for internal navigation:** Breaks SPA, loses React state. Use Navigate component or useNavigate hook.
- **No CORS credentials:** Modern SPAs with separate API need `credentials: 'include'` in fetch and `credentials: true` in CORS config.
- **Custom token validation:** Reinventing the wheel. Use express-session which handles session fixation, concurrent logins, expiration.

## Open Questions

Things that couldn't be fully resolved:

1. **Should we migrate Client Portal to express-session or keep dual auth?**
   - What we know: Admin uses express-session (works), Client Portal uses localStorage (broken)
   - What's unclear: Product requirement - do Clients need separate auth system? Or can we unify?
   - Recommendation: **Unify to express-session** for consistency unless there's a specific requirement for separate auth (e.g., different session lifetimes, different authentication providers)

2. **How to handle organizationId for Client Portal without subdomain lookup?**
   - What we know: Admin gets organizationId from session (user belongs to org), Client Portal needs to derive it from hostname/subdomain
   - What's unclear: Current code has `getOrganizationIdFromHostname` stub that returns hardcoded `1`
   - Recommendation: **Store organizationId in session on login** (like Admin Portal) instead of deriving from hostname each request. When Client logs in, look up their organization from `clients.organizationId` and store in session.

3. **Should Client Portal use Authorization header or Cookie header for tokens?**
   - What we know: Admin Portal uses Cookie (express-session), Client Portal currently uses neither (localStorage)
   - What's unclear: If we keep custom tokens, should we send via Authorization header (Bearer token) or migrate to cookies?
   - Recommendation: **Use express-session cookies** (like Admin) for consistency. If custom tokens required, use Authorization header with Bearer scheme and validate in tRPC context.

4. **How to test authentication persistence in E2E tests?**
   - What we know: Current tests manually inject sessionToken into localStorage (workaround for broken auth)
   - What's unclear: After fixing auth, do we test cookie-based sessions (requires different approach) or keep localStorage injection?
   - Recommendation: **Remove localStorage injection** after fix. E2E tests should login via tRPC mutation (like real users), then browser automatically sends session cookie. Use Playwright's `storageState` to persist cookies between tests if needed.

## Sources

### Primary (HIGH confidence)

**tRPC + express-session Integration:**
- [Express-session with tRPC - Discord](https://discord-questions.trpc.io/m/1101372058207801435) - Confirms express-session works with tRPC without special config
- [Express Session not persisting - tRPC GitHub](https://github.com/trpc/trpc/discussions/2570) - Common issues with session persistence in tRPC apps
- [Cookie-Based JWT Authentication in tRPC Backend](https://itsrakesh.com/blog/implementing-cookie-based-jwt-authentication-in-a-trpc-backend) - Recent 2025 implementation guide

**React Router Navigation:**
- [How to redirect in React Router - CoreUI](https://coreui.io/answers/how-to-redirect-in-react-router/) - Navigate component vs window.location
- [Programmatically navigate with React Router](https://ultimatecourses.com/blog/programmatically-navigate-react-router) - useNavigate hook patterns
- [React Router Redirect with useNavigate](https://refine.dev/blog/usenavigate-react-router-redirect/) - V6 redirect patterns

**Session Cookies with SPAs:**
- [Express-session cookies not saving - GitHub Gist](https://gist.github.com/samsch/3c2c98c415e1d5b15e37a272aa0b77f1) - Common CORS and credentials issues
- [Client-side Authentication the Right Way](https://www.taniarascia.com/full-stack-cookies-localstorage-react-express/) - Cookies vs localStorage security comparison
- [Authenticate SPAs With Cookies - Auth0](https://auth0.com/docs/manage-users/cookies/spa-authenticate-with-cookies) - Best practices for SPA authentication

### Secondary (MEDIUM confidence)

**Codebase Analysis:**
- `packages/server/src/routers/client-portal-auth.ts` - Client Portal auth router (sessionToken pattern)
- `packages/server/src/routers/auth.ts` - Admin Portal auth router (express-session pattern)
- `packages/client/src/contexts/ClientPortalAuthContext.tsx` - Client Portal auth context (localStorage)
- `packages/client/src/contexts/AuthContext.tsx` - Admin Portal auth context (tRPC query)
- `packages/client/src/components/ProtectedRoute.tsx` - Admin protected route (working)
- `packages/server/src/index.ts` - Express-session configuration (lines 133-154)

### Tertiary (LOW confidence)

- E2E test results from Phase 17-03-FIX showing authentication persistence failures
- Stack Overflow discussions on express-session with React SPAs (various dates, no single authoritative source)

## Metadata

**Confidence breakdown:**
- Standard stack: **HIGH** - express-session + Redis is industry standard, well-documented with tRPC
- Architecture: **HIGH** - Clear comparison between working (Admin) and broken (Client Portal) patterns
- Pitfalls: **HIGH** - All pitfalls identified from actual codebase bugs and E2E test failures
- Fix patterns: **MEDIUM** - Patterns verified from official docs and working Admin implementation, but not tested in Client Portal context yet

**Research date:** 2026-01-16
**Valid until:** 30 days (stable authentication libraries, patterns unlikely to change)

**Key findings for planner:**
1. Root cause is dual authentication systems - localStorage (broken) vs express-session (working)
2. Fix requires either (a) add sessionToken validation to tRPC context OR (b) migrate Client Portal to express-session
3. Migration to express-session is RECOMMENDED for consistency and security
4. ProtectedClientRoute must use Navigate component, not window.location.href
5. All protected routes must validate session on server, not just check localStorage
