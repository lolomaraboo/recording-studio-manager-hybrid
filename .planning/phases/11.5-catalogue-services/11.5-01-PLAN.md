---
phase: 11.5-catalogue-services
plan: 01
type: execute
---

<objective>
Create database schema and tRPC backend infrastructure for service catalog management.

Purpose: Establish backend foundation for storing and managing pre-defined service items (studio time, post-production, equipment rental) that can be quickly added to quotes.
Output: PostgreSQL service_catalog table, migration file, and tRPC router with CRUD + search/filter operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11.5-catalogue-services/11.5-CONTEXT.md

**Prior phase context:**
@.planning/phases/10-systeme-devis-backend/10-01-SUMMARY.md # Quote schema patterns
@.planning/phases/11-systeme-devis-frontend-ui/11-01-SUMMARY.md # Quote UI integration

**Prior decisions affecting this phase:**
- Database-per-Tenant architecture: service_catalog goes in tenant DB, not master
- Decimal precision (10, 2) for prices established in quote/invoice schemas
- Category-based organization pattern used throughout (clients.type, rooms, etc.)
- tRPC 11 with type-safe routers pattern established

**Codebase patterns:**
@packages/database/src/tenant/schema.ts # Existing schema patterns (quotes, quoteItems)
@packages/server/src/routers/quotes.ts # tRPC CRUD pattern to replicate

**Service catalog requirements from CONTEXT.md:**
- Store: name, description (optional), unitPrice, category, defaultQuantity, taxRate
- Categories: Studio, Post-production, Location matériel, Autre
- Enable quick lookup by name (autocomplete) and category (filtering)
- Tax rate can vary per service (20%, 10%, 5.5%, exempt, etc.)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service_catalog table schema and migration</name>
  <files>packages/database/src/tenant/schema.ts, packages/database/drizzle/</files>
  <action>
Add service_catalog table to tenant schema after quoteItems definition (around line 545):

```typescript
export const serviceCatalog = pgTable("service_catalog", {
  id: serial("id").primaryKey(),

  // Service details
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  category: varchar("category", { length: 100 }).notNull(), // "Studio" | "Post-production" | "Location matériel" | "Autre"

  // Pricing
  unitPrice: decimal("unit_price", { precision: 10, scale: 2 }).notNull(),
  taxRate: decimal("tax_rate", { precision: 5, scale: 2 }).notNull().default("20.00"),

  // Defaults for quote insertion
  defaultQuantity: decimal("default_quantity", { precision: 10, scale: 2 }).notNull().default("1.00"),

  // Metadata
  isActive: boolean("is_active").notNull().default(true),
  displayOrder: integer("display_order").notNull().default(0),

  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export type ServiceCatalog = typeof serviceCatalog.$inferSelect;
export type InsertServiceCatalog = typeof serviceCatalog.$inferInsert;
```

Generate migration: `DATABASE_URL="postgresql://postgres:password@localhost:5432/rsm_master" pnpm --filter database db:generate`

Migration will create service_catalog table in all tenant databases.
  </action>
  <verify>
- Schema file compiles without TypeScript errors: `pnpm --filter database tsc --noEmit`
- Migration file created in packages/database/drizzle/ with CREATE TABLE service_catalog
- Migration includes all columns: id, name, description, category, unitPrice, taxRate, defaultQuantity, isActive, displayOrder, createdAt, updatedAt
  </verify>
  <done>service_catalog table defined in schema with proper types, migration generated and ready to apply</done>
</task>

<task type="auto">
  <name>Task 2: Create tRPC service catalog router with CRUD operations</name>
  <files>packages/server/src/routers/serviceCatalog.ts (new), packages/server/src/routers/index.ts</files>
  <action>
Create new tRPC router following the pattern from quotes.ts:

**packages/server/src/routers/serviceCatalog.ts:**
```typescript
import { z } from "zod";
import { router, protectedProcedure } from "../trpc";
import { serviceCatalog } from "@rsm/database/tenant/schema";
import { eq, desc, and, ilike, sql } from "drizzle-orm";

export const serviceCatalogRouter = router({
  // List with optional search/filter
  list: protectedProcedure
    .input(z.object({
      search: z.string().optional(),
      category: z.string().optional(),
      activeOnly: z.boolean().default(true),
    }))
    .query(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();

      const conditions = [];
      if (input.activeOnly) {
        conditions.push(eq(serviceCatalog.isActive, true));
      }
      if (input.category) {
        conditions.push(eq(serviceCatalog.category, input.category));
      }
      if (input.search) {
        conditions.push(
          sql`${serviceCatalog.name} ILIKE ${'%' + input.search + '%'} OR ${serviceCatalog.description} ILIKE ${'%' + input.search + '%'}`
        );
      }

      return tenantDb.query.serviceCatalog.findMany({
        where: conditions.length > 0 ? and(...conditions) : undefined,
        orderBy: [serviceCatalog.displayOrder, serviceCatalog.name],
      });
    }),

  // Get by ID
  getById: protectedProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();
      return tenantDb.query.serviceCatalog.findFirst({
        where: eq(serviceCatalog.id, input.id),
      });
    }),

  // Create
  create: protectedProcedure
    .input(z.object({
      name: z.string().min(1, "Le nom est requis"),
      description: z.string().optional(),
      category: z.enum(["Studio", "Post-production", "Location matériel", "Autre"]),
      unitPrice: z.string().regex(/^\d+(\.\d{1,2})?$/, "Prix invalide"),
      taxRate: z.string().regex(/^\d+(\.\d{1,2})?$/, "TVA invalide").default("20.00"),
      defaultQuantity: z.string().regex(/^\d+(\.\d{1,2})?$/, "Quantité invalide").default("1.00"),
      isActive: z.boolean().default(true),
      displayOrder: z.number().default(0),
    }))
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();
      const [service] = await tenantDb.insert(serviceCatalog).values(input).returning();
      return service;
    }),

  // Update
  update: protectedProcedure
    .input(z.object({
      id: z.number(),
      name: z.string().min(1, "Le nom est requis").optional(),
      description: z.string().optional(),
      category: z.enum(["Studio", "Post-production", "Location matériel", "Autre"]).optional(),
      unitPrice: z.string().regex(/^\d+(\.\d{1,2})?$/, "Prix invalide").optional(),
      taxRate: z.string().regex(/^\d+(\.\d{1,2})?$/, "TVA invalide").optional(),
      defaultQuantity: z.string().regex(/^\d+(\.\d{1,2})?$/, "Quantité invalide").optional(),
      isActive: z.boolean().optional(),
      displayOrder: z.number().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();
      const { id, ...updateData } = input;
      const [updated] = await tenantDb
        .update(serviceCatalog)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(serviceCatalog.id, id))
        .returning();
      return updated;
    }),

  // Delete
  delete: protectedProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ ctx, input }) => {
      const tenantDb = await ctx.getTenantDb();
      await tenantDb.delete(serviceCatalog).where(eq(serviceCatalog.id, input.id));
      return { success: true };
    }),
});
```

**Register router in packages/server/src/routers/index.ts:**
Add import: `import { serviceCatalogRouter } from "./serviceCatalog";`
Add to router object: `serviceCatalog: serviceCatalogRouter,`
  </action>
  <verify>
- TypeScript compiles: `pnpm --filter server tsc --noEmit`
- Router exports all CRUD operations: list, getById, create, update, delete
- List supports search (fuzzy match name/description), category filter, activeOnly filter
- Input validation uses Zod with proper error messages
- All mutations return data for UI optimistic updates
  </verify>
  <done>serviceCatalog tRPC router created with full CRUD, search, and filter capabilities; registered in main router</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles across all packages: `pnpm check`
- [ ] Migration generated successfully in drizzle/ directory
- [ ] serviceCatalog router registered and accessible via tRPC client
- [ ] No breaking changes to existing quote/project functionality
</verification>

<success_criteria>
- service_catalog table schema defined with 11 columns
- Migration file created and ready to apply
- serviceCatalog tRPC router implements 5 operations (list, getById, create, update, delete)
- List operation supports 3 filters: search (fuzzy), category, activeOnly
- All TypeScript types properly inferred from schema
- Zero compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/11.5-catalogue-services/11.5-01-SUMMARY.md`:

# Phase 11.5 Plan 01: Backend Infrastructure Summary

**Backend foundation for service catalog complete - database schema and tRPC router ready**

## Accomplishments

- Created service_catalog table schema with 11 fields (name, description, category, pricing, defaults)
- Generated PostgreSQL migration for tenant databases
- Built serviceCatalog tRPC router with full CRUD operations
- Implemented search (fuzzy name/description), category filter, and activeOnly filter
- Type-safe integration with existing quote system

## Files Created/Modified

- `packages/database/src/tenant/schema.ts` - Added serviceCatalog table definition
- `packages/database/drizzle/XXXX_add_service_catalog.sql` - Migration file
- `packages/server/src/routers/serviceCatalog.ts` - New tRPC router (180 lines)
- `packages/server/src/routers/index.ts` - Registered serviceCatalog router

## Decisions Made

- Tax rate stored per service (allows different rates: 20%, 10%, 5.5%, exempt)
- Category enum: ["Studio", "Post-production", "Location matériel", "Autre"]
- Search uses fuzzy ILIKE matching on name and description (PostgreSQL full-text)
- displayOrder field enables manual sorting (future drag-and-drop)
- isActive flag for soft-delete (don't show in autocomplete, keep for quote history)

## Issues Encountered

None - straightforward schema extension following established patterns

## Next Step

Ready for 11.5-02-PLAN.md: Service Catalog Management Page (CRUD UI)
</output>
