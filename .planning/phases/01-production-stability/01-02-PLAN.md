---
phase: 01-production-stability
plan: 2
type: execute
---

<objective>
Establish basic production monitoring with health checks and error tracking.

Purpose: Currently zero visibility into production issues. Need to detect errors before users report them and track uptime.
Output: Health check endpoints implemented, Sentry error tracking configured, basic uptime monitoring active.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-production-stability/01-01-SUMMARY.md

**Monitoring requirements (from PROJECT.md):**
- v1.0 needs: Health checks, error tracking, uptime monitoring
- NOT needed v1.0: Prometheus/Grafana (too complex for <100 tenants)
- Sentry already chosen for error tracking (standard tool)

**Current infrastructure:**
- VPS: 31.220.104.244 (Hostinger 4GB RAM, 2 vCPU)
- Containers: rsm-server (Express), rsm-client (React), rsm-postgres, rsm-redis
- No monitoring currently - only Docker health checks

**Budget constraint:**
- Sentry free tier: 5k events/month (sufficient for early stage)
- UptimeRobot free tier: 50 monitors (sufficient)
- Avoid paid monitoring tools until revenue justifies
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement health check endpoints</name>
  <files>packages/server/src/routes/health.ts, packages/server/src/index.ts</files>
  <action>
    1. Create health check router: packages/server/src/routes/health.ts
    2. Implement GET /health endpoint returning: { status: "ok", timestamp: Date.now(), uptime: process.uptime() }
    3. Implement GET /health/db endpoint checking PostgreSQL connection (query rsm_master.tenants table)
    4. Implement GET /health/redis endpoint checking Redis connection (ping command)
    5. Add comprehensive health check GET /health/full combining all checks with status codes: 200 (all healthy), 503 (any unhealthy)
    6. Mount router in Express app: app.use('/api', healthRouter)
    7. Ensure health endpoints do NOT require authentication (public endpoints for monitoring)
  </action>
  <verify>
    - Build succeeds: `pnpm build`
    - Health routes exist in code
    - TypeScript types defined for health responses
    - No authentication middleware on /health routes
  </verify>
  <done>Health check endpoints implemented: /health, /health/db, /health/redis, /health/full with proper status codes</done>
</task>

<task type="auto">
  <name>Task 2: Configure Sentry error tracking</name>
  <files>packages/server/src/index.ts, packages/client/src/main.tsx, .env</files>
  <action>
    1. Install Sentry SDKs: `pnpm add @sentry/node @sentry/react` (in respective packages)
    2. Get Sentry DSN: Visit sentry.io → Create new project "recording-studio-manager" → Copy DSN
    3. Add to .env files:
       - packages/server/.env: SENTRY_DSN_BACKEND=https://...@sentry.io/...
       - packages/client/.env: VITE_SENTRY_DSN_FRONTEND=https://...@sentry.io/...
    4. Initialize Sentry in server (packages/server/src/index.ts):
       ```typescript
       import * as Sentry from '@sentry/node';
       Sentry.init({
         dsn: process.env.SENTRY_DSN_BACKEND,
         environment: process.env.NODE_ENV || 'production',
         tracesSampleRate: 0.1, // 10% performance monitoring (free tier limit)
       });
       // Add Sentry error handler AFTER all routes
       app.use(Sentry.Handlers.errorHandler());
       ```
    5. Initialize Sentry in client (packages/client/src/main.tsx):
       ```typescript
       import * as Sentry from '@sentry/react';
       Sentry.init({
         dsn: import.meta.env.VITE_SENTRY_DSN_FRONTEND,
         environment: import.meta.env.MODE,
         integrations: [new Sentry.BrowserTracing()],
         tracesSampleRate: 0.1,
       });
       ```
    6. Test error capture: Throw test error, verify appears in Sentry dashboard
  </action>
  <verify>
    - `pnpm install` succeeds, Sentry packages added
    - .env files contain SENTRY_DSN variables
    - Sentry.init() called in both server and client entry points
    - Build succeeds without errors
  </verify>
  <done>Sentry configured in both backend and frontend, test error visible in Sentry dashboard</done>
</task>

<task type="auto">
  <name>Task 3: Deploy monitoring to production</name>
  <files>Production VPS deployment</files>
  <action>
    1. Commit monitoring changes: `git add . && git commit -m "feat(monitoring): add health checks and Sentry error tracking"`
    2. SSH to VPS: `ssh root@31.220.104.244`
    3. Pull changes: `cd /opt/recording-studio-manager && git pull origin main`
    4. Add Sentry DSN to production .env files (both server and client)
    5. Rebuild containers: `docker-compose build`
    6. Restart services: `docker-compose up -d`
    7. Verify health endpoints: `curl http://localhost:3000/api/health`
    8. Check Sentry dashboard for connection confirmation
  </action>
  <verify>
    - Git commit exists for monitoring features
    - Production .env files contain Sentry DSN
    - Containers restarted successfully
    - Health endpoint returns 200 OK
    - Sentry dashboard shows project connected
  </verify>
  <done>Monitoring deployed to production, health checks responding, Sentry connected</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Setup UptimeRobot external monitoring</action>
  <instructions>
    I've deployed health check endpoints to production. Now we need external uptime monitoring:

    1. Visit https://uptimerobot.com/signUp (free tier)
    2. Create account with your email
    3. Add Monitor:
       - Monitor Type: HTTP(s)
       - Friendly Name: "Recording Studio Manager - Main Health"
       - URL: https://app.recording-studio-manager.com/api/health
       - Monitoring Interval: 5 minutes (free tier)
    4. Add second monitor:
       - Friendly Name: "Recording Studio Manager - Full Health"
       - URL: https://app.recording-studio-manager.com/api/health/full
       - Monitoring Interval: 5 minutes
    5. Configure alert contacts (your email)
    6. Enable notifications for downtime
  </instructions>
  <verification>UptimeRobot dashboard shows 2 monitors with "Up" status</verification>
  <resume-signal>Type "done" when UptimeRobot monitors are created and showing "Up" status</resume-signal>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Production monitoring infrastructure (health checks, Sentry, UptimeRobot)</what-built>
  <how-to-verify>
    1. Test health endpoints:
       - Visit: https://app.recording-studio-manager.com/api/health
       - Should return: {"status":"ok","timestamp":...,"uptime":...}
       - Visit: https://app.recording-studio-manager.com/api/health/full
       - Should return: 200 OK with all systems healthy
    2. Test Sentry error capture:
       - Visit Sentry dashboard: https://sentry.io/organizations/.../projects/recording-studio-manager/
       - Trigger test error in app (e.g., navigate to non-existent page)
       - Verify error appears in Sentry within 1-2 minutes
    3. Check UptimeRobot:
       - Visit UptimeRobot dashboard
       - Verify both monitors show green "Up" status
       - Check "Last Checked" is recent (<5 min ago)
  </how-to-verify>
  <resume-signal>Type "approved" if all monitoring working, or describe what's not working</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Health check endpoints implemented (/health, /health/db, /health/redis, /health/full)
- [ ] Sentry configured in backend and frontend
- [ ] Monitoring code committed and deployed to production
- [ ] Health endpoints return 200 OK
- [ ] Sentry dashboard shows project connected
- [ ] UptimeRobot monitors created and showing "Up"
- [ ] Error tracking verified (test error appears in Sentry)
</verification>

<success_criteria>

- Health check endpoints public and responding
- Sentry capturing errors from backend and frontend
- UptimeRobot monitoring uptime externally
- Errors visible in Sentry dashboard within minutes
- Uptime alerts configured to email on downtime
- Ready for end-to-end production validation (Plan 01-03)
</success_criteria>

<output>
After completion, create `.planning/phases/01-production-stability/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Setup Monitoring Summary

**Production visibility established - errors and downtime now detected automatically**

## Accomplishments

- Implemented health check endpoints (/health, /health/db, /health/redis, /health/full)
- Configured Sentry error tracking for backend and frontend
- Deployed monitoring infrastructure to production
- Setup UptimeRobot external uptime monitoring
- Verified error capture and uptime monitoring working

## Files Created/Modified

- `packages/server/src/routes/health.ts` - Health check endpoints
- `packages/server/src/index.ts` - Sentry initialization
- `packages/client/src/main.tsx` - Sentry frontend initialization
- `.env` files - Added Sentry DSN configuration

## Decisions Made

- Sentry free tier (5k events/month) sufficient for early stage
- UptimeRobot free tier (5 min intervals) acceptable for v1.0
- Health checks public (no auth) for external monitoring
- Traces sample rate 10% to stay within free tier limits

## Issues Encountered

[Document any issues during execution, or "None"]

## Next Step

Ready for 01-03-PLAN.md (Validate production deployment end-to-end)
</output>
