---
phase: 25-gestion-relations-client-entreprise
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - packages/server/src/routers/clients.ts
  - packages/client/src/components/CompanyMembersModal.tsx
autonomous: true

must_haves:
  truths:
    - "Individual client view shows all companies they belong to"
    - "Modal displays company names with roles from individual perspective"
    - "Add company dropdown filters only company-type clients"
    - "Role autocomplete suggests existing roles from database"
  artifacts:
    - path: "packages/server/src/routers/clients.ts"
      provides: "getCompanies endpoint for individual clients"
      exports: ["getCompanies"]
    - path: "packages/client/src/components/CompanyMembersModal.tsx"
      provides: "Individual view mode with company list"
      contains: "clientType === 'individual'"
  key_links:
    - from: "packages/client/src/components/CompanyMembersModal.tsx"
      to: "packages/server/src/routers/clients.ts"
      via: "getCompanies query when individual"
      pattern: "trpc\\.clients\\.getCompanies\\.useQuery"
    - from: "packages/client/src/components/CompanyMembersModal.tsx"
      to: "role autocomplete"
      via: "fetch existing roles for suggestions"
      pattern: "getRoles\\.useQuery"
---

<objective>
Complete the individual client view functionality by adding the missing backend endpoint and role autocomplete feature.

Purpose: Enable individuals to see which companies they belong to, and provide role autocomplete to prevent duplicates ("Ingénieur du son" vs "Ingénieur Son").

Output: Fully functional bidirectional UI with role consistency.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-gestion-relations-client-entreprise/25-CONTEXT.md
@.planning/phases/25-gestion-relations-client-entreprise/25-01-PLAN.md
@packages/server/src/routers/clients.ts
@packages/client/src/components/CompanyMembersModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getCompanies Backend Endpoint</name>
  <files>packages/server/src/routers/clients.ts</files>
  <action>
Add new tRPC endpoint `getCompanies` for querying companies linked to an individual client (reverse direction of getMembers).

**Endpoint:**
```typescript
getCompanies: protectedProcedure
  .input(z.object({ memberId: z.number() }))
  .query(async ({ ctx, input }) => {
    const tenantDb = await ctx.getTenantDb();

    const companies = await tenantDb
      .select({
        id: companyMembers.id, // company_members.id (NOT client.id)
        role: companyMembers.role,
        isPrimary: companyMembers.isPrimary,
        companyId: clients.id,
        companyName: clients.name,
        companyEmail: clients.email,
        companyLogoUrl: clients.logoUrl,
      })
      .from(companyMembers)
      .innerJoin(clients, eq(companyMembers.companyClientId, clients.id))
      .where(eq(companyMembers.memberClientId, input.memberId))
      .orderBy(desc(companyMembers.isPrimary), asc(clients.name));

    return companies;
  })
```

**Key details:**
- Input: `memberId` (individual client ID)
- Join: company_members → clients (on companyClientId)
- Filter: WHERE member_client_id = memberId
- Order: Primary contacts first, then alphabetically by company name
- Returns: company_members.id (critical for update/remove), company name/email/logo

**Why this pattern:**
- Symmetrical to getMembers (same join logic, reversed direction)
- Returns company_members.id ensures update/remove use correct relationship ID
- Ordering by isPrimary ensures primary contacts appear first
  </action>
  <verify>
```bash
# Endpoint exists
grep -A 15 "getCompanies:" packages/server/src/routers/clients.ts

# TypeScript check passes
pnpm check

# Test query structure
grep "memberClientId, input.memberId" packages/server/src/routers/clients.ts
```
  </verify>
  <done>
- getCompanies endpoint added to clients router
- Query joins company_members → clients correctly
- Returns company_members.id for relationship management
- TypeScript compilation 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate getCompanies in Modal</name>
  <files>packages/client/src/components/CompanyMembersModal.tsx</files>
  <action>
Update CompanyMembersModal to use getCompanies endpoint when viewing from individual client perspective.

**Current state:** Plan 25-01 created modal structure but left getCompanies as TODO.

**Changes needed:**

1. **Add query for individual view:**
```typescript
// Existing (company view)
const { data: members, isLoading: membersLoading } = trpc.clients.getMembers.useQuery(
  { companyId: clientId },
  { enabled: clientType === 'company' }
);

// New (individual view)
const { data: companies, isLoading: companiesLoading } = trpc.clients.getCompanies.useQuery(
  { memberId: clientId },
  { enabled: clientType === 'individual' }
);
```

2. **Unified data structure:**
```typescript
// Normalize both queries to same structure for rendering
const items = clientType === 'company'
  ? members?.map(m => ({ id: m.id, name: m.memberName, role: m.role, isPrimary: m.isPrimary }))
  : companies?.map(c => ({ id: c.id, name: c.companyName, role: c.role, isPrimary: c.isPrimary }));
```

3. **Update dropdown filter:**
```typescript
const { data: availableClients } = trpc.clients.list.useQuery({
  limit: 100,
  // Filter: show individuals when adding to company, companies when adding to individual
  // Note: clients.list doesn't have type filter yet - filter in client-side
});

const filteredClients = availableClients?.clients.filter(c =>
  clientType === 'company' ? c.type === 'individual' : c.type === 'company'
);
```

4. **Update addMember mutation call:**
```typescript
const handleAdd = async () => {
  await addMemberMutation.mutateAsync({
    companyId: clientType === 'company' ? clientId : selectedClientId,
    memberId: clientType === 'company' ? selectedClientId : clientId,
    role: newRole,
    isPrimary: newIsPrimary,
  });
  // Reset form + invalidate queries
};
```

**Why these patterns:**
- Conditional queries with `enabled` prevent unnecessary API calls
- Normalized data structure allows single render loop
- Client-side filter handles type filtering (avoids backend change)
- Mutation parameters swap based on view direction (company→member or member→company)
  </action>
  <verify>
```bash
# getCompanies query integrated
grep "getCompanies.useQuery" packages/client/src/components/CompanyMembersModal.tsx

# Conditional query enabled
grep "enabled: clientType" packages/client/src/components/CompanyMembersModal.tsx

# TypeScript check passes
pnpm check
```
  </verify>
  <done>
- getCompanies query integrated with conditional enable
- Data normalized for unified rendering
- Dropdown filters by client type correctly
- Mutation parameters swap based on view direction
- TypeScript compilation 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Role Autocomplete Feature</name>
  <files>
packages/server/src/routers/clients.ts
packages/client/src/components/CompanyMembersModal.tsx
  </files>
  <action>
**Part 1: Add getRoles Backend Endpoint**

Add lightweight endpoint to fetch existing roles for autocomplete suggestions.

```typescript
getRoles: protectedProcedure.query(async ({ ctx }) => {
  const tenantDb = await ctx.getTenantDb();

  // Get distinct roles from company_members table
  const roles = await tenantDb
    .selectDistinct({ role: companyMembers.role })
    .from(companyMembers)
    .where(sql`${companyMembers.role} IS NOT NULL AND ${companyMembers.role} != ''`)
    .orderBy(asc(companyMembers.role));

  return roles.map(r => r.role!); // Array of strings
})
```

**Part 2: Integrate Autocomplete in Modal**

Replace simple text input with autocomplete (use shadcn/ui Popover + Command pattern).

**UI Structure:**
```tsx
// Import at top
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem } from "@/components/ui/command";

// Query existing roles
const { data: existingRoles = [] } = trpc.clients.getRoles.useQuery();

// State for autocomplete
const [roleInputValue, setRoleInputValue] = useState("");
const [showRolePopover, setShowRolePopover] = useState(false);

// Render
<div className="space-y-2">
  <label className="text-sm font-medium">Rôle</label>
  <Popover open={showRolePopover} onOpenChange={setShowRolePopover}>
    <PopoverTrigger asChild>
      <input
        type="text"
        value={roleInputValue}
        onChange={(e) => setRoleInputValue(e.target.value)}
        onFocus={() => setShowRolePopover(true)}
        placeholder="Ex: Ingénieur du son, Producteur..."
        className="w-full px-3 py-2 border rounded-md"
      />
    </PopoverTrigger>
    <PopoverContent className="w-[400px] p-0" align="start">
      <Command>
        <CommandInput placeholder="Rechercher rôle existant..." />
        <CommandEmpty>Aucun rôle trouvé</CommandEmpty>
        <CommandGroup>
          {existingRoles
            .filter(role => role.toLowerCase().includes(roleInputValue.toLowerCase()))
            .map(role => (
              <CommandItem
                key={role}
                onSelect={() => {
                  setRoleInputValue(role);
                  setShowRolePopover(false);
                }}
              >
                {role}
              </CommandItem>
            ))}
        </CommandGroup>
      </Command>
    </PopoverContent>
  </Popover>
</div>
```

**Alternative (simpler):** Use HTML5 datalist if Command component is overkill:
```tsx
<input
  type="text"
  value={roleInputValue}
  onChange={(e) => setRoleInputValue(e.target.value)}
  list="roles-datalist"
  className="w-full px-3 py-2 border rounded-md"
/>
<datalist id="roles-datalist">
  {existingRoles.map(role => (
    <option key={role} value={role} />
  ))}
</datalist>
```

**Why these patterns:**
- Distinct query prevents duplicate role suggestions
- Autocomplete reduces typos ("Ingénieur du son" vs "Ingénieur Son")
- User can still type custom role (not restricted to list)
- HTML5 datalist is simpler fallback if Command component too complex
- Query is lightweight (just distinct roles, no joins)
  </action>
  <verify>
```bash
# getRoles endpoint exists
grep "getRoles:" packages/server/src/routers/clients.ts

# Autocomplete integrated (check for either Popover or datalist)
grep -E "(Popover|datalist)" packages/client/src/components/CompanyMembersModal.tsx

# TypeScript check passes
pnpm check

# Build succeeds
cd packages/client && pnpm build
```
  </verify>
  <done>
- getRoles endpoint added returning distinct roles
- Role autocomplete integrated (Popover or datalist)
- User can select existing role or type new one
- TypeScript compilation 0 errors
- Production build succeeds
  </done>
</task>

</tasks>

<verification>
**Manual testing checklist:**

1. **Individual view → Companies:**
   - Open individual client (e.g., "Alexandre Grand")
   - Click "Entreprises" indicator
   - Modal shows companies they belong to
   - Verify company names, roles, primary badges display correctly

2. **Add company to individual:**
   - Click "Ajouter une entreprise" in modal
   - Dropdown shows ONLY company-type clients
   - Type role → autocomplete suggests existing roles
   - Submit → company appears in list

3. **Role autocomplete:**
   - Start typing "Ing..." → suggests "Ingénieur du son"
   - Select suggestion → role field populated
   - Try typing new role → still works (not restricted)

4. **Bidirectional consistency:**
   - Add member to company A from company view
   - Open that member's individual view → see company A in their list
   - Remove from either view → disappears from both

**Automated verification:**
```bash
# Backend complete
pnpm check
grep "getCompanies:" packages/server/src/routers/clients.ts
grep "getRoles:" packages/server/src/routers/clients.ts

# Frontend integrated
grep "getCompanies.useQuery" packages/client/src/components/CompanyMembersModal.tsx
grep "getRoles.useQuery" packages/client/src/components/CompanyMembersModal.tsx

# Build succeeds
cd packages/client && pnpm build
```
</verification>

<success_criteria>
- ✅ getCompanies endpoint added and returns correct data
- ✅ getRoles endpoint added returning distinct roles
- ✅ Modal uses getCompanies when viewing individual client
- ✅ Dropdown filters correctly (individuals for company, companies for individual)
- ✅ Role autocomplete suggests existing roles
- ✅ Mutation parameters swap correctly based on view direction
- ✅ Bidirectional UI works (add/remove from either view updates both)
- ✅ TypeScript compilation 0 errors
- ✅ Production build succeeds
- ✅ Manual testing confirms all scenarios work
</success_criteria>

<output>
After completion, create `.planning/phases/25-gestion-relations-client-entreprise/25-02-SUMMARY.md` documenting:
- getCompanies endpoint implementation
- getRoles endpoint for autocomplete
- Modal updates for individual view
- Role autocomplete UI pattern used (Popover or datalist)
- Any edge cases discovered during testing
- Final verification results
</output>
