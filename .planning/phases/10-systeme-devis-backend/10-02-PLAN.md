---
phase: 10-systeme-devis-backend
plan: 2
type: execute
---

<objective>
Implement tRPC router for quote management with CRUD operations, state machine transitions, and quote-to-project conversion logic.

Purpose: Provide backend API for complete quote lifecycle management from creation through acceptance to project conversion. This enables frontend (Phase 11) to interact with quotes system.
Output: Fully functional quotes tRPC router with 10+ endpoints, state machine validation, and atomic conversion logic.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-systeme-devis-backend/DISCOVERY.md
@.planning/phases/10-systeme-devis-backend/10-01-SUMMARY.md

**Existing router patterns to follow:**
@packages/server/src/routers/invoices.ts
@packages/server/src/routers/clients.ts
@packages/server/src/routers/projects.ts

**Prior decisions affecting this phase:**
- tRPC 11 with zod validation (established architecture)
- protectedProcedure requires authentication (ctx.userId, ctx.organizationId)
- ctx.getTenantDb() for tenant-specific database access
- State machine pattern from DISCOVERY.md (7 states with defined transitions)
- Calculated expiration (no cron jobs - check expiresAt in queries)
- Database transactions for atomic operations (quote conversion)

**From DISCOVERY.md:**
- State transitions: draft→sent, sent→accepted/rejected/expired, accepted→converted_to_project
- Quote number auto-generation (format: Q-2026-0001)
- Conversion creates project with budget=quote.total, links via convertedToProjectId
- Only accepted quotes can be converted
- Prevent duplicate conversion (check convertedToProjectId)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quotes router with CRUD endpoints</name>
  <files>packages/server/src/routers/quotes.ts, packages/server/src/routers/_app.ts</files>
  <action>
Create new quotes router with basic CRUD operations:

1. **Create file** `packages/server/src/routers/quotes.ts`

2. **Import dependencies:**
   ```typescript
   import { router, protectedProcedure } from '../_core/trpc';
   import { z } from 'zod';
   import { quotes, quoteItems, clients, projects } from '@rsm/database/tenant';
   import { eq, and, desc, sql } from 'drizzle-orm';
   import { TRPCError } from '@trpc/server';
   ```

3. **Implement CRUD endpoints:**
   - `list`: Query with filters (status, clientId), pagination, order by createdAt DESC
     - Return virtual field `isExpired` calculated from expiresAt timestamp
     - Return virtual field `displayStatus` (shows 'expired' if isExpired=true)
   - `get`: Fetch single quote by ID with quote_items (use `with: { items: true, client: true }`)
   - `create`: Insert quote + items in transaction
     - Auto-generate quoteNumber (format: Q-YYYY-NNNN, sequence per year)
     - Calculate total from items (sum of amounts)
     - Default status='draft', validityDays=30
     - Input validation: clientId required, items array min 1 item
   - `update`: Update quote fields (only if status='draft')
     - Prevent editing sent/accepted quotes (throw BAD_REQUEST)
     - Recalculate totals if items modified
   - `delete`: Soft delete or hard delete (only if status='draft')

4. **Add router to app:**
   - Export quotesRouter
   - Import in `packages/server/src/routers/_app.ts`
   - Add to appRouter: `quotes: quotesRouter`

Follow invoice router pattern exactly (invoices.ts lines 1-250 approximate). Use same zod schemas for financial validation (decimal precision, non-negative amounts).
  </action>
  <verify>
1. TypeScript compiles: `pnpm --filter server tsc --noEmit`
2. Router exported and added to _app.ts
3. Test create endpoint: Create quote with 2 items, verify totals calculated
4. Test list endpoint: Returns quotes with isExpired field
5. Test get endpoint: Returns quote with items and client
  </verify>
  <done>
- quotes.ts created with 5 CRUD endpoints
- Router integrated into _app.ts
- Quote number generation working
- Total calculation from items correct
- Edit protection for non-draft quotes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement state transition endpoints</name>
  <files>packages/server/src/routers/quotes.ts</files>
  <action>
Add state machine endpoints to quotes router:

1. **send endpoint** (draft → sent):
   ```typescript
   send: protectedProcedure
     .input(z.object({ quoteId: z.number() }))
     .mutation(async ({ ctx, input }) => {
       const tenantDb = await ctx.getTenantDb();

       // Validate current state
       const quote = await tenantDb.query.quotes.findFirst({
         where: eq(quotes.id, input.quoteId)
       });
       if (!quote) throw NOT_FOUND;
       if (quote.status !== 'draft') throw BAD_REQUEST('Only draft quotes can be sent');

       // Calculate expiration date
       const expiresAt = new Date();
       expiresAt.setDate(expiresAt.getDate() + quote.validityDays);

       // Update status
       return await tenantDb.update(quotes)
         .set({ status: 'sent', sentAt: new Date(), expiresAt })
         .where(eq(quotes.id, input.quoteId))
         .returning();
     })
   ```

2. **accept endpoint** (sent → accepted):
   - Validate status='sent' and not expired
   - Update status='accepted', respondedAt=now()

3. **reject endpoint** (sent → rejected):
   - Validate status='sent'
   - Update status='rejected', respondedAt=now()

4. **cancel endpoint** (draft → cancelled):
   - Validate status='draft'
   - Update status='cancelled'

5. **Helper function** for expiration check:
   ```typescript
   const isExpired = (quote: Quote): boolean => {
     if (!quote.expiresAt || quote.status !== 'sent') return false;
     return new Date() > new Date(quote.expiresAt);
   };
   ```

Use pattern from DISCOVERY.md lines 126-158. Include proper error messages for invalid transitions (e.g., "Cannot accept expired quote").
  </action>
  <verify>
1. State transitions validated: send draft→sent, accept sent→accepted, reject sent→rejected, cancel draft→cancelled
2. Expiration prevents acceptance: Send quote, manually set expiresAt to past, verify accept throws error
3. Invalid transitions blocked: Try accept draft (should fail), try send accepted (should fail)
4. Timestamps populated: sentAt on send, respondedAt on accept/reject
  </verify>
  <done>
- 4 state transition endpoints implemented
- State validation prevents invalid transitions
- Expiration logic working correctly
- Timestamps tracked properly
- Error messages clear and helpful
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement quote-to-project conversion endpoint</name>
  <files>packages/server/src/routers/quotes.ts</files>
  <action>
Add convertToProject endpoint with atomic transaction:

```typescript
convertToProject: protectedProcedure
  .input(z.object({ quoteId: z.number() }))
  .mutation(async ({ ctx, input }) => {
    const tenantDb = await ctx.getTenantDb();

    // Use database transaction for atomicity
    return await tenantDb.transaction(async (tx) => {
      // 1. Fetch quote with validation
      const quote = await tx.query.quotes.findFirst({
        where: eq(quotes.id, input.quoteId),
        with: { client: true, items: true }
      });

      if (!quote) {
        throw new TRPCError({ code: 'NOT_FOUND', message: 'Quote not found' });
      }

      // 2. Validate quote state
      if (quote.status !== 'accepted') {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Only accepted quotes can be converted to projects'
        });
      }

      if (quote.convertedToProjectId) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Quote already converted to project'
        });
      }

      // 3. Create project from quote
      const [project] = await tx.insert(projects).values({
        clientId: quote.clientId,
        name: `Project from Quote ${quote.quoteNumber}`,
        description: quote.notes || `Converted from quote ${quote.quoteNumber}`,
        status: 'pre_production',
        budget: quote.total, // Quote total becomes project budget
        startDate: new Date(),
      }).returning();

      // 4. Update quote status and link project
      await tx.update(quotes)
        .set({
          status: 'converted_to_project',
          convertedToProjectId: project.id,
          convertedAt: new Date(),
        })
        .where(eq(quotes.id, input.quoteId));

      return { project, quote };
    });
  })
```

Follow exact pattern from DISCOVERY.md lines 452-507. Use database transaction to ensure atomicity (if project creation fails, quote status not updated).

Add validation:
- Quote must be 'accepted' status
- Quote not already converted (convertedToProjectId is null)
- Quote exists

Return both project and updated quote in response for frontend to show success confirmation.
  </action>
  <verify>
1. Transaction atomicity: Mock project creation failure, verify quote status unchanged
2. Validation works: Try convert draft quote (fails), try convert already-converted quote (fails)
3. Project created correctly: budget=quote.total, clientId matches, status='pre_production'
4. Quote updated: status='converted_to_project', convertedToProjectId set, convertedAt timestamp
5. Test full workflow: create quote → send → accept → convert → verify project exists
  </verify>
  <done>
- convertToProject endpoint implemented with transaction
- All validations working (status, duplicate conversion)
- Project creation follows mapping from DISCOVERY.md
- Quote updated with conversion tracking
- Error handling comprehensive
- Full quote→project workflow tested
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compilation succeeds: `pnpm --filter server tsc --noEmit`
- [ ] All endpoints exported in quotes router
- [ ] Router added to _app.ts
- [ ] State machine transitions validated (only valid transitions allowed)
- [ ] Quote-to-project conversion atomic (transaction rollback on failure)
- [ ] No console errors or warnings
</verification>

<success_criteria>
- quotes router with 9+ endpoints (CRUD + state transitions + conversion)
- State machine prevents invalid transitions
- Quote number auto-generation working
- Expiration logic calculated correctly
- Conversion creates project atomically with proper budget mapping
- All validations in place (status checks, duplicate prevention)
- Router ready for frontend integration (Phase 11)
</success_criteria>

<output>
After completion, create `.planning/phases/10-systeme-devis-backend/10-02-SUMMARY.md`:

# Phase 10 Plan 2: tRPC Router & State Machine Summary

**Complete quote management API with state machine and conversion logic**

## Accomplishments

- Created quotes tRPC router with 9+ endpoints
- Implemented 7-state state machine (draft/sent/accepted/rejected/expired/cancelled/converted_to_project)
- Built atomic quote-to-project conversion with database transactions
- Added quote number auto-generation (Q-YYYY-NNNN format)
- Implemented calculated expiration (no cron jobs required)
- Validation prevents invalid state transitions

## Files Created/Modified

- `packages/server/src/routers/quotes.ts` - Complete quotes router with CRUD, state machine, conversion
- `packages/server/src/routers/_app.ts` - Added quotes router to app

## Decisions Made

[Document any deviations from DISCOVERY.md, error handling patterns, or validation refinements]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for Plan 3 (10-03-PLAN.md): PDF Generation & Testing
</output>
