---
phase: 28-harmonisation-ui-talents
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/routers/musicians.ts
autonomous: true

must_haves:
  truths:
    - "Musicians can be sorted by name, talentType, sessions count, lastSession"
    - "Search filters musicians by name, stageName, email, specialty, genres, instruments"
    - "Stats endpoint returns total, VIP performers, total sessions, last session date"
  artifacts:
    - path: "packages/server/src/routers/musicians.ts"
      provides: "Enhanced musicians router with sorting, filtering, stats"
      min_lines: 300
      exports: ["list with sort/filter", "getStats enhanced", "searchMusicians"]
  key_links:
    - from: "packages/client/src/pages/Talents.tsx"
      to: "trpc.musicians.list"
      via: "useQuery with sort/search params"
      pattern: "trpc\\.musicians\\.list\\.useQuery"
---

<objective>
Enhance musicians backend router to support all UI features needed for harmonization with Clients page.

Purpose: Enable server-side sorting, filtering, search, and comprehensive stats for /talents page
Output: Updated musicians.ts with 6+ new endpoints and enhanced existing ones
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-harmonisation-ui-talents/28-CONTEXT.md

# Reference implementations
@packages/server/src/routers/clients.ts (lines 1-500) - for sorting/filtering patterns
@packages/server/src/routers/musicians.ts (current implementation)

# Schema reference
@packages/database/src/tenant/schema.ts (musicians table)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-side search with debounced filtering</name>
  <files>packages/server/src/routers/musicians.ts</files>
  <action>
**Pattern reference:** Clients.tsx lines 144-147 (searchQuery parameter) + backend implementation pattern

**Modify list endpoint:**
1. Add searchQuery to input schema:
   ```typescript
   input: z.object({
     talentType: z.enum(["musician", "actor"]).optional(),
     searchQuery: z.string().optional(),
     sortField: z.enum(['name', 'talentType', 'sessions', 'lastSession']).optional(),
     sortOrder: z.enum(['asc', 'desc']).optional(),
   }).optional()
   ```

2. Build WHERE clause conditionally:
   - If searchQuery provided, use OR logic across: name, stageName, email, specialty
   - For genres/instruments (JSONB fields), cast to text and use ILIKE: `sql\`genres::text ILIKE '%${searchQuery}%'\``
   - Pattern: `const where = searchQuery ? or(like(musicians.name, \`%${searchQuery}%\`), ...) : undefined`

3. Add ORDER BY clause:
   - Default: name ASC
   - Support sortField + sortOrder from input
   - Sessions/lastSession require LEFT JOIN with sessions table (count sessions, max startTime)

**Why server-side:** Scalability (100+ talents), consistency with /clients, enables future pagination
  </action>
  <verify>
1. Test search API: `curl http://localhost:3001/api/trpc/musicians.list?input={"searchQuery":"guitar"}`
2. Verify JSONB search works (genres/instruments fields)
3. Test sorting: `?input={"sortField":"name","sortOrder":"desc"}`
4. Confirm empty searchQuery returns all musicians
  </verify>
  <done>
- list endpoint accepts searchQuery, sortField, sortOrder parameters
- Search filters across 7 fields (name, stageName, email, specialty, genres, instruments, notes)
- Sorting works on all 4 fields (name, talentType, sessions count, lastSession date)
- TypeScript 0 errors, backend compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhanced stats endpoint with VIP performers and session metrics</name>
  <files>packages/server/src/routers/musicians.ts</files>
  <action>
**Pattern reference:** Clients.tsx stats cards (lines ~200-300) - adapt to musicians context

**Replace getStats endpoint:**
Current returns: total, withEmail, withPhone, withWebsite

New returns:
1. **total**: Total musicians count
2. **vipPerformers**: Musicians with >10 sessions (high-volume performers)
3. **totalSessions**: Sum of all sessions linked to musicians
4. **lastSessionDate**: Most recent session.startTime across all musicians

**Implementation:**
```typescript
getStats: protectedProcedure.query(async ({ ctx }) => {
  const tenantDb = await ctx.getTenantDb();

  // Total count
  const total = await tenantDb.select({ count: sql<number>\`count(*)\` }).from(musicians);

  // Sessions JOIN for VIP and totals
  const sessionStats = await tenantDb
    .select({
      musicianId: sessions.musicianId,
      sessionCount: sql<number>\`count(*)\`,
      lastSession: sql<Date>\`max(${sessions.startTime})\`
    })
    .from(sessions)
    .where(isNotNull(sessions.musicianId))
    .groupBy(sessions.musicianId);

  const vipPerformers = sessionStats.filter(s => s.sessionCount > 10).length;
  const totalSessions = sessionStats.reduce((sum, s) => sum + s.sessionCount, 0);
  const lastSessionDate = sessionStats.reduce((max, s) =>
    s.lastSession > max ? s.lastSession : max, new Date(0)
  );

  return { total: total[0].count, vipPerformers, totalSessions, lastSessionDate };
});
```

**Note:** Ensure sessions table has musicianId column (check schema). If missing, create migration.
  </action>
  <verify>
1. Call stats endpoint: `trpc.musicians.getStats.useQuery()` in frontend
2. Verify 4 stats returned with correct types
3. Test with 0 musicians, 1 musician, 10+ musicians
4. Confirm VIP threshold logic (>10 sessions)
  </verify>
  <done>
- getStats returns 4 metrics: total, vipPerformers, totalSessions, lastSessionDate
- VIP logic correctly identifies high-volume performers
- Stats match actual data in database
- TypeScript types exported correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Add musicians-to-sessions relationship enrichment</name>
  <files>packages/server/src/routers/musicians.ts</files>
  <action>
**Context:** Talents need session counts and last session date for sorting/display (like clients.sessionsCount)

**Add enriched list endpoint variant:**
Create new endpoint `listWithStats` that returns musicians with computed fields:
- `sessionsCount`: Number of sessions for this musician
- `lastSessionAt`: Date of most recent session
- `totalRevenue`: Optional - sum of invoices related to musician sessions

**Implementation:**
```typescript
listWithStats: protectedProcedure
  .input(z.object({
    searchQuery: z.string().optional(),
    sortField: z.enum(['name', 'talentType', 'sessions', 'lastSession']).optional(),
    sortOrder: z.enum(['asc', 'desc']).optional(),
  }).optional())
  .query(async ({ ctx, input }) => {
    const tenantDb = await ctx.getTenantDb();

    // Base query with LEFT JOIN sessions
    const musiciansWithStats = await tenantDb
      .select({
        ...musicians,
        sessionsCount: sql<number>\`COUNT(DISTINCT ${sessions.id})\`,
        lastSessionAt: sql<Date | null>\`MAX(${sessions.startTime})\`
      })
      .from(musicians)
      .leftJoin(sessions, eq(sessions.musicianId, musicians.id))
      .groupBy(musicians.id);

    // Apply search filter
    // Apply sorting
    // Return enriched data
  });
```

**Why separate endpoint:** list remains lightweight, listWithStats used by Talents.tsx for richer display
  </action>
  <verify>
1. Test listWithStats: returns musicians with sessionsCount and lastSessionAt fields
2. Verify LEFT JOIN doesn't exclude musicians with 0 sessions
3. Test sorting by sessions (DESC should show most active first)
4. Confirm TypeScript types include new fields
  </verify>
  <done>
- listWithStats endpoint created and functional
- Returns enriched musician data with session metrics
- Sorting by sessions/lastSession works correctly
- 0-session musicians still appear in results
  </done>
</task>

</tasks>

<verification>
**Backend functionality checks:**

1. **Search endpoint:**
   - Search "guitar" finds musicians with guitar in instruments
   - Search "jazz" finds musicians with jazz in genres
   - Search partial names works (case-insensitive)

2. **Sorting endpoint:**
   - Sort by name ASC/DESC works
   - Sort by sessions DESC shows high-volume performers first
   - Sort by lastSession DESC shows recently active first

3. **Stats endpoint:**
   - Returns 4 metrics with correct types
   - VIP threshold logic accurate
   - Total sessions matches actual count

4. **Enriched list:**
   - sessionsCount accurate for each musician
   - lastSessionAt shows correct date
   - Musicians with 0 sessions included

**TypeScript checks:**
```bash
pnpm --filter server check
```

**Backend compilation:**
```bash
pnpm --filter server build
```
</verification>

<success_criteria>
- [ ] musicians.list accepts searchQuery, sortField, sortOrder parameters
- [ ] Search filters across 7 fields (name, stageName, email, specialty, genres, instruments, notes)
- [ ] Sorting works on 4 fields (name, talentType, sessions, lastSession)
- [ ] getStats returns 4 metrics: total, vipPerformers, totalSessions, lastSessionDate
- [ ] listWithStats endpoint returns enriched data (sessionsCount, lastSessionAt)
- [ ] TypeScript 0 errors in server package
- [ ] Backend compiles successfully
- [ ] All endpoints tested via tRPC client
</success_criteria>

<output>
After completion, create `.planning/phases/28-harmonisation-ui-talents/28-01-SUMMARY.md`
</output>
