---
phase: 3.8.1-fix-chatbot-sessionid-persistence-bug
plan: 01
type: execute
---

<objective>
Fix critical frontend bug where sessionId is not persisted between chatbot messages, causing complete memory loss.

Purpose: Restore chatbot memory functionality so multi-turn conversations work correctly before marketing launch.
Output: Working chatbot that maintains conversation context across messages, validated in production.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3.8-verifier-chatbot-memoire/3.8-01-SUMMARY.md

**Bug discovered in Phase 3.8 testing:**
- Turn 1: Created client "John Smith" (sessionId: `session_1766975522813_6c7oygc34`)
- Turn 2: Asked "What was the name I just mentioned?"
- Response: "You didn't mention any specific name" (NEW sessionId: `session_1766975657754_e8y9f2hfk`)
- **Root cause**: Frontend never sends sessionId to backend, each message creates new session

**Network analysis (Phase 3.8):**
- Turn 1 request: `{"message": "Create a client..."}`  ❌ Missing sessionId
- Turn 1 response: `{"response": "...", "sessionId": "session_1766975522813_6c7oygc34"}`
- Turn 2 request: `{"message": "What was the name..."}`  ❌ Missing sessionId (should send session_1766975522813_6c7oygc34)
- Turn 2 response: New sessionId generated = memory loss

**Backend implementation (packages/server/src/routers/ai.ts:30-67):**
Backend is CORRECT - it expects sessionId and loads conversation history when provided:
```typescript
chat: protectedProcedure
  .input(z.object({
    message: z.string().min(1).max(5000),
    sessionId: z.string().optional(), // ✅ Backend expects this
  }))
  .mutation(async ({ ctx, input }) => {
    const sessionId = inputSessionId || `session_${Date.now()}_...`; // Line 47

    // Load conversation history if session exists
    if (inputSessionId) { // Line 57
      const existingConversations = await tenantDb
        .select()
        .from(aiConversations)
        .where(eq(aiConversations.sessionId, inputSessionId))
        .limit(1);
      if (existingConversations.length > 0) {
        conversationHistory = JSON.parse(existingConversations[0].messages);
      }
    }
  });
```

**Frontend bug (packages/client/src/components/AIAssistant.tsx:152-154):**
```typescript
const response = await chatMutation.mutateAsync({
  message: userMessage.content,
  // ❌ BUG: sessionId is NEVER sent!
});

// Backend returns sessionId but frontend NEVER stores it:
const assistantMessage: Message = {
  content: response.response, // ✅ Used
  // ❌ response.sessionId is IGNORED!
};
```

**Fix required:**
1. Add state: `const [sessionId, setSessionId] = useState<string | null>(null)`
2. Send sessionId in request: `sessionId: sessionId || undefined`
3. Store sessionId from response: `setSessionId(response.sessionId)`

**Files to modify:**
@packages/client/src/components/AIAssistant.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix AIAssistant sessionId persistence</name>
  <files>packages/client/src/components/AIAssistant.tsx</files>
  <action>
    Fix the chatbot sessionId persistence bug in AIAssistant.tsx:

    1. **Add sessionId state** (after existing state declarations around line 33):
       ```typescript
       const [sessionId, setSessionId] = useState<string | null>(null);
       ```

    2. **Send sessionId in chatMutation request** (line 152-154):
       ```typescript
       const response = await chatMutation.mutateAsync({
         message: userMessage.content,
         sessionId: sessionId || undefined, // ✅ Send existing sessionId
       });
       ```

    3. **Store sessionId from response** (after line 163, before cache invalidation):
       ```typescript
       setMessages(prev => [...prev, assistantMessage]);

       // ✅ Store sessionId from response for subsequent messages
       if (response.sessionId) {
         setSessionId(response.sessionId);
       }

       // Invalidate tRPC caches based on actions...
       ```

    **Important notes:**
    - Use `sessionId || undefined` (not `sessionId || null`) - tRPC expects optional string, not null
    - Store sessionId AFTER adding assistant message but BEFORE cache invalidation
    - Don't modify any other logic (messages, cache invalidation, error handling all stay the same)
    - The sessionId will persist across all messages in the conversation until component unmounts
    - When component remounts (page refresh), new conversation starts (intentional - matches typical chat UX)

    **What NOT to do:**
    - Don't add sessionId to Message interface (it's not part of UI state, just request state)
    - Don't persist sessionId to localStorage (chat should reset on refresh for privacy)
    - Don't modify backend (it's already correct)
  </action>
  <verify>
    - TypeScript compilation succeeds: `pnpm --filter @rsm/client build`
    - No ESLint errors introduced
    - Code diff shows exactly 3 changes: state declaration, request parameter, response storage
  </verify>
  <done>
    - sessionId state added to AIAssistant component
    - sessionId sent in chatMutation.mutateAsync calls
    - sessionId stored from response.sessionId
    - Build succeeds without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Deploy fix to production</name>
  <files>packages/client/src/components/AIAssistant.tsx</files>
  <action>
    Build and deploy the fixed frontend to production:

    1. **Build client**:
       ```bash
       cd /Users/marabook_m1/Documents/APP_HOME/CascadeProjects/windsurf-project/recording-studio-manager-hybrid
       pnpm --filter @rsm/client build
       ```

    2. **Deploy to production via rsync**:
       ```bash
       rsync -avz --delete \
         packages/client/dist/ \
         vps-n8n:/root/recording-studio-manager-hybrid/packages/client/dist/
       ```

    3. **Restart client container**:
       ```bash
       ssh vps-n8n "cd /root/recording-studio-manager-hybrid && docker-compose restart client"
       ```

    4. **Verify deployment**:
       ```bash
       curl -I https://recording-studio-manager.com
       ```
       Expected: HTTP 200, no errors

    **Deployment pattern from Phase 3.6:**
    This follows the established deployment pattern - build locally, rsync dist/, restart container.
  </action>
  <verify>
    - Build completes successfully
    - Rsync transfer completes without errors
    - Container restart succeeds
    - curl returns HTTP 200
    - No browser console errors on page load
  </verify>
  <done>
    - Client built with sessionId fix
    - Deployed to production VPS
    - Container restarted successfully
    - Production site accessible
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Chatbot sessionId persistence fix deployed to production</what-built>
  <how-to-verify>
    Test the fix with a 2-turn conversation in production:

    1. **Navigate to production dashboard**:
       - Visit: https://recording-studio-manager.com/dashboard
       - Log in if needed (test-validation-1766731401390@recording-studio-manager.com)

    2. **Open AI chatbot** (floating window on right side)

    3. **Turn 1 - Create client**:
       - Send message: "Create a client named Jane Doe with email jane@test.com"
       - Expected: Chatbot confirms client created successfully
       - Note the response (should mention client creation)

    4. **Turn 2 - Test memory (CRITICAL)**:
       - Send message: "What was the name I just mentioned?"
       - Expected: ✅ Chatbot responds "Jane Doe" or references the name from Turn 1
       - FAILURE if: ❌ Chatbot says "You didn't mention any specific name"

    5. **Verify in browser DevTools** (optional but recommended):
       - Open Network tab
       - Find the POST request to `/api/trpc/ai.chat` for Turn 2
       - Check request payload - should contain `sessionId` field
       - Confirm sessionId value matches between Turn 1 response and Turn 2 request

    **Success criteria:**
    - Turn 2 response demonstrates memory of Turn 1
    - Chatbot correctly recalls "Jane Doe" when asked
    - No "You didn't mention..." amnesia response
    - (Optional) Network tab shows sessionId in Turn 2 request
  </how-to-verify>
  <resume-signal>Type "approved" if chatbot remembers Turn 1, or describe the memory failure if it still occurs</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] AIAssistant.tsx modified with sessionId state management
- [ ] Client builds without TypeScript errors
- [ ] Deployed to production successfully
- [ ] 2-turn conversation test passes (chatbot remembers Turn 1 in Turn 2)
- [ ] No browser console errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Chatbot memory works in production (2-turn test successful)
- Phase 3.8.1 complete - ready to re-run Phase 3.8 full 10-turn test
- No errors or regressions introduced
</success_criteria>

<output>
After completion, create `.planning/phases/3.8.1-fix-chatbot-sessionid-persistence-bug/3.8.1-01-SUMMARY.md`:

# Phase 3.8.1 Plan 1: Fix Chatbot SessionId Persistence Summary

**Chatbot memory restored - sessionId now persists across messages**

## Accomplishments

- Fixed frontend sessionId state management in AIAssistant.tsx
- Added sessionId state, send in requests, store from responses
- Deployed fix to production
- Validated 2-turn conversation maintains memory

## Files Modified

- `packages/client/src/components/AIAssistant.tsx` - Added sessionId state persistence (3 line changes)

## Bug Fix Details

**Before (broken):**
```typescript
const response = await chatMutation.mutateAsync({
  message: userMessage.content,
  // ❌ Missing sessionId
});
// ❌ response.sessionId ignored
```

**After (fixed):**
```typescript
const [sessionId, setSessionId] = useState<string | null>(null);

const response = await chatMutation.mutateAsync({
  message: userMessage.content,
  sessionId: sessionId || undefined, // ✅ Send existing sessionId
});

if (response.sessionId) {
  setSessionId(response.sessionId); // ✅ Store for next message
}
```

## Production Validation

- Turn 1: "Create client Jane Doe" → ✅ Client created
- Turn 2: "What was the name I just mentioned?" → ✅ "Jane Doe" (memory works!)
- Network analysis: sessionId consistent across requests
- No browser console errors

## Issues Encountered

[None OR describe any deployment issues]

## Next Step

Phase 3.8.1 complete - chatbot memory bug fixed.

**Ready to re-run Phase 3.8** (full 10-turn conversation test) to validate memory works across extended conversations.

After Phase 3.8 passes → proceed to Phase 4 (Marketing Foundation).
</output>
