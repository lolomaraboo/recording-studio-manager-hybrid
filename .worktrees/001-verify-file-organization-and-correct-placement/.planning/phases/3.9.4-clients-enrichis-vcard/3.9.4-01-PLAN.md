# Phase 3.9.4-01: Clients Enrichis - Schema + Photos/Logos

**Date:** 2025-12-31
**Phase:** 3.9.4 - Clients enrichis compatible vCard
**Plan:** 01 (Schema + Upload)
**Estimated Context:** ~45-50%

---

## Objective

Enrichir le système de contacts clients pour supporter le standard vCard 4.0 (RFC 6350), avec photos/avatars pour particuliers, logos pour entreprises, contacts multiples pour groupes, et champs personnalisés illimités. Stockage local VPS avec isolation par tenant et middleware de sécurité.

**User Requirements:**
- Champs compatibles vCard 4.0 (nom structuré, téléphones multiples, emails multiples, adresses complètes)
- Photos/avatars pour particuliers (stockage local VPS)
- Logos pour entreprises/groupes (stockage local VPS)
- Contacts multiples pour comptes entreprise/groupe
- Champs personnalisés illimités (JSON flexible)
- Isolation par tenant (stockage: `/uploads/tenant_X/`)
- Middleware sécurité (vérification accès tenant)

---

## Execution Context

@packages/database/src/tenant/schema.ts (clients table)
@packages/server/src/routes/upload.ts (upload routes)
@packages/server/src/middleware/ (tenant security)
@packages/client/src/pages/Clients.tsx (UI)
@packages/client/src/pages/ClientDetail.tsx (UI)

**Tech Stack:**
- PostgreSQL (Drizzle ORM)
- Node.js + Express (upload + middleware)
- Multer (multipart/form-data)
- React 19.1 + TypeScript
- Nginx (static file serving)

**Standards:**
- vCard 4.0 (RFC 6350)
- Multi-tenant isolation (database-per-tenant + storage-per-tenant)

---

## Context

**Current Schema (clients table):**
```typescript
// packages/database/src/tenant/schema.ts:18-35
{
  id, userId, name, artistName, email, phone, type,
  address, city, country, notes, isVip, isActive,
  portalAccess, createdAt, updatedAt
}
```

**Current Upload System:**
- Uses Cloudinary for audio/images (external service)
- Organization-based folders: `logos/org_${organizationId}`
- No tenant-isolated local storage yet

**Migration to Local Storage:**
- Stockage: `/var/www/recording-studio-manager/uploads/tenant_X/{avatars,logos}`
- URLs: `https://recording-studio-manager.com/uploads/tenant_1/avatars/client-123.jpg`
- Nginx static serving with Express middleware security

**vCard 4.0 Standard Fields (to add):**
- Structured name: firstName, lastName, middleName, prefix, suffix
- Multiple contacts: phones[], emails[], websites[]
- Complete address: street, postalCode, region
- Personal: birthday, gender
- Photos: avatarUrl (individuals), logoUrl (companies)
- Custom: customFields JSON

---

## Tasks

### Task 1: Database Schema Migration (AUTO)

**Objective:** Add vCard-compatible fields to clients table and create clientContacts table.

**Actions:**

1. Create migration file `packages/database/migrations/YYYY-MM-DD-clients-vcard-fields.ts`:

```typescript
import { sql } from 'drizzle-orm';
import { db } from '../src/connection';

export async function up() {
  // Add new columns to clients table
  await db.execute(sql`
    ALTER TABLE clients
    ADD COLUMN first_name VARCHAR(100),
    ADD COLUMN last_name VARCHAR(100),
    ADD COLUMN middle_name VARCHAR(100),
    ADD COLUMN prefix VARCHAR(20),
    ADD COLUMN suffix VARCHAR(20),
    ADD COLUMN avatar_url VARCHAR(500),
    ADD COLUMN logo_url VARCHAR(500),
    ADD COLUMN phones JSONB DEFAULT '[]',
    ADD COLUMN emails JSONB DEFAULT '[]',
    ADD COLUMN websites JSONB DEFAULT '[]',
    ADD COLUMN street VARCHAR(255),
    ADD COLUMN postal_code VARCHAR(20),
    ADD COLUMN region VARCHAR(100),
    ADD COLUMN birthday DATE,
    ADD COLUMN gender VARCHAR(20),
    ADD COLUMN custom_fields JSONB DEFAULT '[]';
  `);

  // Create clientContacts table for company/group contacts
  await db.execute(sql`
    CREATE TABLE client_contacts (
      id SERIAL PRIMARY KEY,
      client_id INTEGER NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
      first_name VARCHAR(100) NOT NULL,
      last_name VARCHAR(100) NOT NULL,
      title VARCHAR(100),
      email VARCHAR(255),
      phone VARCHAR(50),
      is_primary BOOLEAN DEFAULT false,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );
  `);

  // Create index for faster lookups
  await db.execute(sql`
    CREATE INDEX idx_client_contacts_client_id ON client_contacts(client_id);
  `);
}

export async function down() {
  await db.execute(sql`DROP TABLE IF EXISTS client_contacts;`);

  await db.execute(sql`
    ALTER TABLE clients
    DROP COLUMN first_name,
    DROP COLUMN last_name,
    DROP COLUMN middle_name,
    DROP COLUMN prefix,
    DROP COLUMN suffix,
    DROP COLUMN avatar_url,
    DROP COLUMN logo_url,
    DROP COLUMN phones,
    DROP COLUMN emails,
    DROP COLUMN websites,
    DROP COLUMN street,
    DROP COLUMN postal_code,
    DROP COLUMN region,
    DROP COLUMN birthday,
    DROP COLUMN gender,
    DROP COLUMN custom_fields;
  `);
}
```

2. Update `packages/database/src/tenant/schema.ts`:

```typescript
export const clients = pgTable("clients", {
  // Existing fields
  id: serial("id").primaryKey(),
  userId: integer("user_id"),
  name: varchar("name", { length: 255 }).notNull(),
  artistName: varchar("artist_name", { length: 255 }),
  email: varchar("email", { length: 255 }),
  phone: varchar("phone", { length: 50 }),
  type: varchar("type", { length: 50 }).notNull().default("individual"),
  address: text("address"),
  city: varchar("city", { length: 100 }),
  country: varchar("country", { length: 100 }),
  notes: text("notes"),
  isVip: boolean("is_vip").notNull().default(false),
  isActive: boolean("is_active").notNull().default(true),
  portalAccess: boolean("portal_access").notNull().default(false),

  // NEW: vCard 4.0 compatible fields
  firstName: varchar("first_name", { length: 100 }),
  lastName: varchar("last_name", { length: 100 }),
  middleName: varchar("middle_name", { length: 100 }),
  prefix: varchar("prefix", { length: 20 }), // Mr., Mrs., Dr., etc.
  suffix: varchar("suffix", { length: 20 }), // Jr., III, etc.
  avatarUrl: varchar("avatar_url", { length: 500 }), // For individuals
  logoUrl: varchar("logo_url", { length: 500 }), // For companies
  phones: jsonb("phones").$type<Array<{type: string; number: string}>>().default([]),
  emails: jsonb("emails").$type<Array<{type: string; email: string}>>().default([]),
  websites: jsonb("websites").$type<Array<{type: string; url: string}>>().default([]),
  street: varchar("street", { length: 255 }),
  postalCode: varchar("postal_code", { length: 20 }),
  region: varchar("region", { length: 100 }),
  birthday: date("birthday"),
  gender: varchar("gender", { length: 20 }),
  customFields: jsonb("custom_fields").$type<Array<{label: string; type: string; value: any}>>().default([]),

  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const clientContacts = pgTable("client_contacts", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull().references(() => clients.id, { onDelete: "cascade" }),
  firstName: varchar("first_name", { length: 100 }).notNull(),
  lastName: varchar("last_name", { length: 100 }).notNull(),
  title: varchar("title", { length: 100 }), // Job title
  email: varchar("email", { length: 255 }),
  phone: varchar("phone", { length: 50 }),
  isPrimary: boolean("is_primary").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export type ClientContact = typeof clientContacts.$inferSelect;
export type InsertClientContact = typeof clientContacts.$inferInsert;
```

3. Run migration:
```bash
pnpm run db:migrate
```

**Verification:**
- Migration runs without errors
- New columns exist in clients table
- clientContacts table created with foreign key
- JSON default values work

---

### Task 2: Tenant-Isolated File Upload System (AUTO)

**Objective:** Create local VPS storage with tenant isolation and security middleware.

**Actions:**

1. Create upload directories structure on VPS:
```bash
ssh vps-n8n "mkdir -p /var/www/recording-studio-manager/uploads/{tenant_1,tenant_2,tenant_3,tenant_4,tenant_5}/{avatars,logos}"
ssh vps-n8n "chown -R www-data:www-data /var/www/recording-studio-manager/uploads"
ssh vps-n8n "chmod -R 755 /var/www/recording-studio-manager/uploads"
```

2. Create Nginx configuration for static serving:
```nginx
# Add to /etc/nginx/sites-available/recording-studio-manager

location /uploads/ {
    alias /var/www/recording-studio-manager/uploads/;

    # Proxy to Express for security check
    proxy_pass http://localhost:3000/api/uploads/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # Cache settings
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

3. Create tenant security middleware `packages/server/src/middleware/tenantFileAccess.ts`:

```typescript
import { Request, Response, NextFunction } from 'express';
import { getSessionUser } from '../lib/session';
import { db } from '@rsm/database';
import { tenantDatabases } from '@rsm/database/master/schema';
import { eq } from 'drizzle-orm';

export async function validateTenantFileAccess(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    // Extract tenant ID from URL: /uploads/tenant_X/...
    const match = req.path.match(/^\/tenant_(\d+)\//);
    if (!match) {
      return res.status(400).json({ error: 'Invalid file path' });
    }

    const requestedTenantId = parseInt(match[1]);

    // Get authenticated user's organization
    const user = await getSessionUser(req);
    if (!user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    // Get user's tenant database
    const [userTenant] = await db
      .select()
      .from(tenantDatabases)
      .where(eq(tenantDatabases.organizationId, user.organizationId))
      .limit(1);

    if (!userTenant) {
      return res.status(403).json({ error: 'No tenant found' });
    }

    // Extract tenant ID from database name (e.g., "tenant_1" -> 1)
    const userTenantId = parseInt(userTenant.databaseName.split('_')[1]);

    // Verify user can only access their own tenant's files
    if (userTenantId !== requestedTenantId) {
      console.warn(
        `[Security] User ${user.id} attempted to access tenant ${requestedTenantId} files (belongs to tenant ${userTenantId})`
      );
      return res.status(403).json({ error: 'Access denied' });
    }

    // Access granted
    next();
  } catch (error) {
    console.error('[TenantFileAccess] Error:', error);
    res.status(500).json({ error: 'File access verification failed' });
  }
}
```

4. Create upload service `packages/server/src/utils/local-upload-service.ts`:

```typescript
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';

const UPLOADS_BASE = process.env.UPLOADS_PATH || '/var/www/recording-studio-manager/uploads';

export interface UploadResult {
  url: string;
  filePath: string;
  fileName: string;
  bytes: number;
}

/**
 * Upload file to local VPS storage with tenant isolation
 */
export async function uploadLocalFile(
  buffer: Buffer,
  originalFilename: string,
  tenantId: number,
  folder: 'avatars' | 'logos'
): Promise<UploadResult> {
  // Generate unique filename
  const ext = path.extname(originalFilename);
  const hash = crypto.randomBytes(16).toString('hex');
  const fileName = `${Date.now()}-${hash}${ext}`;

  // Construct paths
  const tenantFolder = `tenant_${tenantId}`;
  const relativePath = `${tenantFolder}/${folder}/${fileName}`;
  const absolutePath = path.join(UPLOADS_BASE, relativePath);

  // Ensure directory exists
  await fs.mkdir(path.dirname(absolutePath), { recursive: true });

  // Write file
  await fs.writeFile(absolutePath, buffer);

  // Generate public URL
  const url = `/uploads/${relativePath}`;

  return {
    url,
    filePath: relativePath,
    fileName,
    bytes: buffer.length,
  };
}

/**
 * Delete file from local storage
 */
export async function deleteLocalFile(filePath: string): Promise<void> {
  const absolutePath = path.join(UPLOADS_BASE, filePath);

  try {
    await fs.unlink(absolutePath);
    console.log('[LocalUpload] File deleted:', filePath);
  } catch (error: any) {
    if (error.code !== 'ENOENT') {
      throw error;
    }
    // File doesn't exist, ignore
  }
}
```

5. Update upload routes `packages/server/src/routes/upload.ts`:

```typescript
import { Router, Request } from 'express';
import multer from 'multer';
import { uploadLocalFile, deleteLocalFile } from '../utils/local-upload-service';
import { validateTenantFileAccess } from '../middleware/tenantFileAccess';
import { getSessionUser } from '../lib/session';
import { db } from '@rsm/database';
import { tenantDatabases } from '@rsm/database/master/schema';
import { eq } from 'drizzle-orm';

const router = Router();

// Configure multer for memory storage
const uploadAvatar = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB max
  },
  fileFilter: (_req, file, cb) => {
    const allowedMimes = [
      'image/png',
      'image/jpeg',
      'image/jpg',
      'image/webp',
    ];

    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error(`Invalid file type: ${file.mimetype}. Only images allowed.`));
    }
  },
});

/**
 * Upload avatar/logo endpoint
 * POST /api/upload/avatar
 * POST /api/upload/logo
 */
router.post('/avatar', uploadAvatar.single('file'), async (req: any, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file provided' });
    }

    // Get user's tenant ID
    const user = await getSessionUser(req);
    if (!user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const [tenant] = await db
      .select()
      .from(tenantDatabases)
      .where(eq(tenantDatabases.organizationId, user.organizationId))
      .limit(1);

    if (!tenant) {
      return res.status(403).json({ error: 'No tenant found' });
    }

    const tenantId = parseInt(tenant.databaseName.split('_')[1]);

    // Upload to local storage
    const result = await uploadLocalFile(
      req.file.buffer,
      req.file.originalname,
      tenantId,
      'avatars'
    );

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    console.error('[Upload] Avatar upload failed:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Upload failed',
    });
  }
});

router.post('/logo', uploadAvatar.single('file'), async (req: any, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file provided' });
    }

    const user = await getSessionUser(req);
    if (!user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const [tenant] = await db
      .select()
      .from(tenantDatabases)
      .where(eq(tenantDatabases.organizationId, user.organizationId))
      .limit(1);

    if (!tenant) {
      return res.status(403).json({ error: 'No tenant found' });
    }

    const tenantId = parseInt(tenant.databaseName.split('_')[1]);

    const result = await uploadLocalFile(
      req.file.buffer,
      req.file.originalname,
      tenantId,
      'logos'
    );

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    console.error('[Upload] Logo upload failed:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Upload failed',
    });
  }
});

/**
 * Secure file serving with tenant validation
 * GET /api/uploads/tenant_X/{avatars|logos}/filename.jpg
 */
router.get('/tenant_*', validateTenantFileAccess, async (req, res) => {
  try {
    const filePath = path.join(UPLOADS_BASE, req.path);

    // Check file exists
    await fs.access(filePath);

    // Serve file
    res.sendFile(filePath);
  } catch (error) {
    res.status(404).json({ error: 'File not found' });
  }
});

export default router;
```

6. Register middleware in `packages/server/src/index.ts`:

```typescript
import uploadRoutes from './routes/upload';

// ... existing code ...

app.use('/api/upload', uploadRoutes);
```

**Verification:**
- Upload directories created on VPS
- Permissions correct (www-data)
- Middleware blocks cross-tenant access
- Files uploaded to correct tenant folder
- URLs return 403 for wrong tenant, 200 for correct tenant

---

### Task 3: tRPC Procedures for Clients + Contacts (AUTO)

**Objective:** Add tRPC mutations/queries for new client fields and clientContacts.

**Actions:**

1. Update `packages/server/src/routers/clients.ts`:

```typescript
import { z } from 'zod';
import { clients, clientContacts } from '@rsm/database/tenant/schema';
import { eq, and } from 'drizzle-orm';

// Add to existing clientsRouter

// Schema for client contacts
const clientContactSchema = z.object({
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  title: z.string().optional(),
  email: z.string().email().optional(),
  phone: z.string().optional(),
  isPrimary: z.boolean().default(false),
});

// Get client with contacts
getWithContacts: protectedTenantProcedure
  .input(z.object({ id: z.number() }))
  .query(async ({ ctx, input }) => {
    const [client] = await ctx.tenantDb
      .select()
      .from(clients)
      .where(eq(clients.id, input.id))
      .limit(1);

    if (!client) {
      throw new Error('Client not found');
    }

    const contacts = await ctx.tenantDb
      .select()
      .from(clientContacts)
      .where(eq(clientContacts.clientId, input.id));

    return {
      ...client,
      contacts,
    };
  }),

// Update client with new vCard fields
update: protectedTenantProcedure
  .input(
    z.object({
      id: z.number(),
      // Existing fields
      name: z.string().min(1).optional(),
      artistName: z.string().optional(),
      email: z.string().email().optional(),
      phone: z.string().optional(),
      type: z.enum(['individual', 'company']).optional(),
      // NEW vCard fields
      firstName: z.string().optional(),
      lastName: z.string().optional(),
      middleName: z.string().optional(),
      prefix: z.string().optional(),
      suffix: z.string().optional(),
      avatarUrl: z.string().optional(),
      logoUrl: z.string().optional(),
      phones: z.array(z.object({ type: z.string(), number: z.string() })).optional(),
      emails: z.array(z.object({ type: z.string(), email: z.string() })).optional(),
      websites: z.array(z.object({ type: z.string(), url: z.string() })).optional(),
      street: z.string().optional(),
      postalCode: z.string().optional(),
      region: z.string().optional(),
      birthday: z.string().optional(),
      gender: z.string().optional(),
      customFields: z.array(z.object({ label: z.string(), type: z.string(), value: z.any() })).optional(),
    })
  )
  .mutation(async ({ ctx, input }) => {
    const { id, ...data } = input;

    await ctx.tenantDb
      .update(clients)
      .set({
        ...data,
        updatedAt: new Date(),
      })
      .where(eq(clients.id, id));

    return { success: true };
  }),

// Add contact to client
addContact: protectedTenantProcedure
  .input(
    z.object({
      clientId: z.number(),
      contact: clientContactSchema,
    })
  )
  .mutation(async ({ ctx, input }) => {
    const [newContact] = await ctx.tenantDb
      .insert(clientContacts)
      .values({
        clientId: input.clientId,
        ...input.contact,
      })
      .returning();

    return newContact;
  }),

// Update contact
updateContact: protectedTenantProcedure
  .input(
    z.object({
      id: z.number(),
      contact: clientContactSchema.partial(),
    })
  )
  .mutation(async ({ ctx, input }) => {
    await ctx.tenantDb
      .update(clientContacts)
      .set({
        ...input.contact,
        updatedAt: new Date(),
      })
      .where(eq(clientContacts.id, input.id));

    return { success: true };
  }),

// Delete contact
deleteContact: protectedTenantProcedure
  .input(z.object({ id: z.number() }))
  .mutation(async ({ ctx, input }) => {
    await ctx.tenantDb
      .delete(clientContacts)
      .where(eq(clientContacts.id, input.id));

    return { success: true };
  }),
```

**Verification:**
- tRPC procedures compile without errors
- Can fetch client with contacts
- Can update client with new vCard fields
- Can add/update/delete contacts

---

### Task 4: Frontend UI for Enriched Client Form (AUTO)

**Objective:** Update ClientDetail page to edit all new fields, upload avatar/logo, manage contacts.

**Actions:**

1. Update `packages/client/src/pages/ClientDetail.tsx` (add new sections):

```typescript
import { useState } from 'react';
import { trpc } from '@/lib/trpc';
import { Upload, Plus, Trash2, User, Building2 } from 'lucide-react';

// Add state for new fields
const [avatarFile, setAvatarFile] = useState<File | null>(null);
const [logoFile, setLogoFile] = useState<File | null>(null);
const [contacts, setContacts] = useState<any[]>([]);

// Add upload mutation
const uploadAvatar = trpc.upload.avatar.useMutation();
const uploadLogo = trpc.upload.logo.useMutation();

// Add sections to form:

{/* Avatar/Logo Upload Section */}
<div className="mb-6">
  <h3 className="text-lg font-semibold mb-4">
    {client?.type === 'individual' ? 'Photo' : 'Logo'}
  </h3>

  <div className="flex items-center gap-4">
    {/* Preview */}
    <div className="w-24 h-24 rounded-full bg-muted flex items-center justify-center overflow-hidden">
      {client?.avatarUrl || client?.logoUrl ? (
        <img
          src={client.type === 'individual' ? client.avatarUrl : client.logoUrl}
          alt={client.name}
          className="w-full h-full object-cover"
        />
      ) : (
        <span className="text-4xl text-muted-foreground">
          {client?.type === 'individual' ? (
            <User className="w-12 h-12" />
          ) : (
            <Building2 className="w-12 h-12" />
          )}
        </span>
      )}
    </div>

    {/* Upload Button */}
    <div>
      <input
        type="file"
        id="avatar-upload"
        accept="image/png,image/jpeg,image/jpg,image/webp"
        className="hidden"
        onChange={async (e) => {
          const file = e.target.files?.[0];
          if (!file) return;

          const formData = new FormData();
          formData.append('file', file);

          try {
            const result = await uploadAvatar.mutateAsync(formData);
            // Update client with new avatar URL
            await updateClient.mutateAsync({
              id: client.id,
              avatarUrl: result.data.url,
            });
          } catch (error) {
            console.error('Upload failed:', error);
          }
        }}
      />
      <Button
        variant="outline"
        size="sm"
        onClick={() => document.getElementById('avatar-upload')?.click()}
      >
        <Upload className="mr-2 h-4 w-4" />
        Modifier
      </Button>
    </div>
  </div>
</div>

{/* Structured Name Section (for individuals) */}
{client?.type === 'individual' && (
  <div className="grid grid-cols-2 gap-4 mb-6">
    <div>
      <label className="text-sm font-medium">Prénom</label>
      <Input
        value={client.firstName || ''}
        onChange={(e) => handleFieldChange('firstName', e.target.value)}
      />
    </div>
    <div>
      <label className="text-sm font-medium">Nom</label>
      <Input
        value={client.lastName || ''}
        onChange={(e) => handleFieldChange('lastName', e.target.value)}
      />
    </div>
    <div>
      <label className="text-sm font-medium">Civilité</label>
      <select
        value={client.prefix || ''}
        onChange={(e) => handleFieldChange('prefix', e.target.value)}
        className="w-full px-3 py-2 border rounded"
      >
        <option value="">-</option>
        <option value="M.">M.</option>
        <option value="Mme">Mme</option>
        <option value="Dr.">Dr.</option>
      </select>
    </div>
    <div>
      <label className="text-sm font-medium">Suffixe</label>
      <Input
        value={client.suffix || ''}
        onChange={(e) => handleFieldChange('suffix', e.target.value)}
        placeholder="Jr., III, etc."
      />
    </div>
  </div>
)}

{/* Multiple Phones Section */}
<div className="mb-6">
  <div className="flex justify-between items-center mb-3">
    <h3 className="text-lg font-semibold">Téléphones</h3>
    <Button
      variant="outline"
      size="sm"
      onClick={() => {
        const newPhones = [...(client.phones || []), { type: 'mobile', number: '' }];
        handleFieldChange('phones', newPhones);
      }}
    >
      <Plus className="mr-2 h-4 w-4" />
      Ajouter
    </Button>
  </div>

  {(client?.phones || []).map((phone: any, index: number) => (
    <div key={index} className="flex gap-2 mb-2">
      <select
        value={phone.type}
        onChange={(e) => {
          const newPhones = [...client.phones];
          newPhones[index].type = e.target.value;
          handleFieldChange('phones', newPhones);
        }}
        className="w-32 px-3 py-2 border rounded"
      >
        <option value="mobile">Mobile</option>
        <option value="work">Travail</option>
        <option value="home">Domicile</option>
      </select>
      <Input
        value={phone.number}
        onChange={(e) => {
          const newPhones = [...client.phones];
          newPhones[index].number = e.target.value;
          handleFieldChange('phones', newPhones);
        }}
        placeholder="Numéro"
        className="flex-1"
      />
      <Button
        variant="ghost"
        size="sm"
        onClick={() => {
          const newPhones = client.phones.filter((_: any, i: number) => i !== index);
          handleFieldChange('phones', newPhones);
        }}
      >
        <Trash2 className="h-4 w-4" />
      </Button>
    </div>
  ))}
</div>

{/* Multiple Emails Section - Similar pattern */}
{/* Multiple Websites Section - Similar pattern */}

{/* Contacts Section (for companies/groups) */}
{client?.type === 'company' && (
  <div className="mb-6">
    <div className="flex justify-between items-center mb-3">
      <h3 className="text-lg font-semibold">Contacts</h3>
      <Button
        variant="outline"
        size="sm"
        onClick={() => {
          // Open dialog to add contact
        }}
      >
        <Plus className="mr-2 h-4 w-4" />
        Ajouter contact
      </Button>
    </div>

    {contacts.map((contact) => (
      <Card key={contact.id} className="mb-2 p-3">
        <div className="flex justify-between items-start">
          <div>
            <div className="font-semibold">
              {contact.firstName} {contact.lastName}
              {contact.isPrimary && (
                <Badge variant="default" className="ml-2">Principal</Badge>
              )}
            </div>
            {contact.title && (
              <div className="text-sm text-muted-foreground">{contact.title}</div>
            )}
            <div className="text-sm mt-1">
              {contact.email && <div>{contact.email}</div>}
              {contact.phone && <div>{contact.phone}</div>}
            </div>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => {
              // Delete contact
              deleteContact.mutate({ id: contact.id });
            }}
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        </div>
      </Card>
    ))}
  </div>
)}

{/* Custom Fields Section */}
<div className="mb-6">
  <div className="flex justify-between items-center mb-3">
    <h3 className="text-lg font-semibold">Champs personnalisés</h3>
    <Button
      variant="outline"
      size="sm"
      onClick={() => {
        const newFields = [
          ...(client.customFields || []),
          { label: '', type: 'text', value: '' }
        ];
        handleFieldChange('customFields', newFields);
      }}
    >
      <Plus className="mr-2 h-4 w-4" />
      Ajouter
    </Button>
  </div>

  {(client?.customFields || []).map((field: any, index: number) => (
    <div key={index} className="flex gap-2 mb-2">
      <Input
        value={field.label}
        onChange={(e) => {
          const newFields = [...client.customFields];
          newFields[index].label = e.target.value;
          handleFieldChange('customFields', newFields);
        }}
        placeholder="Nom du champ"
        className="w-48"
      />
      <select
        value={field.type}
        onChange={(e) => {
          const newFields = [...client.customFields];
          newFields[index].type = e.target.value;
          handleFieldChange('customFields', newFields);
        }}
        className="w-32 px-3 py-2 border rounded"
      >
        <option value="text">Texte</option>
        <option value="number">Nombre</option>
        <option value="date">Date</option>
        <option value="url">URL</option>
      </select>
      <Input
        value={field.value}
        onChange={(e) => {
          const newFields = [...client.customFields];
          newFields[index].value = e.target.value;
          handleFieldChange('customFields', newFields);
        }}
        placeholder="Valeur"
        className="flex-1"
      />
      <Button
        variant="ghost"
        size="sm"
        onClick={() => {
          const newFields = client.customFields.filter((_: any, i: number) => i !== index);
          handleFieldChange('customFields', newFields);
        }}
      >
        <Trash2 className="h-4 w-4" />
      </Button>
    </div>
  ))}
</div>
```

**Verification:**
- Form displays all new vCard fields
- Avatar/logo upload works
- Multiple phones/emails can be added/removed
- Contacts can be added for companies
- Custom fields can be added/removed
- All changes save correctly

---

## Verification

**Manual Testing:**

1. **Database Migration:**
   - ✅ Run `pnpm run db:migrate`
   - ✅ Verify new columns in clients table
   - ✅ Verify clientContacts table created

2. **File Upload:**
   - ✅ Upload avatar for individual client
   - ✅ Upload logo for company client
   - ✅ Verify files saved in `/uploads/tenant_X/{avatars|logos}/`
   - ✅ Verify cross-tenant access blocked (try accessing tenant_2 file from tenant_1 account)

3. **Client Form:**
   - ✅ Edit structured name (firstName, lastName, prefix, suffix)
   - ✅ Add multiple phones with types (mobile/work/home)
   - ✅ Add multiple emails
   - ✅ Add custom fields (text, number, date)
   - ✅ Add contacts for company client
   - ✅ Mark contact as primary

4. **Security:**
   - ✅ Try accessing another tenant's avatar URL → 403 Forbidden
   - ✅ Verify middleware logs security warnings

**checkpoint:human-verify**

Ask user to verify:
- Avatar/logo upload works for both individuals and companies
- Multiple phones/emails display correctly
- Contacts section works for companies
- Custom fields can be added and saved
- Cross-tenant file access is blocked

---

## Success Criteria

- [ ] Database migration completed with all vCard fields
- [ ] clientContacts table created
- [ ] Local VPS upload directories created with correct permissions
- [ ] Tenant-isolated file storage working (`/uploads/tenant_X/`)
- [ ] Security middleware blocks cross-tenant file access
- [ ] Avatar upload works for individuals
- [ ] Logo upload works for companies
- [ ] Multiple phones/emails/websites can be managed
- [ ] Contacts can be added to company clients
- [ ] Custom fields work (add/edit/delete)
- [ ] All changes persist correctly
- [ ] User confirms all features work

---

## Output

**Files Modified:**
- `packages/database/src/tenant/schema.ts` - Added vCard fields + clientContacts table
- `packages/database/migrations/` - New migration file
- `packages/server/src/middleware/tenantFileAccess.ts` - NEW security middleware
- `packages/server/src/utils/local-upload-service.ts` - NEW local upload service
- `packages/server/src/routes/upload.ts` - Updated for local storage
- `packages/server/src/routers/clients.ts` - Added contact management procedures
- `packages/client/src/pages/ClientDetail.tsx` - Enhanced UI for all new fields

**Infrastructure:**
- VPS: `/var/www/recording-studio-manager/uploads/tenant_X/{avatars,logos}/`
- Nginx: Proxy configuration for secure file serving

**Next Phase:**
- Phase 3.9.4-02: Import/Export vCard/Excel/CSV

**User Experience:**
- Clients now have complete vCard-compatible information
- Photos/avatars for individuals
- Logos for companies
- Multiple contact methods per client
- Unlimited custom fields
- Multi-contact support for companies
- Tenant-isolated secure file storage
