# Phase 3.9.4-02: Clients Enrichis - Import/Export vCard/Excel/CSV

**Date:** 2025-12-31
**Phase:** 3.9.4 - Clients enrichis compatible vCard
**Plan:** 02 (Import/Export)
**Estimated Context:** ~45-50%

---

## Objective

Implémenter import/export de contacts dans les formats standards: vCard (.vcf), Excel (.xlsx), et CSV (.csv). Mapping automatique des champs vCard 4.0 vers le schema enrichi, avec gestion des avatars/logos embarqués et validation des données importées.

**User Requirements:**
- Import vCard (.vcf) compatible Apple Contacts, Google Contacts
- Export vCard 4.0 (RFC 6350) avec tous les champs standards
- Import/Export Excel (.xlsx) avec template
- Import/Export CSV avec headers configurables
- Mapping automatique des champs
- Validation des données importées
- Preview avant import (afficher 5 premiers contacts)
- Gestion avatars/logos embarqués dans vCard

---

## Execution Context

@packages/server/src/routers/clients.ts (import/export procedures)
@packages/server/src/utils/vcard-service.ts (NEW - vCard parser/generator)
@packages/server/src/utils/excel-service.ts (NEW - Excel import/export)
@packages/client/src/pages/Clients.tsx (import/export UI)
@packages/client/src/components/ImportClientsDialog.tsx (NEW)

**Tech Stack:**
- Node.js + TypeScript
- vcard4 (vCard 4.0 RFC 6350 parser/generator)
- exceljs (Excel XLSX manipulation)
- csv-parse / csv-stringify (CSV handling)
- React 19.1 (UI)
- tRPC (API)

**Libraries to Install:**
```bash
pnpm add vcard4 exceljs csv-parse csv-stringify
pnpm add -D @types/node
```

**Standards:**
- vCard 4.0 (RFC 6350)
- Excel Office Open XML (.xlsx)
- CSV RFC 4180

---

## Context

**Current Schema (from Plan 3.9.4-01):**
```typescript
clients {
  // Basic
  id, name, artistName, email, phone, type
  // vCard structured
  firstName, lastName, middleName, prefix, suffix
  avatarUrl, logoUrl
  phones: [{type, number}]
  emails: [{type, email}]
  websites: [{type, url}]
  // Address
  street, city, region, postalCode, country, address
  // Personal
  birthday, gender
  // Custom
  customFields: [{label, type, value}]
}

clientContacts {
  id, clientId, firstName, lastName, title, email, phone, isPrimary
}
```

**vCard 4.0 Mapping:**
- FN → name (formatted name)
- N → firstName;lastName;middleName;prefix;suffix
- TEL → phones[]
- EMAIL → emails[]
- URL → websites[]
- ADR → street;city;region;postalCode;country
- BDAY → birthday
- GENDER → gender
- PHOTO → avatarUrl (base64 or URL)
- LOGO → logoUrl
- ORG → name (for companies)
- TITLE → clientContacts.title

---

## Tasks

### Task 1: Install Dependencies & vCard Service (AUTO)

**Objective:** Install libraries and create vCard import/export service.

**Actions:**

1. Install dependencies:
```bash
pnpm add vcard4 exceljs csv-parse csv-stringify
```

2. Create `packages/server/src/utils/vcard-service.ts`:

```typescript
import { VCard, Property } from 'vcard4';
import type { Client, ClientContact } from '@rsm/database/tenant/schema';

/**
 * Convert Client to vCard 4.0
 */
export function clientToVCard(client: Client, contacts?: ClientContact[]): string {
  const vcard = new VCard();

  // VERSION (required)
  vcard.version = '4.0';

  // FN - Formatted Name (required)
  vcard.fn = client.name;

  // N - Structured Name
  if (client.firstName || client.lastName) {
    vcard.n = {
      familyName: client.lastName || '',
      givenName: client.firstName || '',
      additionalName: client.middleName || '',
      prefix: client.prefix || '',
      suffix: client.suffix || '',
    };
  }

  // NICKNAME - Artist Name
  if (client.artistName) {
    vcard.nickname = [client.artistName];
  }

  // TEL - Phone Numbers
  if (client.phones && client.phones.length > 0) {
    client.phones.forEach((phone: any) => {
      vcard.addTel(phone.number, {
        type: phone.type || 'voice',
      });
    });
  } else if (client.phone) {
    vcard.addTel(client.phone);
  }

  // EMAIL - Email Addresses
  if (client.emails && client.emails.length > 0) {
    client.emails.forEach((email: any) => {
      vcard.addEmail(email.email, {
        type: email.type || 'internet',
      });
    });
  } else if (client.email) {
    vcard.addEmail(client.email);
  }

  // URL - Websites
  if (client.websites && client.websites.length > 0) {
    client.websites.forEach((website: any) => {
      vcard.addUrl(website.url);
    });
  }

  // ADR - Address
  if (client.street || client.city || client.country) {
    vcard.addAdr({
      street: client.street || '',
      locality: client.city || '',
      region: client.region || '',
      postalCode: client.postalCode || '',
      country: client.country || '',
    });
  }

  // BDAY - Birthday
  if (client.birthday) {
    vcard.bday = client.birthday;
  }

  // GENDER
  if (client.gender) {
    vcard.gender = { sex: client.gender };
  }

  // PHOTO - Avatar URL (external reference)
  if (client.avatarUrl) {
    vcard.addPhoto(client.avatarUrl, { mediatype: 'image/jpeg' });
  }

  // LOGO - Company Logo (external reference)
  if (client.logoUrl) {
    vcard.addLogo(client.logoUrl, { mediatype: 'image/png' });
  }

  // ORG - Organization (for companies)
  if (client.type === 'company') {
    vcard.org = [client.name];
  }

  // KIND - Type of entity
  vcard.kind = client.type === 'company' ? 'org' : 'individual';

  // NOTE - Notes
  if (client.notes) {
    vcard.note = client.notes;
  }

  // Custom fields as extended properties
  if (client.customFields && client.customFields.length > 0) {
    client.customFields.forEach((field: any) => {
      vcard.add(new Property({
        name: `X-${field.label.toUpperCase().replace(/\s+/g, '-')}`,
        value: String(field.value),
      }));
    });
  }

  // Add contacts as MEMBER for groups/organizations
  if (contacts && contacts.length > 0) {
    contacts.forEach((contact) => {
      const contactVCard = `${contact.firstName} ${contact.lastName}`;
      if (contact.email) {
        vcard.add(new Property({
          name: 'MEMBER',
          value: `mailto:${contact.email}`,
        }));
      }
    });
  }

  return vcard.toString();
}

/**
 * Parse vCard to Client data
 */
export function vCardToClient(vcardString: string): Partial<Client> {
  const vcard = VCard.parse(vcardString);

  const client: Partial<Client> = {
    name: vcard.fn || 'Sans nom',
    type: vcard.kind === 'org' ? 'company' : 'individual',
  };

  // N - Structured Name
  if (vcard.n) {
    client.firstName = vcard.n.givenName || undefined;
    client.lastName = vcard.n.familyName || undefined;
    client.middleName = vcard.n.additionalName || undefined;
    client.prefix = vcard.n.prefix || undefined;
    client.suffix = vcard.n.suffix || undefined;
  }

  // NICKNAME - Artist Name
  if (vcard.nickname && vcard.nickname.length > 0) {
    client.artistName = vcard.nickname[0];
  }

  // TEL - Phones
  const tels = vcard.getTel();
  if (tels && tels.length > 0) {
    client.phones = tels.map((tel: any) => ({
      type: tel.type?.[0] || 'voice',
      number: tel.value,
    }));
    // Set primary phone
    client.phone = tels[0].value;
  }

  // EMAIL - Emails
  const emails = vcard.getEmail();
  if (emails && emails.length > 0) {
    client.emails = emails.map((email: any) => ({
      type: email.type?.[0] || 'internet',
      email: email.value,
    }));
    // Set primary email
    client.email = emails[0].value;
  }

  // URL - Websites
  const urls = vcard.getUrl();
  if (urls && urls.length > 0) {
    client.websites = urls.map((url: any) => ({
      type: 'website',
      url: url.value,
    }));
  }

  // ADR - Address
  const addresses = vcard.getAdr();
  if (addresses && addresses.length > 0) {
    const addr = addresses[0];
    client.street = addr.street || undefined;
    client.city = addr.locality || undefined;
    client.region = addr.region || undefined;
    client.postalCode = addr.postalCode || undefined;
    client.country = addr.country || undefined;
  }

  // BDAY - Birthday
  if (vcard.bday) {
    client.birthday = vcard.bday;
  }

  // GENDER
  if (vcard.gender) {
    client.gender = vcard.gender.sex;
  }

  // NOTE
  if (vcard.note) {
    client.notes = vcard.note;
  }

  // ORG - Organization name for companies
  if (vcard.org && vcard.org.length > 0) {
    client.name = vcard.org[0];
  }

  // Extract custom fields from X- properties
  const customFields: any[] = [];
  vcard.properties.forEach((prop: Property) => {
    if (prop.name.startsWith('X-')) {
      customFields.push({
        label: prop.name.substring(2).replace(/-/g, ' '),
        type: 'text',
        value: prop.value,
      });
    }
  });
  if (customFields.length > 0) {
    client.customFields = customFields;
  }

  return client;
}

/**
 * Parse multiple vCards from .vcf file
 */
export function parseVCardFile(fileContent: string): Partial<Client>[] {
  const clients: Partial<Client>[] = [];

  // Split by BEGIN:VCARD
  const vcards = fileContent.split(/BEGIN:VCARD/i).filter(s => s.trim());

  vcards.forEach((vcardText) => {
    try {
      const fullVCard = 'BEGIN:VCARD' + vcardText;
      const client = vCardToClient(fullVCard);
      clients.push(client);
    } catch (error) {
      console.error('[vCard] Parse error:', error);
    }
  });

  return clients;
}
```

**Verification:**
- vcard4 library installed
- clientToVCard generates valid vCard 4.0
- vCardToClient parses vCard correctly
- All fields mapped properly

---

### Task 2: Excel Import/Export Service (AUTO)

**Objective:** Create Excel service for import/export with template.

**Actions:**

1. Create `packages/server/src/utils/excel-service.ts`:

```typescript
import ExcelJS from 'exceljs';
import type { Client } from '@rsm/database/tenant/schema';

/**
 * Export clients to Excel
 */
export async function clientsToExcel(clients: Client[]): Promise<Buffer> {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('Clients');

  // Define columns
  worksheet.columns = [
    { header: 'ID', key: 'id', width: 10 },
    { header: 'Type', key: 'type', width: 12 },
    { header: 'Prénom', key: 'firstName', width: 15 },
    { header: 'Nom', key: 'lastName', width: 15 },
    { header: 'Nom complet', key: 'name', width: 25 },
    { header: 'Nom artiste', key: 'artistName', width: 20 },
    { header: 'Email', key: 'email', width: 30 },
    { header: 'Téléphone', key: 'phone', width: 15 },
    { header: 'Rue', key: 'street', width: 30 },
    { header: 'Ville', key: 'city', width: 20 },
    { header: 'Code postal', key: 'postalCode', width: 12 },
    { header: 'Région', key: 'region', width: 20 },
    { header: 'Pays', key: 'country', width: 15 },
    { header: 'Anniversaire', key: 'birthday', width: 15 },
    { header: 'Genre', key: 'gender', width: 10 },
    { header: 'Notes', key: 'notes', width: 40 },
  ];

  // Style header row
  worksheet.getRow(1).font = { bold: true };
  worksheet.getRow(1).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FFCCCCCC' },
  };

  // Add data rows
  clients.forEach((client) => {
    worksheet.addRow({
      id: client.id,
      type: client.type === 'company' ? 'Entreprise' : 'Particulier',
      firstName: client.firstName,
      lastName: client.lastName,
      name: client.name,
      artistName: client.artistName,
      email: client.email,
      phone: client.phone,
      street: client.street,
      city: client.city,
      postalCode: client.postalCode,
      region: client.region,
      country: client.country,
      birthday: client.birthday,
      gender: client.gender,
      notes: client.notes,
    });
  });

  // Generate buffer
  const buffer = await workbook.xlsx.writeBuffer();
  return Buffer.from(buffer);
}

/**
 * Parse Excel file to clients
 */
export async function excelToClients(fileBuffer: Buffer): Promise<Partial<Client>[]> {
  const workbook = new ExcelJS.Workbook();
  await workbook.xlsx.load(fileBuffer);

  const worksheet = workbook.getWorksheet('Clients') || workbook.worksheets[0];
  const clients: Partial<Client>[] = [];

  // Skip header row
  worksheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
    if (rowNumber === 1) return; // Skip header

    const client: Partial<Client> = {
      type: row.getCell(2).value === 'Entreprise' ? 'company' : 'individual',
      firstName: row.getCell(3).value?.toString(),
      lastName: row.getCell(4).value?.toString(),
      name: row.getCell(5).value?.toString() || '',
      artistName: row.getCell(6).value?.toString(),
      email: row.getCell(7).value?.toString(),
      phone: row.getCell(8).value?.toString(),
      street: row.getCell(9).value?.toString(),
      city: row.getCell(10).value?.toString(),
      postalCode: row.getCell(11).value?.toString(),
      region: row.getCell(12).value?.toString(),
      country: row.getCell(13).value?.toString(),
      birthday: row.getCell(14).value?.toString(),
      gender: row.getCell(15).value?.toString(),
      notes: row.getCell(16).value?.toString(),
    };

    if (client.name) {
      clients.push(client);
    }
  });

  return clients;
}

/**
 * Generate Excel template for import
 */
export async function generateExcelTemplate(): Promise<Buffer> {
  const workbook = new ExcelJS.Workbook();
  const worksheet = workbook.addWorksheet('Clients');

  // Same columns as export
  worksheet.columns = [
    { header: 'Type', key: 'type', width: 12 },
    { header: 'Prénom', key: 'firstName', width: 15 },
    { header: 'Nom', key: 'lastName', width: 15 },
    { header: 'Nom complet', key: 'name', width: 25 },
    { header: 'Nom artiste', key: 'artistName', width: 20 },
    { header: 'Email', key: 'email', width: 30 },
    { header: 'Téléphone', key: 'phone', width: 15 },
    { header: 'Rue', key: 'street', width: 30 },
    { header: 'Ville', key: 'city', width: 20 },
    { header: 'Code postal', key: 'postalCode', width: 12 },
    { header: 'Région', key: 'region', width: 20 },
    { header: 'Pays', key: 'country', width: 15 },
  ];

  // Style header
  worksheet.getRow(1).font = { bold: true };
  worksheet.getRow(1).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FFCCCCCC' },
  };

  // Add example rows
  worksheet.addRow({
    type: 'Particulier',
    firstName: 'Jean',
    lastName: 'Dupont',
    name: 'Jean Dupont',
    artistName: 'DJ Jean',
    email: 'jean@example.com',
    phone: '+33 6 12 34 56 78',
    street: '123 Rue de la Musique',
    city: 'Paris',
    postalCode: '75001',
    region: 'Île-de-France',
    country: 'France',
  });

  const buffer = await workbook.xlsx.writeBuffer();
  return Buffer.from(buffer);
}
```

**Verification:**
- ExcelJS library works
- Excel export generates valid .xlsx
- Excel import parses correctly
- Template has example data

---

### Task 3: CSV Import/Export Service (AUTO)

**Objective:** Create CSV service for import/export.

**Actions:**

1. Create `packages/server/src/utils/csv-service.ts`:

```typescript
import { parse } from 'csv-parse/sync';
import { stringify } from 'csv-stringify/sync';
import type { Client } from '@rsm/database/tenant/schema';

/**
 * Export clients to CSV
 */
export function clientsToCSV(clients: Client[]): string {
  const records = clients.map((client) => ({
    ID: client.id,
    Type: client.type === 'company' ? 'Entreprise' : 'Particulier',
    Prénom: client.firstName || '',
    Nom: client.lastName || '',
    'Nom complet': client.name,
    'Nom artiste': client.artistName || '',
    Email: client.email || '',
    Téléphone: client.phone || '',
    Rue: client.street || '',
    Ville: client.city || '',
    'Code postal': client.postalCode || '',
    Région: client.region || '',
    Pays: client.country || '',
    Anniversaire: client.birthday || '',
    Genre: client.gender || '',
    Notes: client.notes || '',
  }));

  return stringify(records, {
    header: true,
    delimiter: ',',
    quoted: true,
  });
}

/**
 * Parse CSV to clients
 */
export function csvToClients(csvContent: string): Partial<Client>[] {
  const records = parse(csvContent, {
    columns: true,
    skip_empty_lines: true,
    trim: true,
  });

  return records.map((row: any) => ({
    type: row.Type === 'Entreprise' ? 'company' : 'individual',
    firstName: row['Prénom'] || undefined,
    lastName: row['Nom'] || undefined,
    name: row['Nom complet'] || '',
    artistName: row['Nom artiste'] || undefined,
    email: row['Email'] || undefined,
    phone: row['Téléphone'] || undefined,
    street: row['Rue'] || undefined,
    city: row['Ville'] || undefined,
    postalCode: row['Code postal'] || undefined,
    region: row['Région'] || undefined,
    country: row['Pays'] || undefined,
    birthday: row['Anniversaire'] || undefined,
    gender: row['Genre'] || undefined,
    notes: row['Notes'] || undefined,
  }));
}
```

**Verification:**
- CSV export generates valid CSV
- CSV import parses correctly
- French headers work

---

### Task 4: tRPC Import/Export Procedures (AUTO)

**Objective:** Add tRPC procedures for import/export.

**Actions:**

1. Update `packages/server/src/routers/clients.ts`:

```typescript
import { z } from 'zod';
import { clientToVCard, parseVCardFile } from '../utils/vcard-service';
import { clientsToExcel, excelToClients, generateExcelTemplate } from '../utils/excel-service';
import { clientsToCSV, csvToClients } from '../utils/csv-service';

// Add to clientsRouter:

// Export clients as vCard
exportVCard: protectedTenantProcedure
  .input(z.object({ ids: z.array(z.number()).optional() }))
  .mutation(async ({ ctx, input }) => {
    // Get clients to export
    const query = input.ids
      ? ctx.tenantDb.select().from(clients).where(inArray(clients.id, input.ids))
      : ctx.tenantDb.select().from(clients);

    const clientsToExport = await query;

    // Generate vCards
    const vcards = await Promise.all(
      clientsToExport.map(async (client) => {
        // Get contacts for this client
        const contacts = await ctx.tenantDb
          .select()
          .from(clientContacts)
          .where(eq(clientContacts.clientId, client.id));

        return clientToVCard(client, contacts);
      })
    );

    // Combine all vCards
    const vcardContent = vcards.join('\n');

    return {
      content: vcardContent,
      filename: `clients_${Date.now()}.vcf`,
      mimeType: 'text/vcard',
    };
  }),

// Import vCard file
importVCard: protectedTenantProcedure
  .input(z.object({ content: z.string() }))
  .mutation(async ({ ctx, input }) => {
    // Parse vCard file
    const parsedClients = parseVCardFile(input.content);

    // Preview first 5
    const preview = parsedClients.slice(0, 5);

    // Import all
    const imported = await Promise.all(
      parsedClients.map(async (clientData) => {
        const [newClient] = await ctx.tenantDb
          .insert(clients)
          .values({
            ...clientData,
            isActive: true,
            portalAccess: false,
          })
          .returning();

        return newClient;
      })
    );

    return {
      count: imported.length,
      preview,
    };
  }),

// Export Excel
exportExcel: protectedTenantProcedure
  .input(z.object({ ids: z.array(z.number()).optional() }))
  .mutation(async ({ ctx, input }) => {
    const query = input.ids
      ? ctx.tenantDb.select().from(clients).where(inArray(clients.id, input.ids))
      : ctx.tenantDb.select().from(clients);

    const clientsToExport = await query;

    const buffer = await clientsToExcel(clientsToExport);

    return {
      content: buffer.toString('base64'),
      filename: `clients_${Date.now()}.xlsx`,
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    };
  }),

// Import Excel
importExcel: protectedTenantProcedure
  .input(z.object({ content: z.string() }))
  .mutation(async ({ ctx, input }) => {
    const buffer = Buffer.from(input.content, 'base64');
    const parsedClients = await excelToClients(buffer);

    const preview = parsedClients.slice(0, 5);

    const imported = await Promise.all(
      parsedClients.map(async (clientData) => {
        const [newClient] = await ctx.tenantDb
          .insert(clients)
          .values({
            ...clientData,
            isActive: true,
            portalAccess: false,
          })
          .returning();

        return newClient;
      })
    );

    return {
      count: imported.length,
      preview,
    };
  }),

// Download Excel template
downloadExcelTemplate: protectedTenantProcedure
  .query(async () => {
    const buffer = await generateExcelTemplate();

    return {
      content: buffer.toString('base64'),
      filename: 'template_clients.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    };
  }),

// Export CSV
exportCSV: protectedTenantProcedure
  .input(z.object({ ids: z.array(z.number()).optional() }))
  .mutation(async ({ ctx, input }) => {
    const query = input.ids
      ? ctx.tenantDb.select().from(clients).where(inArray(clients.id, input.ids))
      : ctx.tenantDb.select().from(clients);

    const clientsToExport = await query;

    const csv = clientsToCSV(clientsToExport);

    return {
      content: csv,
      filename: `clients_${Date.now()}.csv`,
      mimeType: 'text/csv',
    };
  }),

// Import CSV
importCSV: protectedTenantProcedure
  .input(z.object({ content: z.string() }))
  .mutation(async ({ ctx, input }) => {
    const parsedClients = csvToClients(input.content);

    const preview = parsedClients.slice(0, 5);

    const imported = await Promise.all(
      parsedClients.map(async (clientData) => {
        const [newClient] = await ctx.tenantDb
          .insert(clients)
          .values({
            ...clientData,
            isActive: true,
            portalAccess: false,
          })
          .returning();

        return newClient;
      })
    );

    return {
      count: imported.length,
      preview,
    };
  }),
```

**Verification:**
- All import/export procedures compile
- vCard export works
- Excel export works
- CSV export works
- Import procedures validate correctly

---

### Task 5: Frontend Import/Export UI (AUTO)

**Objective:** Add import/export buttons and dialog to Clients page.

**Actions:**

1. Update `packages/client/src/pages/Clients.tsx` (header section):

```typescript
import { FileDown, FileUp, Download } from 'lucide-react';
import { ImportClientsDialog } from '@/components/ImportClientsDialog';

// Add state
const [showImportDialog, setShowImportDialog] = useState(false);
const [importFormat, setImportFormat] = useState<'vcard' | 'excel' | 'csv'>('vcard');

// Add mutations
const exportVCard = trpc.clients.exportVCard.useMutation();
const exportExcel = trpc.clients.exportExcel.useMutation();
const exportCSV = trpc.clients.exportCSV.useMutation();
const downloadTemplate = trpc.clients.downloadExcelTemplate.useQuery();

// Add export handlers
const handleExport = async (format: 'vcard' | 'excel' | 'csv') => {
  try {
    let result;
    if (format === 'vcard') {
      result = await exportVCard.mutateAsync({});
    } else if (format === 'excel') {
      result = await exportExcel.mutateAsync({});
    } else {
      result = await exportCSV.mutateAsync({});
    }

    // Download file
    const blob = format === 'excel'
      ? new Blob([Buffer.from(result.content, 'base64')], { type: result.mimeType })
      : new Blob([result.content], { type: result.mimeType });

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = result.filename;
    a.click();
    URL.revokeObjectURL(url);

    toast.success(`Export ${format.toUpperCase()} réussi`);
  } catch (error) {
    toast.error('Erreur lors de l\'export');
  }
};

// Add in header (after search, before "Nouveau" button):

{/* Export Dropdown */}
<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button variant="outline" size="sm">
      <FileDown className="mr-2 h-4 w-4" />
      Exporter
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent>
    <DropdownMenuItem onClick={() => handleExport('vcard')}>
      <FileDown className="mr-2 h-4 w-4" />
      vCard (.vcf)
    </DropdownMenuItem>
    <DropdownMenuItem onClick={() => handleExport('excel')}>
      <FileDown className="mr-2 h-4 w-4" />
      Excel (.xlsx)
    </DropdownMenuItem>
    <DropdownMenuItem onClick={() => handleExport('csv')}>
      <FileDown className="mr-2 h-4 w-4" />
      CSV (.csv)
    </DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>

{/* Import Dropdown */}
<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button variant="outline" size="sm">
      <FileUp className="mr-2 h-4 w-4" />
      Importer
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent>
    <DropdownMenuItem onClick={() => {
      setImportFormat('vcard');
      setShowImportDialog(true);
    }}>
      <FileUp className="mr-2 h-4 w-4" />
      vCard (.vcf)
    </DropdownMenuItem>
    <DropdownMenuItem onClick={() => {
      setImportFormat('excel');
      setShowImportDialog(true);
    }}>
      <FileUp className="mr-2 h-4 w-4" />
      Excel (.xlsx)
    </DropdownMenuItem>
    <DropdownMenuItem onClick={() => {
      setImportFormat('csv');
      setShowImportDialog(true);
    }}>
      <FileUp className="mr-2 h-4 w-4" />
      CSV (.csv)
    </DropdownMenuItem>
    <DropdownMenuSeparator />
    <DropdownMenuItem onClick={() => {
      // Download template
      const blob = new Blob([Buffer.from(downloadTemplate.data.content, 'base64')], {
        type: downloadTemplate.data.mimeType,
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = downloadTemplate.data.filename;
      a.click();
      URL.revokeObjectURL(url);
    }}>
      <Download className="mr-2 h-4 w-4" />
      Télécharger template Excel
    </DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>

{/* Import Dialog */}
<ImportClientsDialog
  open={showImportDialog}
  onClose={() => setShowImportDialog(false)}
  format={importFormat}
  onImportComplete={() => {
    setShowImportDialog(false);
    refetch();
  }}
/>
```

2. Create `packages/client/src/components/ImportClientsDialog.tsx`:

```typescript
import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Upload, CheckCircle } from 'lucide-react';
import { trpc } from '@/lib/trpc';
import { toast } from 'sonner';

interface Props {
  open: boolean;
  onClose: () => void;
  format: 'vcard' | 'excel' | 'csv';
  onImportComplete: () => void;
}

export function ImportClientsDialog({ open, onClose, format, onImportComplete }: Props) {
  const [file, setFile] = useState<File | null>(null);
  const [preview, setPreview] = useState<any[]>([]);
  const [importing, setImporting] = useState(false);

  const importVCard = trpc.clients.importVCard.useMutation();
  const importExcel = trpc.clients.importExcel.useMutation();
  const importCSV = trpc.clients.importCSV.useMutation();

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (!selectedFile) return;

    setFile(selectedFile);

    // Read file and preview
    const reader = new FileReader();
    reader.onload = async (event) => {
      const content = event.target?.result as string;

      try {
        let result;
        if (format === 'vcard') {
          result = await importVCard.mutateAsync({ content });
        } else if (format === 'excel') {
          const base64 = btoa(content);
          result = await importExcel.mutateAsync({ content: base64 });
        } else {
          result = await importCSV.mutateAsync({ content });
        }

        setPreview(result.preview);
        toast.success(`${result.count} contacts trouvés`);
      } catch (error) {
        toast.error('Erreur lors de la lecture du fichier');
      }
    };

    if (format === 'excel') {
      reader.readAsArrayBuffer(selectedFile);
    } else {
      reader.readAsText(selectedFile);
    }
  };

  const handleImport = async () => {
    if (!file) return;

    setImporting(true);
    try {
      toast.success('Import réussi!');
      onImportComplete();
    } catch (error) {
      toast.error('Erreur lors de l\'import');
    } finally {
      setImporting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>
            Importer des clients - {format.toUpperCase()}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          {/* File Upload */}
          <div>
            <input
              type="file"
              id="import-file"
              accept={
                format === 'vcard'
                  ? '.vcf'
                  : format === 'excel'
                  ? '.xlsx'
                  : '.csv'
              }
              className="hidden"
              onChange={handleFileSelect}
            />
            <Button
              variant="outline"
              onClick={() => document.getElementById('import-file')?.click()}
            >
              <Upload className="mr-2 h-4 w-4" />
              Choisir un fichier {format.toUpperCase()}
            </Button>
            {file && (
              <div className="mt-2 text-sm text-muted-foreground">
                Fichier: {file.name}
              </div>
            )}
          </div>

          {/* Preview */}
          {preview.length > 0 && (
            <div className="border rounded p-4">
              <h4 className="font-semibold mb-2">
                Aperçu (5 premiers contacts)
              </h4>
              <div className="space-y-2">
                {preview.map((client, idx) => (
                  <div key={idx} className="flex items-center gap-2 text-sm">
                    <CheckCircle className="h-4 w-4 text-green-500" />
                    <span className="font-medium">{client.name}</span>
                    {client.email && (
                      <span className="text-muted-foreground">
                        ({client.email})
                      </span>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Actions */}
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={onClose}>
              Annuler
            </Button>
            <Button
              onClick={handleImport}
              disabled={!file || importing}
            >
              {importing ? 'Import en cours...' : 'Importer'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**Verification:**
- Import/Export dropdown menus appear
- vCard export downloads .vcf file
- Excel export downloads .xlsx file
- CSV export downloads .csv file
- Template download works
- Import dialog shows preview
- Import completes successfully

---

## Verification

**Manual Testing:**

1. **vCard Export:**
   - ✅ Export all clients as .vcf
   - ✅ Open in Apple Contacts → imports correctly
   - ✅ Verify all fields present (name, phones, emails, address)

2. **vCard Import:**
   - ✅ Export from Apple Contacts
   - ✅ Import into app
   - ✅ Verify preview shows 5 contacts
   - ✅ Verify all contacts imported

3. **Excel Export/Import:**
   - ✅ Export clients to Excel
   - ✅ Open in Excel/LibreOffice → correct format
   - ✅ Download template
   - ✅ Fill template with test data
   - ✅ Import filled template
   - ✅ Verify clients created

4. **CSV Export/Import:**
   - ✅ Export to CSV
   - ✅ Verify French headers
   - ✅ Import CSV back
   - ✅ Verify data matches

**checkpoint:human-verify**

Ask user to verify:
- vCard import/export works with Apple/Google Contacts
- Excel template is clear and usable
- CSV format is correct
- All fields map correctly
- Import preview is helpful

---

## Success Criteria

- [ ] vCard export generates RFC 6350 compliant .vcf files
- [ ] vCard import parses Apple/Google Contacts exports
- [ ] Excel export generates valid .xlsx with styled headers
- [ ] Excel import parses correctly
- [ ] Excel template available for download
- [ ] CSV export/import works with French headers
- [ ] Import preview shows first 5 contacts
- [ ] All vCard fields map correctly (name, phones, emails, address, birthday, etc.)
- [ ] Import validates data before inserting
- [ ] Duplicate detection (optional enhancement)
- [ ] User confirms all formats work

---

## Output

**Files Created:**
- `packages/server/src/utils/vcard-service.ts` - vCard parser/generator
- `packages/server/src/utils/excel-service.ts` - Excel import/export
- `packages/server/src/utils/csv-service.ts` - CSV import/export
- `packages/client/src/components/ImportClientsDialog.tsx` - Import UI

**Files Modified:**
- `packages/server/src/routers/clients.ts` - Import/export procedures
- `packages/client/src/pages/Clients.tsx` - Import/export buttons

**Dependencies Added:**
- `vcard4` - vCard 4.0 RFC 6350 library
- `exceljs` - Excel XLSX manipulation
- `csv-parse` / `csv-stringify` - CSV handling

**Next Phase:**
- Phase 3.9.5: Modes d'affichage multiples (Table/Grid/Kanban)

**User Experience:**
- Users can export contacts to vCard/Excel/CSV
- Users can import contacts from other systems
- Compatible with Apple Contacts, Google Contacts
- Excel template makes bulk import easy
- Preview before import prevents errors
