---
phase: 03-billing-infrastructure
plan: 2
type: execute
---

<objective>
Implement usage limits enforcement and subscription management UI (upgrade/downgrade/cancel).

Purpose: Enforce tier limits (sessions/month, storage), provide self-service subscription changes.
Output: Middleware enforcing limits, tRPC endpoints for subscription management, usage dashboard data.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-billing-infrastructure/DISCOVERY.md
@.planning/phases/03-billing-infrastructure/03-01-SUMMARY.md

**Prior decisions from Plan 1:**
- Subscription plans seeded with limits in features JSON
- Organizations table has subscriptionTier and billing period fields
- Webhook handlers update current_period_start/end on payment success

**Codebase constraints:**
- Usage tracked in tenant databases (sessions table, storage calculated)
- Limits stored in master DB (subscriptionPlans.features JSON)
- Enforcement happens at tRPC router level before DB writes

**Integration points:**
- Sessions router: Check limit before creating booking
- Projects router: Check storage limit before track upload
- Organizations router: Add subscription management endpoints
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usage limits middleware</name>
  <files>packages/server/src/middleware/subscription-limits.ts (create)</files>
  <action>
Create middleware to check subscription limits before resource creation.

Port from Python utils/subscription_limits.py (lines 1-200).

Create packages/server/src/middleware/subscription-limits.ts with:

1. **checkSessionLimit()**:
   - Get organization from context
   - Fetch current plan from subscriptionPlans table
   - Query tenant DB: count sessions WHERE startTime >= current_period_start
   - Compare against plan.features.maxSessions
   - If unlimited (maxSessions = null), allow
   - If exceeded, throw TRPCError "Monthly session limit reached. Upgrade to Pro for unlimited sessions."

2. **checkStorageLimit()**:
   - Get organization and tenant DB
   - Sum storage from projects.tracks (file sizes)
   - Compare against plan.features.maxStorage (GB)
   - If exceeded, throw TRPCError with upgrade CTA

3. **getUsageStats()**:
   - Return { sessionsUsed, sessionsLimit, storageUsed, storageLimit, percentage }
   - Used by dashboard to show usage meters

Add helper getOrganizationPlan(orgId) to fetch plan with limits.

Port pattern from Python subscription_limits.py get_limits_status_api() (lines 150-200).
</action>
  <verify>
- tsc compiles successfully
- Unit test: checkSessionLimit() throws when limit exceeded
- Unit test: checkSessionLimit() allows when under limit
- Unit test: unlimited plan (-1 or null) never blocks
  </verify>
  <done>Middleware functions enforce session and storage limits, throw clear error messages with upgrade CTAs</done>
</task>

<task type="auto">
  <name>Task 2: Integrate limit checks in sessions and projects routers</name>
  <files>packages/server/src/routers/sessions.ts, packages/server/src/routers/projects.ts</files>
  <action>
Add limit enforcement to resource creation endpoints.

**In sessions.ts (createSession mutation):**
```typescript
// Before creating session
await checkSessionLimit(ctx.organizationId);

// Then proceed with session creation
const session = await tenantDb.insert(sessions).values(...);
```

**In projects.ts (uploadTrack mutation):**
```typescript
// Before uploading track
await checkStorageLimit(ctx.organizationId, uploadedFileSize);

// Then proceed with track upload
const track = await tenantDb.insert(tracks).values(...);
```

Import checkSessionLimit and checkStorageLimit from middleware/subscription-limits.ts.

Handle TRPCError gracefully - client will show upgrade modal.

Port pattern from Python web/sessions_routes.py (limit checks before create).
</action>
  <verify>
- Attempting to create session when at limit returns 400 with "upgrade" error code
- Attempting to upload track when storage full returns 400 with limit message
- Pro plan (unlimited sessions) never blocks session creation
  </verify>
  <done>Sessions and projects routers enforce limits before resource creation, return actionable error messages</done>
</task>

<task type="auto">
  <name>Task 3: Add subscription management endpoints to organizations router</name>
  <files>packages/server/src/routers/organizations.ts</files>
  <action>
Add subscription management procedures to organizations router.

Port from Python billing_routes.py lines 141-299 (upgrade, downgrade, cancel).

Add procedures:

1. **upgradeSubscription** (mutation):
   - Input: { planId: number, billingPeriod: "monthly" | "yearly" }
   - Validate new plan is higher tier than current
   - Get Stripe subscription from organizations.stripe_subscription_id
   - Update subscription with new price via Stripe API (proration automatic)
   - Update organizations table with new planId
   - Return { status: "success", newPlan, proratedAmount }

2. **downgradeSubscription** (mutation):
   - Input: { planId: number, immediate: boolean }
   - Validate new plan is lower tier
   - If immediate: Update subscription now (prorated refund)
   - If not immediate: Schedule downgrade at period end (cancel_at_period_end)
   - Update organizations table
   - Return { status: "success", effectiveDate }

3. **cancelSubscription** (mutation):
   - Input: { immediate: boolean }
   - Set cancel_at_period_end = true (default) OR delete subscription (immediate)
   - Update organizations.status = "CANCELING" (if end of period) or "CANCELED" (immediate)
   - Send cancellation email
   - Return { status: "canceled", effectiveDate }

4. **getSubscriptionInfo** (query):
   - Fetch Stripe subscription with default_payment_method expanded
   - Return { status, plan, billingPeriod, currentPeriodEnd, cancelAtPeriodEnd, paymentMethod }

Use stripe.subscriptions.update() and stripe.subscriptions.cancel() APIs.
All operations require authentication (ctx.userId must match organization.ownerId).

Port from Python stripe_subscriptions.py lines 200-400.
</action>
  <verify>
- Upgrade from Starter to Pro updates Stripe subscription and returns prorated amount
- Downgrade scheduled for period end sets cancel_at_period_end = true
- Immediate cancel deletes Stripe subscription and sets org status CANCELED
- getSubscriptionInfo returns payment method details (last4, brand)
  </verify>
  <done>Organizations router exposes upgrade/downgrade/cancel endpoints with Stripe API integration, proper authorization checks</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] Creating session at limit throws TRPCError with upgrade message
- [ ] Uploading track exceeding storage shows actionable error
- [ ] Upgrade endpoint updates Stripe subscription with proration
- [ ] Downgrade endpoint schedules change for period end
- [ ] Cancel endpoint marks subscription for cancellation
- [ ] getSubscriptionInfo returns current plan and payment method
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Usage limits enforced at API level before DB writes
- Subscription management endpoints work with Stripe API
- Clear upgrade CTAs when limits reached
- Pro plan users have unlimited sessions (no blocking)
</success_criteria>

<output>
After completion, create `.planning/phases/03-billing-infrastructure/03-02-SUMMARY.md`
</output>
